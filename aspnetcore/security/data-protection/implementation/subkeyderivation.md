---
title: Alt anahtar türetme ve ASP.NET Core kimliği doğrulanmış şifreleme
author: rick-anderson
description: ASP.NET Core veri koruma uygulama ayrıntılarını alt anahtarını türetme ve kimliği doğrulanmış şifreleme öğrenin.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: 37e7b01700e8a6b755b5ed16a9d7d75a9eeb970e
ms.sourcegitcommit: 24b1f6decbb17bb22a45166e5fdb0845c65af498
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/01/2019
ms.locfileid: "57072819"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="9a791-103">Alt anahtar türetme ve ASP.NET Core kimliği doğrulanmış şifreleme</span><span class="sxs-lookup"><span data-stu-id="9a791-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="9a791-104">Çoğu anahtar halkası anahtarlarında entropi çeşit içerir ve algoritmik bilgiler belirten "CBC modunda şifreleme + HMAC doğrulama" veya "GCM şifreleme + doğrulama".</span><span class="sxs-lookup"><span data-stu-id="9a791-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="9a791-105">Bu gibi durumlarda, katıştırılmış entropi için bu anahtar için ana anahtar malzemesini (veya KM) olarak diyoruz ve gerçek şifreleme işlemleri için kullanılan anahtarları türetmek için anahtar türetme işlevi gerçekleştiririz.</span><span class="sxs-lookup"><span data-stu-id="9a791-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="9a791-106">Anahtarlar büyük/küçük harfe soyuttur ve özel bir uygulaması aşağıdaki gibi çalışmayabilir.</span><span class="sxs-lookup"><span data-stu-id="9a791-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="9a791-107">Anahtar kendi uygulaması sağlıyorsa `IAuthenticatedEncryptor` bizim yerleşik fabrikaları birini kullanmak yerine, bu bölümde açıklanan mekanizması artık geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="9a791-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="9a791-108">Ek kimliği doğrulanmış veriler ve alt anahtar türetme</span><span class="sxs-lookup"><span data-stu-id="9a791-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="9a791-109">`IAuthenticatedEncryptor` Arabirimi tüm kimliği doğrulanmış şifreleme işlemleri için temel arabirim olarak hizmet verir.</span><span class="sxs-lookup"><span data-stu-id="9a791-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="9a791-110">Kendi `Encrypt` yöntemi iki arabelleğini alır: düz metin ve additionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="9a791-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="9a791-111">Düz metin içeriği akış çağrısı değişmeden `IDataProtector.Protect`, ancak AAD sistem tarafından oluşturulan ve üç bileşenden oluşur:</span><span class="sxs-lookup"><span data-stu-id="9a791-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="9a791-112">32-bit Sihirli üstbilgisi 09 F0 C9 F0'de, veri koruma sisteminde bu sürümünü tanımlar.</span><span class="sxs-lookup"><span data-stu-id="9a791-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="9a791-113">128 bit anahtar kimliği.</span><span class="sxs-lookup"><span data-stu-id="9a791-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="9a791-114">Değişken uzunluklu bir dize oluşturan amaçlı zincirinden biçimlendirilmiş `IDataProtector` , bu işlemi gerçekleştiriyor.</span><span class="sxs-lookup"><span data-stu-id="9a791-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="9a791-115">AAD üç bileşen tanımlama grubu için benzersiz olduğundan, bu yeni anahtarları KM kendisini tüm müşterilerimizin şifreleme işlemlerinin kullanmak yerine KM türetmek için kullanabiliriz.</span><span class="sxs-lookup"><span data-stu-id="9a791-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="9a791-116">Yapılan her çağrı için `IAuthenticatedEncryptor.Encrypt`, aşağıdaki anahtar türetme işlem gerçekleşir:</span><span class="sxs-lookup"><span data-stu-id="9a791-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="9a791-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span><span class="sxs-lookup"><span data-stu-id="9a791-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="9a791-118">Burada, biz sayacı modunda NIST SP800 108 KDF arıyoruz (bkz [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) şu parametrelerle:</span><span class="sxs-lookup"><span data-stu-id="9a791-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="9a791-119">Anahtar türetme anahtarı (KDK) K_M =</span><span class="sxs-lookup"><span data-stu-id="9a791-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="9a791-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="9a791-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="9a791-121">Etiket additionalAuthenticatedData =</span><span class="sxs-lookup"><span data-stu-id="9a791-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="9a791-122">bağlam contextHeader = || keyModifier</span><span class="sxs-lookup"><span data-stu-id="9a791-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="9a791-123">İçerik üstbilgisi, değişken uzunluğu ve aslında bir parmak izi için biz K_E ve K_H türetme algoritmaları sunar.</span><span class="sxs-lookup"><span data-stu-id="9a791-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="9a791-124">Her çağrı için rastgele oluşturulmuş bir 128-bit dize anahtar değiştiricidir `Encrypt` ve tüm diğer girişler için KDF sabit olsa bile KE ve KH bu özel kimlik doğrulama şifreleme işlemi için benzersiz olduğunu olasılık aşırı yüklenilmesini ile sağlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="9a791-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="9a791-125">CBC modunda şifreleme + HMAC doğrulama işlemleri için | K_E | simetrik blok şifreleme anahtarı uzunluğu ve | K_H | HMAC yordamının Özet boyutudur.</span><span class="sxs-lookup"><span data-stu-id="9a791-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="9a791-126">GCM şifreleme + doğrulama işlemleri | K_H | 0 =.</span><span class="sxs-lookup"><span data-stu-id="9a791-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="9a791-127">CBC modunda şifreleme + HMAC doğrulama</span><span class="sxs-lookup"><span data-stu-id="9a791-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="9a791-128">Yukarıdaki mekanizması K_E oluşturulduktan sonra size rastgele başlatma vektörü oluşturur ve düz metin şifreleme için simetrik blok şifreleme algoritması çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="9a791-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="9a791-129">Ciphertext ve başlatma vektörünü sonra Mac üretmek için K_H anahtarıyla başlatıldı HMAC yordamı aracılığıyla çalıştırılır</span><span class="sxs-lookup"><span data-stu-id="9a791-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="9a791-130">Bu işlem ve dönüş değeri grafik aşağıda gösterilir.</span><span class="sxs-lookup"><span data-stu-id="9a791-130">This process and the return value is represented graphically below.</span></span>

![CBC modunda işlem ve dön](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="9a791-132">*Çıkış: keyModifier = || IV || (Veri K_E, IV) E_cbc || HMAC (K_H, IV || E_cbc (K_E, IV, veriler))*</span><span class="sxs-lookup"><span data-stu-id="9a791-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="9a791-133">`IDataProtector.Protect` Uygulaması olacak [Sihirli bir üst bilgi ve anahtar kimliği önüne ekleyin](xref:security/data-protection/implementation/authenticated-encryption-details) çağırana döndürmeden önce çıktı.</span><span class="sxs-lookup"><span data-stu-id="9a791-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="9a791-134">Sihirli bir üst bilgi ve anahtar kimliği örtük olarak olduğundan parçası [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), ve anahtar değiştiricisi KDF giriş olarak beslenir olduğundan, bu yük döndürülen her tek baytlık Mac tarafından doğrulanır anlamına gelir</span><span class="sxs-lookup"><span data-stu-id="9a791-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="9a791-135">Galois/sayacı modu şifreleme + doğrulama</span><span class="sxs-lookup"><span data-stu-id="9a791-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="9a791-136">Yukarıdaki mekanizması K_E oluşturulduktan sonra size rastgele 96 bit nonce oluşturmak ve düz metin şifrele, 128 bit kimlik doğrulaması etiketi oluşturmak için simetrik blok şifreleme algoritması'ı çalıştırın.</span><span class="sxs-lookup"><span data-stu-id="9a791-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![GCM modu işlemi ve dön](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="9a791-138">*Çıkış: keyModifier = || nonce || E_gcm (K_E, nonce, veriler) || authTag*</span><span class="sxs-lookup"><span data-stu-id="9a791-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="9a791-139">GCM yerel olarak AAD kavramını destekler olsa da, biz yine de AAD yalnızca özgün KDF GCM, AAD parametresi için boş bir dize geçirilecek edilmesiyle besleme.</span><span class="sxs-lookup"><span data-stu-id="9a791-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="9a791-140">Bunun nedeni, iki Katlama.</span><span class="sxs-lookup"><span data-stu-id="9a791-140">The reason for this is two-fold.</span></span> <span data-ttu-id="9a791-141">İlk olarak, [çevikliği desteklemek için](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) hiçbir zaman K_M doğrudan şifreleme anahtarı kullanılacak istiyoruz.</span><span class="sxs-lookup"><span data-stu-id="9a791-141">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="9a791-142">Ayrıca, GCM girişleri üzerinde çok sıkı benzersizlik gereksinimleri karşılamalıdır.</span><span class="sxs-lookup"><span data-stu-id="9a791-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="9a791-143">GCM şifreleme yordamı hiç olmadığı kadar çağrılan iki veya daha farklı olma olasılığını aynı (anahtar, nonce) giriş veri kümelerini çifti aşmamalıdır 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="9a791-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="9a791-144">Biz K_E düzeltin, 2'den yerine getiremez ^ 32 şifreleme işlemleri biz çalıştırma afoul 2 ve önce ^ -32 sınırlayın.</span><span class="sxs-lookup"><span data-stu-id="9a791-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="9a791-145">Bu işlemlerin çok büyük bir sayı gibi görünebilir, ancak trafiği yüksek web sunucusu, 4 milyarı aşan istekleri aracılığıyla da bu anahtarları için normal kullanım ömrü içinde yalnızca gün içinde gidebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="9a791-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="9a791-146">2. uyumlu kalmak için ^-32 olasılık sınırı devam 128 bit anahtar değiştiricisi ve herhangi belirli K_M için kullanılabilir işlem sayısını önemli ölçüde genişleten 96 bit nonce kullanılacak.</span><span class="sxs-lookup"><span data-stu-id="9a791-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="9a791-147">Tasarım kolaylık olması için biz KDF kod yolu CBC ve GCM işlemleri arasında paylaşın ve AAD içinde KDF zaten değerlendirilir olmadığından, GCM yordamına iletme gereği yok.</span><span class="sxs-lookup"><span data-stu-id="9a791-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
