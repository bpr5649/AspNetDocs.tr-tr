---
uid: web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
title: Büyük miktarlarda veri (C#) aracılığıyla verimli sayfalama Microsoft Docs
author: rick-anderson
description: Veri sunumu denetiminin varsayılan sayfalama seçeneği, temel alınan veri kaynağı denetimi retriev olarak büyük miktarlarda verilerle çalışırken uygun değildir...
ms.author: riande
ms.date: 08/15/2006
ms.assetid: 59c01998-9326-4ecb-9392-cb9615962140
msc.legacyurl: /web-forms/overview/data-access/paging-and-sorting/efficiently-paging-through-large-amounts-of-data-cs
msc.type: authoredcontent
ms.openlocfilehash: a3e9562035cb24987b01fcdff5fbfb5fa8a1f894
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 11/28/2019
ms.locfileid: "74629734"
---
# <a name="efficiently-paging-through-large-amounts-of-data-c"></a><span data-ttu-id="fbf4b-103">Büyük Miktarlı Verileri Etkili Bir Şekilde Sayfalama (C#)</span><span class="sxs-lookup"><span data-stu-id="fbf4b-103">Efficiently Paging Through Large Amounts of Data (C#)</span></span>

<span data-ttu-id="fbf4b-104">[Scott Mitchell](https://twitter.com/ScottOnWriting) tarafından</span><span class="sxs-lookup"><span data-stu-id="fbf4b-104">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="fbf4b-105">[Örnek uygulamayı indirin](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe) veya [PDF 'yi indirin](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="fbf4b-105">[Download Sample App](https://download.microsoft.com/download/9/c/1/9c1d03ee-29ba-4d58-aa1a-f201dcc822ea/ASPNET_Data_Tutorial_25_CS.exe) or [Download PDF](efficiently-paging-through-large-amounts-of-data-cs/_static/datatutorial25cs1.pdf)</span></span>

> <span data-ttu-id="fbf4b-106">Veri sunumu denetiminin varsayılan sayfalama seçeneği, büyük miktarlarda verilerle çalışırken uygun değildir, çünkü temel alınan veri kaynağı denetimi tüm kayıtları alır, ancak yalnızca bir veri alt kümesi görüntülense bile.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-106">The default paging option of a data presentation control is unsuitable when working with large amounts of data, as its underlying data source control retrieves all records, even though only a subset of data is displayed.</span></span> <span data-ttu-id="fbf4b-107">Bu tür durumlarda, özel disk belleği ' i açmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-107">In such circumstances, we must turn to custom paging.</span></span>

## <a name="introduction"></a><span data-ttu-id="fbf4b-108">Giriş</span><span class="sxs-lookup"><span data-stu-id="fbf4b-108">Introduction</span></span>

<span data-ttu-id="fbf4b-109">Önceki öğreticide anlatıldığı gibi, sayfalama iki şekilde de uygulanabilir:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-109">As we discussed in the preceding tutorial, paging can be implemented in one of two ways:</span></span>

- <span data-ttu-id="fbf4b-110">**Varsayılan sayfalama** yalnızca veri Web denetimi s akıllı etiketinde sayfalama etkinleştir seçeneği denetlenerek uygulanabilir. Ancak, bir veri sayfasını her görüntülerken, sayfada yalnızca bir alt kümesi görüntülenmese de, ObjectDataSource *Tüm* kayıtları alır</span><span class="sxs-lookup"><span data-stu-id="fbf4b-110">**Default Paging** can be implemented by simply checking the Enable Paging option in the data Web control s smart tag; however, whenever viewing a page of data, the ObjectDataSource retrieves *all* of the records, even though only a subset of them are displayed in the page</span></span>
- <span data-ttu-id="fbf4b-111">**Özel sayfalama** , yalnızca Kullanıcı tarafından istenen verilerin belirli bir sayfası için görüntülenmesi gereken veritabanından alınan kayıtları alarak varsayılan sayfalama performansını geliştirir; Bununla birlikte, özel disk belleği, varsayılan sayfalamaktan daha fazla çaba gerektirir</span><span class="sxs-lookup"><span data-stu-id="fbf4b-111">**Custom Paging** improves the performance of default paging by retrieving only those records from the database that need to be displayed for the particular page of data requested by the user; however, custom paging involves a bit more effort to implement than default paging</span></span>

<span data-ttu-id="fbf4b-112">Uygulama kolaylığına bağlı olarak yalnızca bir onay kutusunu işaretleyip yeniden yapmanız gerekir!</span><span class="sxs-lookup"><span data-stu-id="fbf4b-112">Due to the ease of implementation just check a checkbox and you re done!</span></span> <span data-ttu-id="fbf4b-113">Varsayılan disk belleği etkileyici bir seçenektir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-113">default paging is an attractive option.</span></span> <span data-ttu-id="fbf4b-114">Bu, tüm kayıtları alma yaklaşımına sahiptir; ancak, yeterince büyük miktarlarda veri veya çok sayıda eşzamanlı kullanıcı içeren sitelerde sayfalama yaparken, bunu kesin bir tercih edilebilir hale getirir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-114">Its na�ve approach in retrieving all of the records, though, makes it an implausible choice when paging through sufficiently large amounts of data or for sites with many concurrent users.</span></span> <span data-ttu-id="fbf4b-115">Bu gibi durumlarda, yanıt veren bir sistem sağlamak için özel disk belleği ' i açmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-115">In such circumstances, we must turn to custom paging in order to provide a responsive system.</span></span>

<span data-ttu-id="fbf4b-116">Özel sayfalama zorluğu, belirli bir veri sayfası için gereken tam kayıt kümesini döndüren bir sorgu yazamayacak.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-116">The challenge of custom paging is being able to write a query that returns the precise set of records needed for a particular page of data.</span></span> <span data-ttu-id="fbf4b-117">Neyse ki Microsoft SQL Server 2005, sonuçları derecelendirme için yeni bir anahtar sözcük sağlar ve bu da kayıtların uygun alt kümesini etkin bir şekilde alan bir sorgu yazmanızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-117">Fortunately, Microsoft SQL Server 2005 provides a new keyword for ranking results, which enables us to write a query that can efficiently retrieve the proper subset of records.</span></span> <span data-ttu-id="fbf4b-118">Bu öğreticide, bir GridView denetiminde özel sayfalama uygulamak için bu yeni SQL Server 2005 anahtar sözcüğünü nasıl kullanacağınızı inceleyeceğiz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-118">In this tutorial we'll see how to use this new SQL Server 2005 keyword to implement custom paging in a GridView control.</span></span> <span data-ttu-id="fbf4b-119">Özel disk belleği için Kullanıcı arabirimi varsayılan sayfalama ile aynı olsa da, özel sayfalama kullanarak bir sayfadan sonrakine geçmek varsayılan sayfalamadan daha hızlı bir şekilde çok daha hızlı olabilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-119">While the user interface for custom paging is identical to that for default paging, stepping from one page to the next using custom paging can be several orders of magnitude faster than default paging.</span></span>

> [!NOTE]
> <span data-ttu-id="fbf4b-120">Özel disk belleği tarafından ele alınan tam performans kazancı, üzerinden disk belleğine alınan toplam kayıt sayısına ve yük veritabanı sunucusuna yerleştirilmesine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-120">The exact performance gain exhibited by custom paging depends on the total number of records being paged through and the load being placed on the database server.</span></span> <span data-ttu-id="fbf4b-121">Bu öğreticinin sonunda, özel sayfalama yoluyla elde edilen performanstan faydalanan bazı kaba ölçümlere bakacağız.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-121">At the end of this tutorial we'll look at some rough metrics that showcase the benefits in performance obtained through custom paging.</span></span>

## <a name="step-1-understanding-the-custom-paging-process"></a><span data-ttu-id="fbf4b-122">1\. adım: Özel sayfalama Işlemini anlama</span><span class="sxs-lookup"><span data-stu-id="fbf4b-122">Step 1: Understanding the Custom Paging Process</span></span>

<span data-ttu-id="fbf4b-123">Veriler üzerinden sayfalama yaparken, bir sayfada görünen kesin kayıtlar, istenen verilerin sayfasına ve sayfa başına gösterilecek kayıt sayısına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-123">When paging through data, the precise records displayed in a page depend upon the page of data being requested and the number of records displayed per page.</span></span> <span data-ttu-id="fbf4b-124">Örneğin, sayfa başına 10 ürün görüntüleyen 81 ürün aracılığıyla sayfa eklemek istediğimize göz lıyoruz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-124">For example, imagine that we wanted to page through the 81 products, displaying 10 products per page.</span></span> <span data-ttu-id="fbf4b-125">İlk sayfa görüntülenirken, 1 ' den 10 ' a kadar ürünlerin olmasını istiyoruz. ikinci sayfayı görüntülerken, 10 ile 20 arasındaki ürünlerle ilgilentik ve bu şekilde devam eder.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-125">When viewing the first page, we d want products 1 through 10; when viewing the second page we d be interested in products 11 through 20, and so on.</span></span>

<span data-ttu-id="fbf4b-126">Hangi kayıtların alınması gerektiğini ve sayfalama arabiriminin nasıl işleneceğini belirten üç değişken vardır:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-126">There are three variables that dictate what records need to be retrieved and how the paging interface should be rendered:</span></span>

- <span data-ttu-id="fbf4b-127">**Başlangıç satırı dizini** görüntülenecek veriler sayfasındaki ilk satırın dizini. Bu dizin, sayfa dizinini, sayfa başına görüntülenecek ve bir tane eklenecek kayıtlarla çarpılarak hesaplanabilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-127">**Start Row Index** the index of the first row in the page of data to display; this index can be calculated by multiplying the page index by the records to display per page and adding one.</span></span> <span data-ttu-id="fbf4b-128">Örneğin, ilk sayfa (sayfa dizini 0 olan) için tek seferde 10 kayıt sırasında sayfalama yaparken, başlangıç satırı dizini 0 \* 10 + 1 veya 1; olur. İkinci sayfa (sayfa dizini 1 olan) için başlangıç satırı dizini 1 \* 10 + 1 veya 11 ' dir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-128">For example, when paging through records 10 at a time, for the first page (whose page index is 0), the Start Row Index is 0 \* 10 + 1, or 1; for the second page (whose page index is 1), the Start Row Index is 1 \* 10 + 1, or 11.</span></span>
- <span data-ttu-id="fbf4b-129">**En fazla satır** sayısı, sayfa başına görüntülenecek en fazla kayıt sayısıdır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-129">**Maximum Rows** the maximum number of records to display per page.</span></span> <span data-ttu-id="fbf4b-130">Bu değişken son sayfa için bu yana en fazla satır olarak adlandırılır, sayfa boyutundan daha az kayıt döndürülür.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-130">This variable is referred to as maximum rows since for the last page there may be fewer records returned than the page size.</span></span> <span data-ttu-id="fbf4b-131">Örneğin, sayfa başına 81 ürün 10 kayıt sırasında sayfalama yaparken, dokuzuncu ve nihai sayfada yalnızca bir kayıt olur.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-131">For example, when paging through the 81 products 10 records per page, the ninth and final page will have just one record.</span></span> <span data-ttu-id="fbf4b-132">Ancak sayfa olmadığından, en fazla satır değerinden daha fazla kayıt gösterilecektir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-132">No page, though, will show more records than the Maximum Rows value.</span></span>
- <span data-ttu-id="fbf4b-133">**Toplam kayıt** sayısı ile disk belleğine alınan toplam kayıt sayısı.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-133">**Total Record Count** the total number of records being paged through.</span></span> <span data-ttu-id="fbf4b-134">Bu değişken, belirli bir sayfa için alınacak kayıtları belirlemek için gerekli olsa da, sayfalama arabirimini de dikte etmez.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-134">While this variable isn t needed to determine what records to retrieve for a given page, it does dictate the paging interface.</span></span> <span data-ttu-id="fbf4b-135">Örneğin, sayfalanmakta olan 81 ürün varsa sayfalama arabirimi, sayfalama Kullanıcı arabiriminde dokuz sayfa numarasını görüntülemeyi bilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-135">For example, if there are 81 products being paged through, the paging interface knows to display nine page numbers in the paging UI.</span></span>

<span data-ttu-id="fbf4b-136">Varsayılan sayfalama ile, başlangıç satırı dizini sayfa dizininin ürünü ve sayfa boyutu ile birlikte hesaplanır, ancak en fazla satır yalnızca sayfa boyutudur.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-136">With default paging, the Start Row Index is computed as the product of the page index and the page size plus one, whereas the Maximum Rows is simply the page size.</span></span> <span data-ttu-id="fbf4b-137">Varsayılan sayfalama, herhangi bir veri sayfasını işlerken veritabanındaki tüm kayıtları gönderdiğinden, her bir satırın dizini bilindiğinden, bu nedenle başlangıç satırı Dizin satırına büyük bir görev gönderilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-137">Since default paging retrieves all of the records from the database when rendering any page of data, the index for each row is known, thereby making moving to Start Row Index row a trivial task.</span></span> <span data-ttu-id="fbf4b-138">Ayrıca, toplam kayıt sayısı, yalnızca DataTable içindeki kayıt sayısı (veya veritabanı sonuçlarını tutmak için kullanılan nesne) olarak hazır hale gelir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-138">Moreover, the Total Record Count is readily available, as it s simply the number of records in the DataTable (or whatever object is being used to hold the database results).</span></span>

<span data-ttu-id="fbf4b-139">Başlangıç satırı dizini ve en fazla satır değişkenleri verildiğinde, özel bir sayfalama uygulamasının yalnızca başlangıç satırı dizininden başlayarak kayıtların kesin alt kümesini döndürmesi ve bundan sonra en fazla satır sayısına dönmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-139">Given the Start Row Index and Maximum Rows variables, a custom paging implementation must only return the precise subset of records starting at the Start Row Index and up to Maximum Rows number of records after that.</span></span> <span data-ttu-id="fbf4b-140">Özel disk belleği iki zorluk sağlar:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-140">Custom paging provides two challenges:</span></span>

- <span data-ttu-id="fbf4b-141">Belirtilen başlangıç satırı dizininde kayıtları döndürmeye başlayabilmemiz için, bir satır dizinini tüm verilerin sayfalandırılmış her bir satırla verimli bir şekilde ilişkilendirebilmelidir</span><span class="sxs-lookup"><span data-stu-id="fbf4b-141">We must be able to efficiently associate a row index with each row in the entire data being paged through so that we can start returning records at the specified Start Row Index</span></span>
- <span data-ttu-id="fbf4b-142">Disk belleğine alınan toplam kayıt sayısını sağlamamız gerekir</span><span class="sxs-lookup"><span data-stu-id="fbf4b-142">We need to provide the total number of records being paged through</span></span>

<span data-ttu-id="fbf4b-143">Sonraki iki adımda, bu iki güçlüğe yanıt vermek için gereken SQL betiğini inceleyeceğiz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-143">In the next two steps we'll examine the SQL script needed to respond to these two challenges.</span></span> <span data-ttu-id="fbf4b-144">SQL betiğine ek olarak, DAL ve BLL 'de yöntemler de uygulamamız gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-144">In addition to the SQL script, we'll also need to implement methods in the DAL and BLL.</span></span>

## <a name="step-2-returning-the-total-number-of-records-being-paged-through"></a><span data-ttu-id="fbf4b-145">2\. adım: Disk belleğine alınan toplam kayıt sayısını döndürme</span><span class="sxs-lookup"><span data-stu-id="fbf4b-145">Step 2: Returning the Total Number of Records Being Paged Through</span></span>

<span data-ttu-id="fbf4b-146">Görüntülenmekte olan sayfa için tam kayıt alt kümesini nasıl alacağınızı incelemeden önce, ilk olarak disk belleğine alınan toplam kayıt sayısını geri döndürmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-146">Before we examine how to retrieve the precise subset of records for the page being displayed, let s first look at how to return the total number of records being paged through.</span></span> <span data-ttu-id="fbf4b-147">Bu bilgiler, sayfalama Kullanıcı arabirimini düzgün bir şekilde yapılandırmak için gereklidir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-147">This information is needed in order to properly configure the paging user interface.</span></span> <span data-ttu-id="fbf4b-148">Belirli bir SQL sorgusu tarafından döndürülen kayıtların toplam sayısı [`COUNT` toplama işlevi](https://msdn.microsoft.com/library/ms175997.aspx)kullanılarak elde edilebilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-148">The total number of records returned by a particular SQL query can be obtained by using the [`COUNT` aggregate function](https://msdn.microsoft.com/library/ms175997.aspx).</span></span> <span data-ttu-id="fbf4b-149">Örneğin, `Products` tablosundaki toplam kayıt sayısını öğrenmek için aşağıdaki sorguyu kullanabiliriz:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-149">For example, to determine the total number of records in the `Products` table, we can use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample1.sql)]

<span data-ttu-id="fbf4b-150">Bu bilgileri döndüren DAL için bir yöntem ekleyelim.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-150">Let s add a method to our DAL that returns this information.</span></span> <span data-ttu-id="fbf4b-151">Özellikle, yukarıda gösterilen `SELECT` ifadesini yürüten `TotalNumberOfProducts()` adlı bir DAL yöntemi oluşturacağız.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-151">In particular, we'll create a DAL method called `TotalNumberOfProducts()` that executes the `SELECT` statement shown above.</span></span>

<span data-ttu-id="fbf4b-152">`App_Code/DAL` klasöre `Northwind.xsd` türü belirtilmiş veri kümesi dosyasını açarak başlayın.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-152">Start by opening the `Northwind.xsd` Typed DataSet file in the `App_Code/DAL` folder.</span></span> <span data-ttu-id="fbf4b-153">Sonra, tasarımcıda `ProductsTableAdapter` sağ tıklayın ve sorgu Ekle ' yi seçin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-153">Next, right-click on the `ProductsTableAdapter` in the Designer and choose Add Query.</span></span> <span data-ttu-id="fbf4b-154">Önceki öğreticilerde gördüğünüze göre, bu, çağrıldığında, belirli bir SQL ifadesini veya saklı yordamı yürütecek olan yeni bir yöntem ekleyebilmemiz için size izin verir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-154">As we ve seen in previous tutorials, this will allow us to add a new method to the DAL that, when invoked, will execute a particular SQL statement or stored procedure.</span></span> <span data-ttu-id="fbf4b-155">Bu, önceki öğreticilerdeki TableAdapter yöntemlerinde olduğu gibi, bir geçici SQL ifadesini kullanmayı tercih edebilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-155">As with our TableAdapter methods in previous tutorials, for this one opt to use an ad-hoc SQL statement.</span></span>

![Geçici bir SQL Ifadesini kullanın](efficiently-paging-through-large-amounts-of-data-cs/_static/image1.png)

<span data-ttu-id="fbf4b-157">**Şekil 1**: Geçici bir SQL Ifadesini kullanın</span><span class="sxs-lookup"><span data-stu-id="fbf4b-157">**Figure 1**: Use an Ad-Hoc SQL Statement</span></span>

<span data-ttu-id="fbf4b-158">Sonraki ekranda, oluşturulacak sorgu türünü belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-158">On the next screen we can specify what type of query to create.</span></span> <span data-ttu-id="fbf4b-159">Bu sorgu tek bir skaler değer döndürecek `Products` tablodaki toplam kayıt sayısı bir tek değeri seçeneği döndüren `SELECT` seçin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-159">Since this query will return a single, scalar value the total number of records in the `Products` table choose the `SELECT` which returns a singe value option.</span></span>

![Sorguyu tek bir değer döndüren bir SELECT Ifadesini kullanacak şekilde yapılandırın](efficiently-paging-through-large-amounts-of-data-cs/_static/image2.png)

<span data-ttu-id="fbf4b-161">**Şekil 2**: Sorguyu tek bir değer döndüren bir SELECT Ifadesini kullanacak şekilde yapılandırın</span><span class="sxs-lookup"><span data-stu-id="fbf4b-161">**Figure 2**: Configure the Query to Use a SELECT Statement that Returns a Single Value</span></span>

<span data-ttu-id="fbf4b-162">Kullanılacak sorgunun türünü belirttikten sonra sorguyu belirtmemiz gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-162">After indicating the type of query to use, we must next specify the query.</span></span>

![Products sorgusundan SELECT COUNT (\*) kullanın](efficiently-paging-through-large-amounts-of-data-cs/_static/image3.png)

<span data-ttu-id="fbf4b-164">**Şekil 3**: Ürünler sorgusundan SELECT COUNT (\*) kullanın</span><span class="sxs-lookup"><span data-stu-id="fbf4b-164">**Figure 3**: Use the SELECT COUNT(\*) FROM Products Query</span></span>

<span data-ttu-id="fbf4b-165">Son olarak, yöntemin adını belirtin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-165">Finally, specify the name for the method.</span></span> <span data-ttu-id="fbf4b-166">Belirtildiği gibi, `TotalNumberOfProducts`kullanmasına izin verin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-166">As aforementioned, let s use `TotalNumberOfProducts`.</span></span>

![DAL yöntemi TotalNumberOfProducts olarak adlandırın](efficiently-paging-through-large-amounts-of-data-cs/_static/image4.png)

<span data-ttu-id="fbf4b-168">**Şekil 4**: DAL yöntemi TotalNumberOfProducts olarak adlandırın</span><span class="sxs-lookup"><span data-stu-id="fbf4b-168">**Figure 4**: Name the DAL Method TotalNumberOfProducts</span></span>

<span data-ttu-id="fbf4b-169">Son ' a tıkladıktan sonra, sihirbaz `TotalNumberOfProducts` yöntemini DAL 'e ekler.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-169">After clicking Finish, the wizard will add the `TotalNumberOfProducts` method to the DAL.</span></span> <span data-ttu-id="fbf4b-170">DAL içindeki skaler döndürme yöntemleri, SQL sorgusunun sonucunun `NULL`olması halinde null yapılabilir türler döndürür.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-170">The scalar returning methods in the DAL return nullable types, in case the result from the SQL query is `NULL`.</span></span> <span data-ttu-id="fbf4b-171">Ancak `COUNT` sorgumuz, her zaman`NULL` olmayan bir değer döndürür; ne olursa olsun, DAL yöntemi null yapılabilir bir tamsayı döndürür.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-171">Our `COUNT` query, however, will always return a non-`NULL` value; regardless, the DAL method returns a nullable integer.</span></span>

<span data-ttu-id="fbf4b-172">DAL yöntemine ek olarak BLL 'de de bir metoda ihtiyacımız var.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-172">In addition to the DAL method, we also need a method in the BLL.</span></span> <span data-ttu-id="fbf4b-173">`ProductsBLL` sınıf dosyasını açın ve yalnızca DAL s `TotalNumberOfProducts` metoduna çağıran bir `TotalNumberOfProducts` yöntemi ekleyin:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-173">Open the `ProductsBLL` class file and add a `TotalNumberOfProducts` method that simply calls down to the DAL s `TotalNumberOfProducts` method:</span></span>

[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample2.cs)]

<span data-ttu-id="fbf4b-174">DAL s `TotalNumberOfProducts` yöntemi null yapılabilir bir tamsayı döndürür; Ancak, standart bir tamsayı döndürmesi için `ProductsBLL` sınıf s `TotalNumberOfProducts` metodunu oluşturduk.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-174">The DAL s `TotalNumberOfProducts` method returns a nullable integer; however, we ve created the `ProductsBLL` class s `TotalNumberOfProducts` method so that it returns a standard integer.</span></span> <span data-ttu-id="fbf4b-175">Bu nedenle, `ProductsBLL` sınıf s `TotalNumberOfProducts` yönteminin, DAL s `TotalNumberOfProducts` metodu tarafından döndürülen Nullable tamsayının değer bölümünü döndürmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-175">Therefore, we need to have the `ProductsBLL` class s `TotalNumberOfProducts` method return the value portion of the nullable integer returned by the DAL s `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="fbf4b-176">`GetValueOrDefault()` çağrısı, varsa Nullable tamsayı değerini döndürür; null atanabilir tamsayı `null`, ancak varsayılan tamsayı değerini döndürür, 0.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-176">The call to `GetValueOrDefault()` returns the value of the nullable integer, if it exists; if the nullable integer is `null`, however, it returns the default integer value, 0.</span></span>

## <a name="step-3-returning-the-precise-subset-of-records"></a><span data-ttu-id="fbf4b-177">3\. adım: Kayıtların kesin alt kümesini döndürme</span><span class="sxs-lookup"><span data-stu-id="fbf4b-177">Step 3: Returning the Precise Subset of Records</span></span>

<span data-ttu-id="fbf4b-178">Sonraki görevimiz, daha önce tartışılan başlangıç satırı dizinini ve en fazla satır değişkenlerini kabul eden ve uygun kayıtları döndüren DAL ve BLL 'de Yöntemler oluşturmaktır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-178">Our next task is to create methods in the DAL and BLL that accept the Start Row Index and Maximum Rows variables discussed earlier and return the appropriate records.</span></span> <span data-ttu-id="fbf4b-179">Bunu yapmadan önce, gereken SQL betiğine ilk göz atalım.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-179">Before we do that, let s first look at the needed SQL script.</span></span> <span data-ttu-id="fbf4b-180">Bize bakan zorluk, yalnızca başlangıç satırı dizininden (ve en fazla kayıt numarası kayıt sayısına kadar) başlayarak yalnızca bu kayıtları döndürebilmemiz için tüm sonuçların tamamında disk belleğine alınan her satıra bir dizin atayabilmelidir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-180">The challenge facing us is that we must be able to efficiently assign an index to each row in the entire results being paged through so that we can return just those records starting at the Start Row Index (and up to the Maximum Records number of records).</span></span>

<span data-ttu-id="fbf4b-181">Bu, veritabanı tablosunda bir satır dizini görevi gören bir sütun zaten varsa bir zorluk değildir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-181">This is not a challenge if there is already a column in the database table that serves as a row index.</span></span> <span data-ttu-id="fbf4b-182">İlk bakışta, ilk ürünün 1 `ProductID`, ikincisi 2 vb. olduğu gibi `Products` tablo s `ProductID` alanının yeterli olduğunu düşündük.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-182">At first glance we might think that the `Products` table s `ProductID` field would suffice, as the first product has `ProductID` of 1, the second a 2, and so on.</span></span> <span data-ttu-id="fbf4b-183">Ancak, bir ürünün silinmesi dizide bir boşluk bırakır, bu yaklaşım bu yaklaşımla sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-183">However, deleting a product leaves a gap in the sequence, nullifying this approach.</span></span>

<span data-ttu-id="fbf4b-184">Bir satır dizinini verilerle sayfa ile bir şekilde ilişkilendirmek için kullanılan iki genel teknik vardır ve böylece kayıtların tam alt kümesini elde etmenizi sağlar:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-184">There are two general techniques used to efficiently associate a row index with the data to page through, thereby enabling the precise subset of records to be retrieved:</span></span>

- <span data-ttu-id="fbf4b-185">**SQL Server 2005 s `ROW_NUMBER()` anahtar sözcüğünü** SQL Server 2005 ' e kadar kullanarak, `ROW_NUMBER()` anahtar sözcüğü bir sıralamayı, her bir sıralamaya göre döndürülen her kayıtla ilişkilendirir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-185">**Using SQL Server 2005 s `ROW_NUMBER()` Keyword** new to SQL Server 2005, the `ROW_NUMBER()` keyword associates a ranking with each returned record based on some ordering.</span></span> <span data-ttu-id="fbf4b-186">Bu sıralama, her satır için bir satır dizini olarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-186">This ranking can be used as a row index for each row.</span></span>
- <span data-ttu-id="fbf4b-187">**Tablo değişkeni ve `SET ROWCOUNT`kullanma** SQL Server s [`SET ROWCOUNT` deyimleri](https://msdn.microsoft.com/library/ms188774.aspx) , bir sorgunun sonlandırmadan önce kaç toplam kayıt tarafından işlenmesi gerektiğini belirtmek için kullanılabilir; [Tablo değişkenleri](http://www.sqlteam.com/item.asp?ItemID=9454) , [geçici tablolara](http://www.sqlteam.com/item.asp?ItemID=2029)aktarılan tablolu verileri tutan yerel T-SQL değişkenleridir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-187">**Using a Table Variable and `SET ROWCOUNT`** SQL Server s [`SET ROWCOUNT` statement](https://msdn.microsoft.com/library/ms188774.aspx) can be used to specify how many total records a query should process before terminating; [table variables](http://www.sqlteam.com/item.asp?ItemID=9454) are local T-SQL variables that can hold tabular data, akin to [temporary tables](http://www.sqlteam.com/item.asp?ItemID=2029).</span></span> <span data-ttu-id="fbf4b-188">Bu yaklaşım hem Microsoft SQL Server 2005 hem de 2000 SQL Server (`ROW_NUMBER()` yaklaşımı yalnızca SQL Server 2005 ile birlikte çalışarak) ile aynı şekilde çalışacaktır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-188">This approach works equally well with both Microsoft SQL Server 2005 and SQL Server 2000 (whereas the `ROW_NUMBER()` approach only works with SQL Server 2005).</span></span>  
  
  <span data-ttu-id="fbf4b-189">Buradaki fikir, verileri sayfalandırılmış olan tablonun birincil anahtarları için `IDENTITY` sütunu ve sütunları olan bir tablo değişkeni oluşturmaktır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-189">The idea here is to create a table variable that has an `IDENTITY` column and columns for the primary keys of the table whose data is being paged through.</span></span> <span data-ttu-id="fbf4b-190">Daha sonra, verileri Sayfalanmış tablonun içeriği tablo değişkenine dökülür ve bu sayede tablodaki her bir kayıt için sıralı bir satır dizinini (`IDENTITY` sütunu aracılığıyla) ilişkilendirirler.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-190">Next, the contents of the table whose data is being paged through is dumped into the table variable, thereby associating a sequential row index (via the `IDENTITY` column) for each record in the table.</span></span> <span data-ttu-id="fbf4b-191">Tablo değişkeni doldurulduktan sonra, tablo değişkeninde temel tabloyla birleştirilmiş bir `SELECT` bir ifade, belirli kayıtları çekmek için yürütülebilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-191">Once the table variable has been populated, a `SELECT` statement on the table variable, joined with the underlying table, can be executed to pull out the particular records.</span></span> <span data-ttu-id="fbf4b-192">`SET ROWCOUNT` deyimleri, tablo değişkenine döküme gereken kayıt sayısını akıllıca sınırlamak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-192">The `SET ROWCOUNT` statement is used to intelligently limit the number of records that need to be dumped into the table variable.</span></span>  
  
  <span data-ttu-id="fbf4b-193">Bu yaklaşım verimlilik, istenen sayfa numarasını temel alır. `SET ROWCOUNT` değeri, başlangıç satırı dizininin değeri ve en fazla satır sayısı olarak atanır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-193">This approach s efficiency is based on the page number being requested, as the `SET ROWCOUNT` value is assigned the value of Start Row Index plus the Maximum Rows.</span></span> <span data-ttu-id="fbf4b-194">Verilerin ilk birkaç sayfası gibi düşük sayılı sayfalarda sayfalama yaparken bu yaklaşım çok verimlidir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-194">When paging through low-numbered pages such as the first few pages of data this approach is very efficient.</span></span> <span data-ttu-id="fbf4b-195">Bununla birlikte, son görüntülenen sayfayı alırken varsayılan disk belleği benzeri performansı sergiler.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-195">However, it exhibits default paging-like performance when retrieving a page near the end.</span></span>

<span data-ttu-id="fbf4b-196">Bu öğretici `ROW_NUMBER()` anahtar sözcüğünü kullanarak özel disk belleği uygular.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-196">This tutorial implements custom paging using the `ROW_NUMBER()` keyword.</span></span> <span data-ttu-id="fbf4b-197">Tablo değişkenini ve `SET ROWCOUNT` tekniği kullanma hakkında daha fazla bilgi için, [büyük sonuç kümelerinde sayfalama Için daha verimli bir yönteme](http://www.4guysfromrolla.com/webtech/042606-1.shtml)bakın.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-197">For more information on using the table variable and `SET ROWCOUNT` technique, see [A More Efficient Method for Paging Through Large Result Sets](http://www.4guysfromrolla.com/webtech/042606-1.shtml).</span></span>

<span data-ttu-id="fbf4b-198">Aşağıdaki sözdizimini kullanarak belirli bir sıralama üzerinde döndürülen her bir kayıtla birlikte bir derecelendirmeden ilişkili `ROW_NUMBER()` anahtar sözcüğü.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-198">The `ROW_NUMBER()` keyword associated a ranking with each record returned over a particular ordering using the following syntax:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample3.sql)]

<span data-ttu-id="fbf4b-199">`ROW_NUMBER()`, belirtilen sıralamaya göre her bir kayıt için derecelendirmeyi belirten sayısal bir değer döndürür.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-199">`ROW_NUMBER()` returns a numerical value that specifies the rank for each record with regards to the indicated ordering.</span></span> <span data-ttu-id="fbf4b-200">Örneğin, her bir ürün için en pahalı olandan en az bir sıralama olduğunu görmek için aşağıdaki sorguyu kullanabiliriz:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-200">For example, to see the rank for each product, ordered from the most expensive to the least, we could use the following query:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample4.sql)]

<span data-ttu-id="fbf4b-201">Şekil 5 ' te, Visual Studio 'da sorgu penceresi aracılığıyla çalıştırıldığında bu sorgu sonuçları gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-201">Figure 5 shows this query s results when run through the query window in Visual Studio.</span></span> <span data-ttu-id="fbf4b-202">Ürünlerin fiyata göre sıralandığına ve her satır için bir fiyat derecesine sahip olduğuna unutmayın.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-202">Note that the products are ordered by price, along with a price rank for each row.</span></span>

![Her döndürülen kayıt için fiyat Sıralaması dahildir](efficiently-paging-through-large-amounts-of-data-cs/_static/image5.png)

<span data-ttu-id="fbf4b-204">**Şekil 5**: Her döndürülen kayıt için fiyat Sıralaması dahildir</span><span class="sxs-lookup"><span data-stu-id="fbf4b-204">**Figure 5**: The Price Rank is Included for Each Returned Record</span></span>

> [!NOTE]
> <span data-ttu-id="fbf4b-205">`ROW_NUMBER()`, SQL Server 2005 ' de bulunan çok sayıda yeni derecelendirme işlevlerinden yalnızca biridir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-205">`ROW_NUMBER()` is just one of the many new ranking functions available in SQL Server 2005.</span></span> <span data-ttu-id="fbf4b-206">`ROW_NUMBER()`daha kapsamlı bir şekilde tartışmak için, diğer derecelendirme işlevleriyle birlikte, [Microsoft SQL Server 2005 Ile dereceli sonuçları döndürme](http://www.4guysfromrolla.com/webtech/010406-1.shtml)makalesini okuyun.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-206">For a more thorough discussion of `ROW_NUMBER()`, along with the other ranking functions, read [Returning Ranked Results with Microsoft SQL Server 2005](http://www.4guysfromrolla.com/webtech/010406-1.shtml).</span></span>

<span data-ttu-id="fbf4b-207">Sonuçları, `OVER` yan tümcesinde belirtilen `ORDER BY` sütununa göre derecelendirerek (`UnitPrice`, yukarıdaki örnekte), SQL Server sonuçları sıralaması gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-207">When ranking the results by the specified `ORDER BY` column in the `OVER` clause (`UnitPrice`, in the above example), SQL Server must sort the results.</span></span> <span data-ttu-id="fbf4b-208">Bu, sonuçların tarafından sıralanan sütunlar üzerinde kümelenmiş bir dizin varsa veya kapsayan bir dizin varsa, ancak başka maliyetli bir işlem olduğunda hızlı bir işlemdir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-208">This is a quick operation if there is a clustered index over the column(s) the results are being ordered by, or if there is a covering index, but can be more costly otherwise.</span></span> <span data-ttu-id="fbf4b-209">Yeterince büyük sorguların performansını artırmaya yardımcı olmak için, sonuçların sıralandığı sütun için kümelenmemiş bir dizin eklemeyi göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-209">To help improve performance for sufficiently large queries, consider adding a non-clustered index for the column by which the results are ordered by.</span></span> <span data-ttu-id="fbf4b-210">Performans konularına daha ayrıntılı bir bakış için bkz. [SQL Server 2005 ' de derecelendirme işlevleri ve performansı](http://www.sql-server-performance.com/ak_ranking_functions.asp) .</span><span class="sxs-lookup"><span data-stu-id="fbf4b-210">See [Ranking Functions and Performance in SQL Server 2005](http://www.sql-server-performance.com/ak_ranking_functions.asp) for a more detailed look at the performance considerations.</span></span>

<span data-ttu-id="fbf4b-211">`ROW_NUMBER()` tarafından döndürülen derecelendirme bilgileri `WHERE` yan tümcesinde doğrudan kullanılamaz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-211">The ranking information returned by `ROW_NUMBER()` cannot directly be used in the `WHERE` clause.</span></span> <span data-ttu-id="fbf4b-212">Ancak, bir türetilmiş tablo, daha sonra `WHERE` yan tümcesinde görünebilen `ROW_NUMBER()` sonucunu döndürmek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-212">However, a derived table can be used to return the `ROW_NUMBER()` result, which can then appear in the `WHERE` clause.</span></span> <span data-ttu-id="fbf4b-213">Örneğin, aşağıdaki sorgu, `ROW_NUMBER()` sonucuyla birlikte ProductName ve BirimFiyat sütunlarını döndürmek için türetilmiş bir tablo kullanır ve ardından yalnızca fiyat derecesi 11 ile 20 arasında olan ürünleri döndürmek için bir `WHERE` yan tümcesi kullanır:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-213">For example, the following query uses a derived table to return the ProductName and UnitPrice columns, along with the `ROW_NUMBER()` result, and then uses a `WHERE` clause to only return those products whose price rank is between 11 and 20:</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample5.sql)]

<span data-ttu-id="fbf4b-214">Bu kavramı biraz daha uzun bir şekilde genişleterek, istenen başlangıç satırı dizini ve en fazla satır değerleri verilen belirli bir veri sayfasını almak için bu yaklaşımı kullanabilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-214">Extending this concept a bit further, we can utilize this approach to retrieve a specific page of data given the desired Start Row Index and Maximum Rows values:</span></span>

[!code-html[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample6.html)]

> [!NOTE]
> <span data-ttu-id="fbf4b-215">Bu öğreticide daha sonra göreceğiniz gibi, ObjectDataSource tarafından sağlanan *`StartRowIndex`* dizini sıfırdan başlayarak dizinlenir, ancak SQL Server 2005 tarafından döndürülen `ROW_NUMBER()` değeri 1 ' den başlayarak dizinlenir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-215">As we will see later on in this tutorial, the *`StartRowIndex`* supplied by the ObjectDataSource is indexed starting at zero, whereas the `ROW_NUMBER()` value returned by SQL Server 2005 is indexed starting at 1.</span></span> <span data-ttu-id="fbf4b-216">Bu nedenle `WHERE` yan tümcesi, `PriceRank` *`StartRowIndex`* şundan kesinlikle büyük ve *`StartRowIndex`*  +  *`MaximumRows`* küçük ya da buna eşit olan kayıtları döndürür.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-216">Therefore, the `WHERE` clause returns those records where `PriceRank` is strictly greater than *`StartRowIndex`* and less than or equal to *`StartRowIndex`* + *`MaximumRows`*.</span></span>

<span data-ttu-id="fbf4b-217">Artık `ROW_NUMBER()` başlangıç satırı dizini ve en fazla satır değerleri verilen belirli bir veri sayfasını almak için nasıl kullanılabileceğinizi anladık. artık bu mantığı DAL ve BLL 'de yöntemler olarak uygulamamız gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-217">Now that we ve discussed how `ROW_NUMBER()` can be used to retrieve a particular page of data given the Start Row Index and Maximum Rows values, we now need to implement this logic as methods in the DAL and BLL.</span></span>

<span data-ttu-id="fbf4b-218">Bu sorguyu oluştururken sonuçların derecelendirilir sıralamaya karar vermelidir; ürünlerin adlarını alfabetik sırada sıralamasına izin verin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-218">When creating this query we must decide the ordering by which the results will be ranked; let s sort the products by their name in alphabetical order.</span></span> <span data-ttu-id="fbf4b-219">Diğer bir deyişle, bu öğreticideki özel disk belleği uygulamasının de sıralanamayacak özel bir Sayfalanmış rapor oluşturabileceksiniz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-219">This means that with the custom paging implementation in this tutorial we will not be able to create a custom paged report than can also be sorted.</span></span> <span data-ttu-id="fbf4b-220">Yine de, bir sonraki öğreticide, bu işlevselliğin nasıl sağlanabileceğiz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-220">In the next tutorial, though, we'll see how such functionality can be provided.</span></span>

<span data-ttu-id="fbf4b-221">Önceki bölümde, DAL yöntemini geçici bir SQL ifadesiyle oluşturduk.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-221">In the previous section we created the DAL method as an ad-hoc SQL statement.</span></span> <span data-ttu-id="fbf4b-222">Ne yazık ki, TableAdapter Sihirbazı tarafından kullanılan Visual Studio 'da T-SQL ayrıştırıcısı, `ROW_NUMBER()` işlevi tarafından kullanılan `OVER` sözdizimini beğenmez.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-222">Unfortunately, the T-SQL parser in Visual Studio used by the TableAdapter wizard doesn t like the `OVER` syntax used by the `ROW_NUMBER()` function.</span></span> <span data-ttu-id="fbf4b-223">Bu nedenle, bu DAL metodunu saklı yordam olarak oluşturuyoruz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-223">Therefore, we must create this DAL method as a stored procedure.</span></span> <span data-ttu-id="fbf4b-224">Görünüm menüsünden Sunucu Gezgini seçin (veya CTRL + ALT + S tuşlarına basın) ve `NORTHWND.MDF` düğümünü genişletin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-224">Select the Server Explorer from the View menu (or hit Ctrl+Alt+S) and expand the `NORTHWND.MDF` node.</span></span> <span data-ttu-id="fbf4b-225">Yeni bir saklı yordam eklemek için saklı yordamlar düğümüne sağ tıklayın ve yeni bir saklı yordam Ekle ' yi seçin (bkz. Şekil 6).</span><span class="sxs-lookup"><span data-stu-id="fbf4b-225">To add a new stored procedure, right-click on the Stored Procedures node and choose Add a New Stored Procedure (see Figure 6).</span></span>

![Ürünler aracılığıyla sayfalama için yeni bir saklı yordam ekleyin](efficiently-paging-through-large-amounts-of-data-cs/_static/image6.png)

<span data-ttu-id="fbf4b-227">**Şekil 6**: Ürünler aracılığıyla sayfalama için yeni bir saklı yordam ekleyin</span><span class="sxs-lookup"><span data-stu-id="fbf4b-227">**Figure 6**: Add a New Stored Procedure for Paging Through the Products</span></span>

<span data-ttu-id="fbf4b-228">Bu saklı yordam iki tamsayı giriş parametresi kabul etmelidir-`@startRowIndex` ve `@maximumRows` ve `ProductName` alanı tarafından sıralanan `ROW_NUMBER()` işlevini, yalnızca belirtilen `@startRowIndex` daha büyük ve `@startRowIndex` + `@maximumRow` küçük ya da buna eşit olan satırları döndürerek kullanır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-228">This stored procedure should accept two integer input parameters - `@startRowIndex` and `@maximumRows` and use the `ROW_NUMBER()` function ordered by the `ProductName` field, returning only those rows greater than the specified `@startRowIndex` and less than or equal to `@startRowIndex` + `@maximumRow` s.</span></span> <span data-ttu-id="fbf4b-229">Yeni saklı yordama aşağıdaki betiği girin ve ardından Kaydet simgesine tıklayarak saklı yordamı veritabanına ekleyin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-229">Enter the following script into the new stored procedure and then click the Save icon to add the stored procedure to the database.</span></span>

[!code-sql[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample7.sql)]

<span data-ttu-id="fbf4b-230">Saklı yordamı oluşturduktan sonra, test etmek için bir dakikanızı ayırın. Sunucu Gezgini `GetProductsPaged` saklı yordam adına sağ tıklayın ve Çalıştır seçeneğini belirleyin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-230">After creating the stored procedure, take a moment to test it out. Right-click on the `GetProductsPaged` stored procedure name in the Server Explorer and choose the Execute option.</span></span> <span data-ttu-id="fbf4b-231">Visual Studio, `@startRowIndex` ve `@maximumRow` s giriş parametrelerini ister (bkz. Şekil 7).</span><span class="sxs-lookup"><span data-stu-id="fbf4b-231">Visual Studio will then prompt you for the input parameters, `@startRowIndex` and `@maximumRow` s (see Figure 7).</span></span> <span data-ttu-id="fbf4b-232">Farklı değerleri deneyin ve sonuçları inceleyin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-232">Try different values and examine the results.</span></span>

![@startRowIndex ve @maximumRows parametreleri için bir değer girin](efficiently-paging-through-large-amounts-of-data-cs/_static/image7.png)

<span data-ttu-id="fbf4b-234"><strong>Şekil 7</strong>: @startRowIndex ve @maximumRows parametreleri için bir değer girin</span><span class="sxs-lookup"><span data-stu-id="fbf4b-234"><strong>Figure 7</strong>: Enter a Value for the @startRowIndex and @maximumRows Parameters</span></span>

<span data-ttu-id="fbf4b-235">Bu giriş parametreleri değerlerini seçtikten sonra, çıkış penceresinde sonuçlar gösterilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-235">After choosing these input parameters values, the Output window will show the results.</span></span> <span data-ttu-id="fbf4b-236">Şekil 8 ' de `@startRowIndex` ve `@maximumRows` parametreleri için 10 ' a geçiş yaparken sonuçlar gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-236">Figure 8 shows the results when passing in 10 for both the `@startRowIndex` and `@maximumRows` parameters.</span></span>

<span data-ttu-id="fbf4b-237">[Verilerin Ikinci sayfasında görünen kayıtlar ![döndürülür](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)</span><span class="sxs-lookup"><span data-stu-id="fbf4b-237">[![The Records That Would Appear in the Second Page of Data are Returned](efficiently-paging-through-large-amounts-of-data-cs/_static/image9.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image8.png)</span></span>

<span data-ttu-id="fbf4b-238">**Şekil 8**: Verilerin Ikinci sayfasında görünen kayıtlar döndürülür ([tam boyutlu görüntüyü görüntülemek Için tıklayın](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png))</span><span class="sxs-lookup"><span data-stu-id="fbf4b-238">**Figure 8**: The Records That Would Appear in the Second Page of Data are Returned ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image10.png))</span></span>

<span data-ttu-id="fbf4b-239">Bu saklı yordam oluşturulduktan sonra `ProductsTableAdapter` yöntemi oluşturmaya hazırız.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-239">With this stored procedure created, we re ready to create the `ProductsTableAdapter` method.</span></span> <span data-ttu-id="fbf4b-240">`Northwind.xsd` türü belirtilmiş veri kümesini açın, `ProductsTableAdapter`sağ tıklayın ve sorgu Ekle seçeneğini belirleyin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-240">Open the `Northwind.xsd` Typed DataSet, right-click in the `ProductsTableAdapter`, and choose the Add Query option.</span></span> <span data-ttu-id="fbf4b-241">Geçici bir SQL ifadesini kullanarak sorgu oluşturmak yerine, mevcut bir saklı yordamı kullanarak oluşturun.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-241">Instead of creating the query using an ad-hoc SQL statement, create it using an existing stored procedure.</span></span>

![Varolan bir saklı yordamı kullanarak DAL metodunu oluşturma](efficiently-paging-through-large-amounts-of-data-cs/_static/image11.png)

<span data-ttu-id="fbf4b-243">**Şekil 9**: Varolan bir saklı yordamı kullanarak DAL metodunu oluşturma</span><span class="sxs-lookup"><span data-stu-id="fbf4b-243">**Figure 9**: Create the DAL Method Using an Existing Stored Procedure</span></span>

<span data-ttu-id="fbf4b-244">Ardından, çağrılacak saklı yordamı seçeceğiz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-244">Next, we are prompted to select the stored procedure to invoke.</span></span> <span data-ttu-id="fbf4b-245">Açılan listeden `GetProductsPaged` saklı yordamını seçin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-245">Pick the `GetProductsPaged` stored procedure from the drop-down list.</span></span>

![Açılan listeden GetProductsPaged saklı yordamını seçin](efficiently-paging-through-large-amounts-of-data-cs/_static/image12.png)

<span data-ttu-id="fbf4b-247">**Şekil 10**: Açılan listeden GetProductsPaged saklı yordamını seçin</span><span class="sxs-lookup"><span data-stu-id="fbf4b-247">**Figure 10**: Choose the GetProductsPaged Stored Procedure from the Drop-Down List</span></span>

<span data-ttu-id="fbf4b-248">Ardından, bir sonraki ekranda, saklı yordam tarafından döndürülen veri türünü, tek bir değeri veya değeri olmadığını sorar.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-248">The next screen then asks you what kind of data is returned by the stored procedure: tabular data, a single value, or no value.</span></span> <span data-ttu-id="fbf4b-249">`GetProductsPaged` saklı yordamı birden çok kayıt döndürebileceğinizden bu yana tablo verileri döndürdüğünden emin olduğunu belirtin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-249">Since the `GetProductsPaged` stored procedure can return multiple records, indicate that it returns tabular data.</span></span>

![Saklı yordamın tablo verilerini döndürdüğünü belirtir](efficiently-paging-through-large-amounts-of-data-cs/_static/image13.png)

<span data-ttu-id="fbf4b-251">**Şekil 11**: Saklı yordamın tablo verilerini döndürdüğünü belirtir</span><span class="sxs-lookup"><span data-stu-id="fbf4b-251">**Figure 11**: Indicate that the Stored Procedure Returns Tabular Data</span></span>

<span data-ttu-id="fbf4b-252">Son olarak, oluşturulmasını istediğiniz yöntemlerin adlarını belirtin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-252">Finally, indicate the names of the methods you want to have created.</span></span> <span data-ttu-id="fbf4b-253">Önceki öğreticilerimizde olduğu gibi, bir DataTable doldur ve bir DataTable döndüren yöntemleri kullanarak devam edin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-253">As with our previous tutorials, go ahead and create methods using both the Fill a DataTable and Return a DataTable.</span></span> <span data-ttu-id="fbf4b-254">İlk yöntemi `FillPaged` ve ikinci `GetProductsPaged`adlandırın.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-254">Name the first method `FillPaged` and the second `GetProductsPaged`.</span></span>

![Yöntemleri Filldisk belleğine ve GetProductsPaged olarak adlandırın](efficiently-paging-through-large-amounts-of-data-cs/_static/image14.png)

<span data-ttu-id="fbf4b-256">**Şekil 12**: Yöntemleri Filldisk belleğine ve GetProductsPaged olarak adlandırın</span><span class="sxs-lookup"><span data-stu-id="fbf4b-256">**Figure 12**: Name the Methods FillPaged and GetProductsPaged</span></span>

<span data-ttu-id="fbf4b-257">Belirli bir ürün sayfasını döndürmek için bir DAL yöntemi oluşturmalarının yanı sıra, BLL 'de bu işlevleri de sağlamaları gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-257">In addition to created a DAL method to return a particular page of products, we also need to provide such functionality in the BLL.</span></span> <span data-ttu-id="fbf4b-258">DAL yöntemi gibi, BLL s GetProductsPaged yöntemi, başlangıç satırı dizinini ve en yüksek satırları belirtmek için iki tamsayı girişi kabul etmelidir ve yalnızca belirtilen aralıkta kalan kayıtları döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-258">Like the DAL method, the BLL s GetProductsPaged method must accept two integer inputs for specifying the Start Row Index and Maximum Rows, and must return just those records that fall within the specified range.</span></span> <span data-ttu-id="fbf4b-259">Bu tür bir BLL yöntemi oluşturun, örneğin, yalnızca DAL s GetProductsPaged yöntemine çağrı yapan ProductsBLL sınıfında:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-259">Create such a BLL method in the ProductsBLL class that merely calls down into the DAL s GetProductsPaged method, like so:</span></span>

[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample8.cs)]

<span data-ttu-id="fbf4b-260">BLL metodu giriş parametreleri için herhangi bir ad kullanabilirsiniz, ancak kısa bir süre içinde, `startRowIndex` kullanmayı seçip `maximumRows`, bu yöntemi kullanmak üzere bir ObjectDataSource 'u yapılandırırken daha fazla çalışma alanından bize tasarruf edersiniz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-260">You can use any name for the BLL method s input parameters, but, as we will see shortly, choosing to use `startRowIndex` and `maximumRows` saves us from an extra bit of work when configuring an ObjectDataSource to use this method.</span></span>

## <a name="step-4-configuring-the-objectdatasource-to-use-custom-paging"></a><span data-ttu-id="fbf4b-261">4\. Adım: ObjectDataSource 'ı özel sayfalama kullanacak şekilde yapılandırma</span><span class="sxs-lookup"><span data-stu-id="fbf4b-261">Step 4: Configuring the ObjectDataSource to Use Custom Paging</span></span>

<span data-ttu-id="fbf4b-262">Belirli bir kayıt alt kümesine erişim için BLL ve DAL yöntemleriyle, özel sayfalama kullanarak alttaki kayıtları aracılığıyla sayfaları veren bir GridView denetimi oluşturmaya hazırız.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-262">With the BLL and DAL methods for accessing a particular subset of records complete, we re ready to create a GridView control that pages through its underlying records using custom paging.</span></span> <span data-ttu-id="fbf4b-263">`PagingAndSorting` klasöründeki `EfficientPaging.aspx` sayfasını açıp sayfaya bir GridView ekleyin ve yeni bir ObjectDataSource denetimi kullanmak üzere yapılandırın.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-263">Start by opening the `EfficientPaging.aspx` page in the `PagingAndSorting` folder, add a GridView to the page, and configure it to use a new ObjectDataSource control.</span></span> <span data-ttu-id="fbf4b-264">Geçmiş öğreticilerimizde, genellikle `ProductsBLL` sınıf s `GetProducts` metodunu kullanacak şekilde yapılandırılan ObjectDataSource vardı.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-264">In our past tutorials, we often had the ObjectDataSource configured to use the `ProductsBLL` class s `GetProducts` method.</span></span> <span data-ttu-id="fbf4b-265">Ancak, `GetProducts` yöntemi veritabanındaki *Tüm* ürünleri döndürdüğünden `GetProductsPaged` yalnızca belirli bir kayıt alt kümesini döndürdüğünden, bunun yerine `GetProductsPaged` yöntemini kullanmak istiyoruz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-265">This time, however, we want to use the `GetProductsPaged` method instead, since the `GetProducts` method returns *all* of the products in the database whereas `GetProductsPaged` returns just a particular subset of records.</span></span>

![ObjectDataSource 'ı ProductsBLL Class s GetProductsPaged metodunu kullanacak şekilde yapılandırma](efficiently-paging-through-large-amounts-of-data-cs/_static/image15.png)

<span data-ttu-id="fbf4b-267">**Şekil 13**: ObjectDataSource 'ı ProductsBLL Class s GetProductsPaged metodunu kullanacak şekilde yapılandırma</span><span class="sxs-lookup"><span data-stu-id="fbf4b-267">**Figure 13**: Configure the ObjectDataSource to Use the ProductsBLL Class s GetProductsPaged Method</span></span>

<span data-ttu-id="fbf4b-268">Salt okunurdur bir GridView oluşturuyoruz, INSERT, UPDATE ve DELETE sekmelerinde (None) yöntem açılan listesini ayarlamak için bir dakikanızı ayırın.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-268">Since we re creating a read-only GridView, take a moment to set the method drop-down list in the INSERT, UPDATE, and DELETE tabs to (None).</span></span>

<span data-ttu-id="fbf4b-269">Ardından, ObjectDataSource Sihirbazı bize `GetProductsPaged` Yöntem `startRowIndex` ve `maximumRows` giriş parametresi değerlerinin kaynaklarını ister.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-269">Next, the ObjectDataSource wizard prompts us for the sources of the `GetProductsPaged` method s `startRowIndex` and `maximumRows` input parameters values.</span></span> <span data-ttu-id="fbf4b-270">Bu giriş parametreleri aslında GridView tarafından otomatik olarak ayarlanır, bu nedenle kaynak kümesini None olarak bırakıp son ' a tıklayın.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-270">These input parameters will actually be set by the GridView automatically, so simply leave the source set to None and click Finish.</span></span>

![Giriş parametresi kaynaklarını hiçbiri olarak bırak](efficiently-paging-through-large-amounts-of-data-cs/_static/image16.png)

<span data-ttu-id="fbf4b-272">**Şekil 14**: Giriş parametresi kaynaklarını hiçbiri olarak bırak</span><span class="sxs-lookup"><span data-stu-id="fbf4b-272">**Figure 14**: Leave the Input Parameter Sources as None</span></span>

<span data-ttu-id="fbf4b-273">ObjectDataSource Sihirbazı 'nı tamamladıktan sonra GridView, ürün verileri alanlarının her biri için bir BoundField veya CheckBoxField içerecektir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-273">After completing the ObjectDataSource wizard, the GridView will contain a BoundField or CheckBoxField for each of the product data fields.</span></span> <span data-ttu-id="fbf4b-274">GridView s görünümünü uygun gördüğünüz şekilde uyarlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-274">Feel free to tailor the GridView s appearance as you see fit.</span></span> <span data-ttu-id="fbf4b-275">& Yalnızca `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`ve `UnitPrice` BoundFields alanlarını görüntülemeyi tercih ediyorum.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-275">I ve opted to display only the `ProductName`, `CategoryName`, `SupplierName`, `QuantityPerUnit`, and `UnitPrice` BoundFields.</span></span> <span data-ttu-id="fbf4b-276">Ayrıca, GridView 'u akıllı etiketinde sayfalama etkinleştir onay kutusunu işaretleyerek sayfalamayı destekleyecek şekilde yapılandırın.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-276">Also, configure the GridView to support paging by checking the Enable Paging checkbox in its smart tag.</span></span> <span data-ttu-id="fbf4b-277">Bu değişikliklerden sonra, GridView ve ObjectDataSource tanımlayıcı biçimlendirme biçimlendirmesi aşağıdakine benzer görünmelidir:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-277">After these changes, the GridView and ObjectDataSource declarative markup should look similar to the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample9.aspx)]

<span data-ttu-id="fbf4b-278">Ancak sayfayı bir tarayıcı aracılığıyla ziyaret ederseniz, GridView nerede bulunur.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-278">If you visit the page through a browser, however, the GridView is no where to be found.</span></span>

![GridView görüntülenmiyor](efficiently-paging-through-large-amounts-of-data-cs/_static/image17.png)

<span data-ttu-id="fbf4b-280">**Şekil 15**: GridView görüntülenmiyor</span><span class="sxs-lookup"><span data-stu-id="fbf4b-280">**Figure 15**: The GridView is Not Displayed</span></span>

<span data-ttu-id="fbf4b-281">ObjectDataSource Şu anda `GetProductsPaged` `startRowIndex` ve `maximumRows` giriş parametrelerinin her ikisi için değer olarak 0 kullandığından GridView eksik.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-281">The GridView is missing because the ObjectDataSource is currently using 0 as the values for both of the `GetProductsPaged` `startRowIndex` and `maximumRows` input parameters.</span></span> <span data-ttu-id="fbf4b-282">Bu nedenle, ortaya çıkan SQL sorgusu kayıt döndürmüyor ve bu nedenle GridView görüntülenmez.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-282">Hence, the resulting SQL query is returning no records and therefore the GridView is not displayed.</span></span>

<span data-ttu-id="fbf4b-283">Bu sorunu gidermek için, ObjectDataSource 'u özel sayfalama kullanacak şekilde yapılandırmamız gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-283">To remedy this, we need to configure the ObjectDataSource to use custom paging.</span></span> <span data-ttu-id="fbf4b-284">Bu, aşağıdaki adımlarda gerçekleştirilebilir:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-284">This can be accomplished in the following steps:</span></span>

1. <span data-ttu-id="fbf4b-285">**Objectdatasource `EnablePaging` özelliğini `true`olarak ayarlayın** . Bu, "başlangıç satırı dizinini ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)) ve diğeri de en yüksek satırları ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)) belirtmek için bir tane olmak üzere Iki ek parametreye `SelectMethod` geçmesi gereken ObjectDataSource 'a gösterir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-285">**Set the ObjectDataSource s `EnablePaging` property to `true`** this indicates to the ObjectDataSource that it must pass to the `SelectMethod` two additional parameters: one to specify the Start Row Index ([`StartRowIndexParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.startrowindexparametername.aspx)), and one to specify the Maximum Rows ([`MaximumRowsParameterName`](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.maximumrowsparametername.aspx)).</span></span>
2. <span data-ttu-id="fbf4b-286">**ObjectDataSource `StartRowIndexParameterName` ve `MaximumRowsParameterName` özelliklerini** `StartRowIndexParameterName` ve `MaximumRowsParameterName` özellikleri, özel sayfalama amacıyla `SelectMethod` geçirilen giriş parametrelerinin adlarını belirtir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-286">**Set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` Properties Accordingly** the `StartRowIndexParameterName` and `MaximumRowsParameterName` properties indicate the names of the input parameters passed into the `SelectMethod` for custom paging purposes.</span></span> <span data-ttu-id="fbf4b-287">Varsayılan olarak, bu parametre adları `startIndexRow` ve `maximumRows`, bu nedenle BLL 'de `GetProductsPaged` yöntemi oluştururken giriş parametreleri için bu değerleri kullandım.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-287">By default, these parameter names are `startIndexRow` and `maximumRows`, which is why, when creating the `GetProductsPaged` method in the BLL, I used these values for the input parameters.</span></span> <span data-ttu-id="fbf4b-288">`startIndex` ve `maxRows`gibi BLL s `GetProductsPaged` yöntemi için farklı parametre adları kullanmayı seçerseniz Örneğin, ObjectDataSource s `StartRowIndexParameterName` ve `MaximumRowsParameterName` özelliklerini uygun şekilde ayarlamanız gerekir (`StartRowIndexParameterName` için `MaximumRowsParameterName`ve maxRows için startIndex gibi).</span><span class="sxs-lookup"><span data-stu-id="fbf4b-288">If you chose to use different parameter names for the BLL s `GetProductsPaged` method such as `startIndex` and `maxRows`, for example you would need to set the ObjectDataSource s `StartRowIndexParameterName` and `MaximumRowsParameterName` properties accordingly (such as startIndex for `StartRowIndexParameterName` and maxRows for `MaximumRowsParameterName`).</span></span>
3. <span data-ttu-id="fbf4b-289">**ObjectDataSource [`SelectCountMethod` özelliğini](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) , disk belleğine alınan toplam kayıt sayısını döndüren metodun adına ayarlayın (`TotalNumberOfProducts`)** `ProductsBLL` sınıf s `TotalNumberOfProducts` yönteminin, `SELECT COUNT(*) FROM Products` sorgu yürüten bir dal yöntemi kullanarak disk belleğine alınan toplam kayıt sayısını döndürdüğünü hatırlayın.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-289">**Set the ObjectDataSource s [`SelectCountMethod` Property](https://msdn.microsoft.com/library/system.web.ui.webcontrols.objectdatasource.selectcountmethod(VS.80).aspx) to the Name of the Method that Returns the Total Number of Records Being Paged Through (`TotalNumberOfProducts`)** recall that the `ProductsBLL` class s `TotalNumberOfProducts` method returns the total number of records being paged through using a DAL method that executes a `SELECT COUNT(*) FROM Products` query.</span></span> <span data-ttu-id="fbf4b-290">Bu bilgiler, disk belleği arabirimini doğru bir şekilde işlemek için ObjectDataSource tarafından gereklidir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-290">This information is needed by the ObjectDataSource in order to correctly render the paging interface.</span></span>
4. <span data-ttu-id="fbf4b-291">**`startRowIndex` ve `maximumRows` `<asp:Parameter>` öğelerini** , ObjectDataSource tarafından sihirbaz aracılığıyla yapılandırılırken, Visual Studio `GetProductsPaged` yöntem s giriş parametreleri için otomatik olarak iki `<asp:Parameter>` öğesi ekledi.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-291">**Remove the `startRowIndex` and `maximumRows` `<asp:Parameter>` Elements from the ObjectDataSource s Declarative Markup** when configuring the ObjectDataSource through the wizard, Visual Studio automatically added two `<asp:Parameter>` elements for the `GetProductsPaged` method s input parameters.</span></span> <span data-ttu-id="fbf4b-292">`EnablePaging` `true`olarak ayarlayarak, bu parametreler otomatik olarak geçirilir; bildirim temelli sözdiziminde de görünüyorsa, ObjectDataSource `GetProductsPaged` yöntemine *dört* parametre ve `TotalNumberOfProducts` yöntemine iki parametre geçirmeye çalışacaktır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-292">By setting `EnablePaging` to `true`, these parameters will be passed automatically; if they also appear in the declarative syntax, the ObjectDataSource will attempt to pass *four* parameters to the `GetProductsPaged` method and two parameters to the `TotalNumberOfProducts` method.</span></span> <span data-ttu-id="fbf4b-293">Bu `<asp:Parameter>` öğelerini kaldırmayı unutursanız, sayfayı bir tarayıcı aracılığıyla ziyaret ederken şöyle bir hata iletisi alırsınız: *' ObjectDataSource1 ' ObjectDataSource genel olmayan ve parametreleri olan bir ' TotalNumberOfProducts ' yöntemi bulamadı: StartRowIndex, maximumRows*.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-293">If you forget to remove these `<asp:Parameter>` elements, when visiting the page through a browser you'll get an error message like: *ObjectDataSource 'ObjectDataSource1' could not find a non-generic method 'TotalNumberOfProducts' that has parameters: startRowIndex, maximumRows*.</span></span>

<span data-ttu-id="fbf4b-294">Bu değişiklikleri yaptıktan sonra, ObjectDataSource 'un bildirime dayalı sözdizimi aşağıdaki gibi görünmelidir:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-294">After making these changes, the ObjectDataSource s declarative syntax should look like the following:</span></span>

[!code-aspx[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample10.aspx)]

<span data-ttu-id="fbf4b-295">`EnablePaging` ve `SelectCountMethod` özelliklerinin ayarlandığını ve `<asp:Parameter>` öğelerin kaldırıldığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-295">Note that the `EnablePaging` and `SelectCountMethod` properties have been set and the `<asp:Parameter>` elements have been removed.</span></span> <span data-ttu-id="fbf4b-296">Şekil 16, bu değişiklikler yapıldıktan sonra Özellikler penceresi ekran görüntüsünü gösterir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-296">Figure 16 shows a screen shot of the Properties window after these changes have been made.</span></span>

![Özel sayfalama kullanmak için, ObjectDataSource denetimini yapılandırın](efficiently-paging-through-large-amounts-of-data-cs/_static/image18.png)

<span data-ttu-id="fbf4b-298">**Şekil 16**: Özel sayfalama kullanmak için, ObjectDataSource denetimini yapılandırın</span><span class="sxs-lookup"><span data-stu-id="fbf4b-298">**Figure 16**: To Use Custom Paging, Configure the ObjectDataSource Control</span></span>

<span data-ttu-id="fbf4b-299">Bu değişiklikleri yaptıktan sonra bu sayfayı bir tarayıcı aracılığıyla ziyaret edin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-299">After making these changes, visit this page through a browser.</span></span> <span data-ttu-id="fbf4b-300">Alfabetik olarak sıralanan 10 ürün listelendiğini görmeniz gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-300">You should see 10 products listed, ordered alphabetically.</span></span> <span data-ttu-id="fbf4b-301">Verileri tek seferde bir sayfada ilerlemek için bir dakikanızı ayırın.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-301">Take a moment to step through the data one page at a time.</span></span> <span data-ttu-id="fbf4b-302">Varsayılan sayfalama ve özel sayfalama arasındaki Son Kullanıcı perspektifinden, özel sayfalama, yalnızca belirli bir sayfa için görüntülenmesi gereken kayıtları aldığı için, büyük miktarlarda veri aracılığıyla daha verimli sayfalar sağlar.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-302">While there is no visual difference from the end user s perspective between default paging and custom paging, custom paging more efficiently pages through large amounts of data as it only retrieves those records that need to be displayed for a given page.</span></span>

<span data-ttu-id="fbf4b-303">[Ürün adına göre sıralanmış verilerin ![, özel sayfalama kullanılarak Sayfalanmalıdır](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)</span><span class="sxs-lookup"><span data-stu-id="fbf4b-303">[![The Data, Ordered by the Product s Name, is Paged Using Custom Paging](efficiently-paging-through-large-amounts-of-data-cs/_static/image20.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image19.png)</span></span>

<span data-ttu-id="fbf4b-304">**Şekil 17**: Ürün adına göre sıralanmış veriler özel sayfalama ([tam boyutlu görüntüyü görüntülemek Için tıklayın](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png)) kullanılarak sayfalanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-304">**Figure 17**: The Data, Ordered by the Product s Name, is Paged Using Custom Paging ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image21.png))</span></span>

> [!NOTE]
> <span data-ttu-id="fbf4b-305">Özel sayfalama sayesinde, ObjectDataSource s `SelectCountMethod` tarafından döndürülen sayfa sayısı değeri, GridView s Görünüm durumunda depolanır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-305">With custom paging, the page count value returned by the ObjectDataSource�s `SelectCountMethod` is stored in the GridView�s view state.</span></span> <span data-ttu-id="fbf4b-306">`PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` koleksiyonu vb. diğer GridView değişkenleri, GridView s `EnableViewState` özelliğinin değerine bakılmaksızın kalıcı olan *Denetim durumunda*depolanır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-306">Other GridView variables the `PageIndex`, `EditIndex`, `SelectedIndex`, `DataKeys` collection, and so on are stored in *control state*, which is persisted regardless of the value of the GridView�s `EnableViewState` property.</span></span> <span data-ttu-id="fbf4b-307">`PageCount` değeri görünüm durumu kullanılarak geri göndermeler arasında kalıcı olduğundan, son sayfaya gitmek için bir bağlantı içeren bir sayfalama arabirimi kullanırken, GridView s görünüm durumunun etkinleştirilmesi zorunludur.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-307">Since the `PageCount` value is persisted across postbacks using view state, when using a paging interface that includes a link to take you to the last page, it is imperative that the GridView�s view state be enabled.</span></span> <span data-ttu-id="fbf4b-308">(Sayfalama arabiriminiz son sayfaya doğrudan bir bağlantı içermiyorsa, görünüm durumunu devre dışı bırakabilirsiniz.)</span><span class="sxs-lookup"><span data-stu-id="fbf4b-308">(If your paging interface does not include a direct link to the last page, then you may disable view state.)</span></span>

<span data-ttu-id="fbf4b-309">Son sayfa bağlantısına tıkladığınızda geri göndermeye neden olur ve GridView 'un `PageIndex` özelliğini güncelleştirmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-309">Clicking the last page link causes a postback and instructs the GridView to update its `PageIndex` property.</span></span> <span data-ttu-id="fbf4b-310">Son sayfa bağlantısına tıklandıysanız, GridView `PageIndex` özelliğini `PageCount` özelliğinden daha küçük bir değere atar.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-310">If the last page link is clicked, the GridView assigns its `PageIndex` property to a value one less than its `PageCount` property.</span></span> <span data-ttu-id="fbf4b-311">Görünüm durumu devre dışı bırakıldığında, `PageCount` değeri geri göndermeler arasında kaybolur ve bunun yerine `PageIndex` en büyük tamsayı değeri atanır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-311">With view state disabled, the `PageCount` value is lost across postbacks and the `PageIndex` is assigned the maximum integer value instead.</span></span> <span data-ttu-id="fbf4b-312">Daha sonra, GridView `PageSize` ve `PageCount` özelliklerini çarparak başlangıç satırı dizinini saptamaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-312">Next, the GridView attempts to determine the starting row index by multiplying the `PageSize` and `PageCount` properties.</span></span> <span data-ttu-id="fbf4b-313">Ürünün izin verilen en büyük tamsayı boyutunu aşması bu yana bir `OverflowException` sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-313">This results in an `OverflowException` since the product exceeds the maximum allowed integer size.</span></span>

## <a name="implement-custom-paging-and-sorting"></a><span data-ttu-id="fbf4b-314">Özel sayfalama ve sıralama uygulama</span><span class="sxs-lookup"><span data-stu-id="fbf4b-314">Implement Custom Paging and Sorting</span></span>

<span data-ttu-id="fbf4b-315">Geçerli özel sayfalama uygulamamız, `GetProductsPaged` saklı yordam oluşturulurken verilerin disk belleğine alınan sırasının statik olarak belirtilmesini gerektirir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-315">Our current custom paging implementation requires that the order by which the data is paged through be specified statically when creating the `GetProductsPaged` stored procedure.</span></span> <span data-ttu-id="fbf4b-316">Ancak, sayfalama etkinleştir seçeneğinin yanı sıra GridView s akıllı etiketinin sıralamayı etkinleştir onay kutusunu içerdiğini Not alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-316">However, you may have noted that the GridView s smart tag contains an Enable Sorting checkbox in addition to the Enable Paging option.</span></span> <span data-ttu-id="fbf4b-317">Ne yazık ki, geçerli özel sayfalama uygulamamız ile GridView 'a sıralama desteği eklemek, yalnızca şu anda görüntülenen veri sayfasındaki kayıtları sıralayacak.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-317">Unfortunately, adding sorting support to the GridView with our current custom paging implementation will only sort the records on the currently viewed page of data.</span></span> <span data-ttu-id="fbf4b-318">Örneğin, GridView 'u sayfalama 'yi de destekleyecek şekilde yapılandırırsanız, ilk veri sayfasını görüntülerken, ürün adına göre azalan sırada sıralama yaparken, sayfa 1 ' deki ürünlerin sırası tersine alınır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-318">For example, if you configure the GridView to also support paging and then, when viewing the first page of data, sort by product name in descending order, it will reverse the order of the products on page 1.</span></span> <span data-ttu-id="fbf4b-319">Şekil 18 ' de gösterildiği gibi, geriye doğru alfabetik 71 sırada sıralama yaparken ilk ürün gibi Carnarvon Tiger 'ları gösterir. sıralamada yalnızca ilk sayfadaki kayıtlar göz önünde bulundurululur.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-319">As Figure 18 shows, such shows Carnarvon Tigers as the first product when sorting in reverse alphabetical order, which ignores the 71 other products that come after Carnarvon Tigers, alphabetically; only those records on the first page are considered in the sorting.</span></span>

<span data-ttu-id="fbf4b-320">[Yalnızca geçerli sayfada gösterilen veriler ![sıralanır](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)</span><span class="sxs-lookup"><span data-stu-id="fbf4b-320">[![Only the Data Shown on the Current Page is Sorted](efficiently-paging-through-large-amounts-of-data-cs/_static/image23.png)](efficiently-paging-through-large-amounts-of-data-cs/_static/image22.png)</span></span>

<span data-ttu-id="fbf4b-321">**Şekil 18**: Yalnızca geçerli sayfada gösterilen veriler sıralanır ([tam boyutlu görüntüyü görüntülemek Için tıklayın](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png))</span><span class="sxs-lookup"><span data-stu-id="fbf4b-321">**Figure 18**: Only the Data Shown on the Current Page is Sorted ([Click to view full-size image](efficiently-paging-through-large-amounts-of-data-cs/_static/image24.png))</span></span>

<span data-ttu-id="fbf4b-322">Sıralama, veriler BLL s `GetProductsPaged` yönteminden alındıktan sonra sıralama yapıldığından ve bu yöntem yalnızca belirli bir sayfa için bu kayıtları döndürdüğünden, yalnızca geçerli veri sayfası için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-322">The sorting only applies to the current page of data because the sorting is occurring after the data has been retrieved from the BLL s `GetProductsPaged` method, and this method only returns those records for the specific page.</span></span> <span data-ttu-id="fbf4b-323">Sıralamayı doğru şekilde uygulamak için sıralama ifadesini `GetProductsPaged` yöntemine geçirmemiz gerekir. böylece veriler, verilerin belirli bir sayfasını döndürmeden önce uygun şekilde derecelendirilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-323">To implement sorting correctly, we need to pass the sort expression to the `GetProductsPaged` method so that the data can be ranked appropriately before returning the specific page of data.</span></span> <span data-ttu-id="fbf4b-324">Bunu bir sonraki öğreticimizde nasıl gerçekleştireceğinizi öğreneceğiz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-324">We'll see how to accomplish this in our next tutorial.</span></span>

## <a name="implementing-custom-paging-and-deleting"></a><span data-ttu-id="fbf4b-325">Özel sayfalama uygulama ve silme</span><span class="sxs-lookup"><span data-stu-id="fbf4b-325">Implementing Custom Paging and Deleting</span></span>

<span data-ttu-id="fbf4b-326">Özel disk belleği tekniklerini kullanarak verileri sayfalandırılmış bir GridView 'da silme işlevini etkinleştirirseniz, son sayfadan son kayıt silinirken GridView 'in, GridView s `PageIndex`uygun bir şekilde azaltılamadığına göre kaybolduğunu görürsünüz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-326">If you enabling deleting functionality in a GridView whose data is paged using custom paging techniques you will find that when deleting the last record from the last page, the GridView disappears rather than appropriately decrementing the GridView s `PageIndex`.</span></span> <span data-ttu-id="fbf4b-327">Bu hatayı yeniden oluşturmak için, yalnızca yeni oluşturduğumuz öğreticide silmeyi etkinleştirin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-327">To reproduce this bug, enable deleting for the tutorial just we just created.</span></span> <span data-ttu-id="fbf4b-328">Bir kerede 81 ürün, 10 ürün ile sayfalama yaptığımız için tek bir ürün görmeniz gereken son sayfaya (sayfa 9) gidin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-328">Go to the last page (page 9), where you should see a single product since we are paging through 81 products, 10 products at a time.</span></span> <span data-ttu-id="fbf4b-329">Bu ürünü silin.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-329">Delete this product.</span></span>

<span data-ttu-id="fbf4b-330">Son ürünü sildikten sonra, GridView otomatik olarak sekizinci sayfasına *gitmeli* ve bu tür işlevlere varsayılan sayfalama söz konusu olduğunda izin verilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-330">Upon deleting the last product, the GridView *should* automatically go to the eighth page, and such functionality is exhibited with default paging.</span></span> <span data-ttu-id="fbf4b-331">Ancak, özel sayfalama ile son sayfadaki son ürünü sildikten sonra, GridView yalnızca ekrandan kaybolur.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-331">With custom paging, however, after deleting that last product on the last page, the GridView simply disappears from the screen altogether.</span></span> <span data-ttu-id="fbf4b-332">Bunun *tam nedeni, bu* öğreticinin kapsamının ötesinde bir bit olur; Bu sorunun kaynağına göre alt düzey Ayrıntılar için [Özel sayfalama ile bir GridView 'Dan son sayfadaki son kaydı silme](http://scottonwriting.net/sowblog/posts/7326.aspx) bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-332">The precise reason *why* this happens is a bit beyond the scope of this tutorial; see [Deleting the Last Record on the Last Page from a GridView with Custom Paging](http://scottonwriting.net/sowblog/posts/7326.aspx) for the low-level details as to the source of this problem.</span></span> <span data-ttu-id="fbf4b-333">Özet içinde, Sil düğmesine tıklandığında GridView tarafından gerçekleştirilen aşağıdaki adım dizisi nedeniyle bu ayrıntıları izleyin:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-333">In summary it s due to the following sequence of steps that are performed by the GridView when the Delete button is clicked:</span></span>

1. <span data-ttu-id="fbf4b-334">Kaydı silme</span><span class="sxs-lookup"><span data-stu-id="fbf4b-334">Delete the record</span></span>
2. <span data-ttu-id="fbf4b-335">Belirtilen `PageIndex` ve `PageSize` görüntülenecek uygun kayıtları alın</span><span class="sxs-lookup"><span data-stu-id="fbf4b-335">Get the appropriate records to display for the specified `PageIndex` and `PageSize`</span></span>
3. <span data-ttu-id="fbf4b-336">`PageIndex` veri kaynağındaki veri sayfalarının sayısını aşmadığından emin olun; varsa, GridView s `PageIndex` özelliğini otomatik olarak azaltır</span><span class="sxs-lookup"><span data-stu-id="fbf4b-336">Check to ensure that the `PageIndex` does not exceed the number of pages of data in the data source; if it does, automatically decrement the GridView s `PageIndex` property</span></span>
4. <span data-ttu-id="fbf4b-337">2\. adımda elde edilen kayıtları kullanarak GridView 'a uygun veri sayfasını bağlama</span><span class="sxs-lookup"><span data-stu-id="fbf4b-337">Bind the appropriate page of data to the GridView using the records obtained in Step 2</span></span>

<span data-ttu-id="fbf4b-338">Sorun, yakalayıp. adımdaki `PageIndex`, tek kaydı yeni silinen son sayfanın `PageIndex` olmaya devam ediyorsa, bu sorunun adım 2 ' de sorun.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-338">The problem stems from the fact that in Step 2 the `PageIndex` used when grabbing the records to display is still the `PageIndex` of the last page whose sole record was just deleted.</span></span> <span data-ttu-id="fbf4b-339">Bu nedenle, adım 2 ' de, verilerin son sayfası artık hiçbir kayıt bulunmadığından *hiçbir kayıt döndürülmez* .</span><span class="sxs-lookup"><span data-stu-id="fbf4b-339">Therefore, in Step 2, *no* records are returned since that last page of data no longer contains any records.</span></span> <span data-ttu-id="fbf4b-340">Daha sonra, adım 3 ' te GridView, `PageIndex` özelliğinin veri kaynağındaki toplam sayfa sayısından daha büyük olduğunu (son sayfadaki son kaydı silmiş olduğundan) ve bu nedenle `PageIndex` özelliğini azaltır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-340">Then, in Step 3, the GridView realizes that its `PageIndex` property is greater than the total number of pages in the data source (since we ve deleted the last record in the last page) and therefore decrements its `PageIndex` property.</span></span> <span data-ttu-id="fbf4b-341">4\. adımda GridView, adım 2 ' de alınan verilere kendisini bağlamayı dener; Ancak, 2. adımda hiçbir kayıt döndürülmedi, bu nedenle boş bir GridView ile sonuçlanır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-341">In Step 4 the GridView attempts to bind itself to the data retrieved in Step 2; however, in Step 2 no records were returned, therefore resulting in an empty GridView.</span></span> <span data-ttu-id="fbf4b-342">Varsayılan sayfalama ile bu sorun, 2. adımdaki *Tüm* kayıtlar veri kaynağından alındığından, bu sorun bir yüzey değildir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-342">With default paging, this problem doesn t surface because in Step 2 *all* records are retrieved from the data source.</span></span>

<span data-ttu-id="fbf4b-343">Bunu yapmak için iki seçeneğiniz vardır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-343">To fix this we have two options.</span></span> <span data-ttu-id="fbf4b-344">Birincisi, yeni silinen sayfada kaç kaydın görüntülendiğini belirleyen GridView s `RowDeleted` olay işleyicisi için bir olay işleyicisi oluşturmaktır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-344">The first is to create an event handler for the GridView s `RowDeleted` event handler that determines how many records were displayed in the page that was just deleted.</span></span> <span data-ttu-id="fbf4b-345">Yalnızca bir kayıt varsa, yeni silinen kayıt en son bir tane olmalıdır ve GridView s `PageIndex`azaltmemiz gerekiyor.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-345">If there was only one record, then the record just deleted must have been the last one and we need to decrement the GridView s `PageIndex`.</span></span> <span data-ttu-id="fbf4b-346">Elbette yalnızca silme işlemi başarılı olduysa `PageIndex` güncelleştirmek istiyoruz. Bu, `e.Exception` özelliğinin `null`olduğundan belirlenebilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-346">Of course, we only want to update the `PageIndex` if the delete operation was actually successful, which can be determined by ensuring that the `e.Exception` property is `null`.</span></span>

<span data-ttu-id="fbf4b-347">Bu yaklaşım, 1. adımdaki ve adım 2 ' den sonra `PageIndex` güncelleştirdiği için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-347">This approach works because it updates the `PageIndex` after Step 1 but before Step 2.</span></span> <span data-ttu-id="fbf4b-348">Bu nedenle, adım 2 ' de, uygun kayıt kümesi döndürülür.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-348">Therefore, in Step 2, the appropriate set of records is returned.</span></span> <span data-ttu-id="fbf4b-349">Bunu gerçekleştirmek için aşağıdaki gibi bir kod kullanın:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-349">To accomplish this, use code like the following:</span></span>

[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample11.cs)]

<span data-ttu-id="fbf4b-350">Alternatif bir geçici çözüm, ObjectDataSource s `RowDeleted` olayı için bir olay işleyicisi oluşturmak ve `AffectedRows` özelliğini 1 değerine ayarlamak içindir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-350">An alternative workaround is to create an event handler for the ObjectDataSource s `RowDeleted` event and to set the `AffectedRows` property to a value of 1.</span></span> <span data-ttu-id="fbf4b-351">Adım 1 ' deki kayıt silindikten sonra (ancak adım 2 ' deki verileri yeniden almadan önce), GridView, bir veya daha fazla satır işlemden etkilenirse `PageIndex` özelliğini güncelleştirir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-351">After deleting the record in Step 1 (but before re-retrieving the data in Step 2), the GridView updates its `PageIndex` property if one or more rows were affected by the operation.</span></span> <span data-ttu-id="fbf4b-352">Ancak, `AffectedRows` özelliği ObjectDataSource tarafından ayarlanmadı ve bu nedenle bu adım atlanır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-352">However, the `AffectedRows` property is not set by the ObjectDataSource and therefore this step is omitted.</span></span> <span data-ttu-id="fbf4b-353">Bu adımın bir yolu, silme işlemi başarıyla tamamlanırsa `AffectedRows` özelliği el ile ayarlanmektir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-353">One way to have this step executed is to manually set the `AffectedRows` property if the delete operation completes successfully.</span></span> <span data-ttu-id="fbf4b-354">Bu, aşağıdakiler gibi kod kullanılarak gerçekleştirilebilir:</span><span class="sxs-lookup"><span data-stu-id="fbf4b-354">This can be accomplished using code like the following:</span></span>

[!code-csharp[Main](efficiently-paging-through-large-amounts-of-data-cs/samples/sample12.cs)]

<span data-ttu-id="fbf4b-355">Bu olay işleyicilerinin her ikisi için de kod `EfficientPaging.aspx` örneğin arka plan kod sınıfında bulunabilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-355">The code for both of these events handlers can be found in code-behind class of the `EfficientPaging.aspx` example.</span></span>

## <a name="comparing-the-performance-of-default-and-custom-paging"></a><span data-ttu-id="fbf4b-356">Varsayılan ve özel sayfalama performansını karşılaştırma</span><span class="sxs-lookup"><span data-stu-id="fbf4b-356">Comparing the Performance of Default and Custom Paging</span></span>

<span data-ttu-id="fbf4b-357">Özel sayfalama yalnızca gerekli kayıtları aldığı için, varsayılan sayfalama görüntülenen her sayfanın *Tüm* kayıtlarını döndürdüğünden, özel sayfalama varsayılan sayfalamadan daha etkilidir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-357">Since custom paging only retrieves the needed records, whereas default paging returns *all* of the records for each page being viewed, it s clear that custom paging is more efficient than default paging.</span></span> <span data-ttu-id="fbf4b-358">Ancak özel sayfalama ne kadar verimli?</span><span class="sxs-lookup"><span data-stu-id="fbf4b-358">But just how much more efficient is custom paging?</span></span> <span data-ttu-id="fbf4b-359">Varsayılan disk belleğine özel disk belleğine geçerek performans artışı ne şekilde görülebilir?</span><span class="sxs-lookup"><span data-stu-id="fbf4b-359">What sort of performance gains can be seen by moving from default paging to custom paging?</span></span>

<span data-ttu-id="fbf4b-360">Ne yazık ki, burada hiç bir boyut tüm yanıta sığar.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-360">Unfortunately, there s no one size fits all answer here.</span></span> <span data-ttu-id="fbf4b-361">Performans kazancı, bir dizi etkene bağlıdır, en belirgin ikisi üzerinde disk belleğine alınan kayıt sayısı ve veritabanı sunucusuna ve Web sunucusu ile veritabanı sunucusu arasındaki iletişim kanallarına yerleştirilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-361">The performance gain depends on a number of factors, the most prominent two being the number of records being paged through and the load placed on the database server and communication channels between the web server and database server.</span></span> <span data-ttu-id="fbf4b-362">Yalnızca birkaç düzine kayıt içeren küçük tablolar için performans farkı göz ardı edilebilir olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-362">For small tables with just a few dozen records, the performance difference may be negligible.</span></span> <span data-ttu-id="fbf4b-363">Büyük tablolar için, binlerce ila yüzlerce satır, ancak performans farkı ise dar olur.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-363">For large tables, with thousands to hundreds of thousands of rows, though, the performance difference is acute.</span></span>

<span data-ttu-id="fbf4b-364">[SQL Server 2005 ile ASP.NET 2,0 ' de özel sayfalama](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), bir bir veritabanı 50.000 tablosu aracılığıyla disk belleği ile sayfalama yaparken, bu iki sayfalama tekniği arasındaki performans farklarını sergilediğim bazı performans testlerini içeren bir makale.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-364">An article of mine, [Custom Paging in ASP.NET 2.0 with SQL Server 2005](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx), contains some performance tests I ran to exhibit the differences in performance between these two paging techniques when paging through a database table with 50,000 records.</span></span> <span data-ttu-id="fbf4b-365">Bu testlerde, sorgu SQL Server düzeyinde ( [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)kullanarak) ve ASP.NET sayfasında [ASP.net s izleme özelliklerini](https://msdn.microsoft.com/library/y13fw6we.aspx)kullanarak sorguyu yürütmek için her iki zamanı da inceledim.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-365">In these tests I examined both the time to execute the query at the SQL Server level (using [SQL Profiler](https://msdn.microsoft.com/library/ms173757.aspx)) and at the ASP.NET page using [ASP.NET s tracing features](https://msdn.microsoft.com/library/y13fw6we.aspx).</span></span> <span data-ttu-id="fbf4b-366">Bu testlerin, tek bir etkin kullanıcıyla geliştirme kutum üzerinde çalıştırıldığını ve bu nedenle bilimsel olduğunu ve tipik web sitesi yükleme düzenlerini benzemeyeceğini göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-366">Keep in mind that these tests were run on my development box with a single active user, and therefore are unscientific and do not mimic typical website load patterns.</span></span> <span data-ttu-id="fbf4b-367">Ne olursa olsun, sonuçlar yeterince büyük miktarda verilerle çalışırken varsayılan ve özel sayfalama yürütme sürelerindeki göreli farklılıkları gösterir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-367">Regardless, the results illustrate the relative differences in execution time for default and custom paging when working with sufficiently large amounts of data.</span></span>

|  | <span data-ttu-id="fbf4b-368">**ort. Süre (sn)**</span><span class="sxs-lookup"><span data-stu-id="fbf4b-368">**Avg. Duration (sec)**</span></span> | <span data-ttu-id="fbf4b-369">**Okur**</span><span class="sxs-lookup"><span data-stu-id="fbf4b-369">**Reads**</span></span> |
| --- | --- | --- |
| <span data-ttu-id="fbf4b-370">**Varsayılan sayfalama SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="fbf4b-370">**Default Paging SQL Profiler**</span></span> | <span data-ttu-id="fbf4b-371">1.411</span><span class="sxs-lookup"><span data-stu-id="fbf4b-371">1.411</span></span> | <span data-ttu-id="fbf4b-372">383</span><span class="sxs-lookup"><span data-stu-id="fbf4b-372">383</span></span> |
| <span data-ttu-id="fbf4b-373">**Özel sayfalama SQL Profiler**</span><span class="sxs-lookup"><span data-stu-id="fbf4b-373">**Custom Paging SQL Profiler**</span></span> | <span data-ttu-id="fbf4b-374">0.002</span><span class="sxs-lookup"><span data-stu-id="fbf4b-374">0.002</span></span> | <span data-ttu-id="fbf4b-375">29</span><span class="sxs-lookup"><span data-stu-id="fbf4b-375">29</span></span> |
| <span data-ttu-id="fbf4b-376">**Varsayılan sayfalama ASP.NET Izleme**</span><span class="sxs-lookup"><span data-stu-id="fbf4b-376">**Default Paging ASP.NET Trace**</span></span> | <span data-ttu-id="fbf4b-377">2.379</span><span class="sxs-lookup"><span data-stu-id="fbf4b-377">2.379</span></span> | <span data-ttu-id="fbf4b-378">*YOK*</span><span class="sxs-lookup"><span data-stu-id="fbf4b-378">*N/A*</span></span> |
| <span data-ttu-id="fbf4b-379">**Özel sayfalama ASP.NET Izleme**</span><span class="sxs-lookup"><span data-stu-id="fbf4b-379">**Custom Paging ASP.NET Trace**</span></span> | <span data-ttu-id="fbf4b-380">0.029</span><span class="sxs-lookup"><span data-stu-id="fbf4b-380">0.029</span></span> | <span data-ttu-id="fbf4b-381">*YOK*</span><span class="sxs-lookup"><span data-stu-id="fbf4b-381">*N/A*</span></span> |

<span data-ttu-id="fbf4b-382">Görebileceğiniz gibi, belirli bir veri sayfasını almak, ortalama olarak 354 daha az okuma ve tamamlanma süresinin bir kesilişinde tamamlanmakta olması gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-382">As you can see, retrieving a particular page of data required 354 less reads on average and completed in a fraction of the time.</span></span> <span data-ttu-id="fbf4b-383">ASP.NET sayfasında, özel sayfa, varsayılan sayfalama kullanılırken geçen<sup>sürenin 1/100 '</sup> a yakın sürede işleme sağlayamıştı.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-383">At the ASP.NET page, custom the page was able to render in close to 1/100<sup>th</sup> of the time it took when using default paging.</span></span> <span data-ttu-id="fbf4b-384">Bu testleri kendi ortamınızda yeniden oluşturmak için indirebileceğiniz kod ve veritabanıyla birlikte bu sonuçlarla ilgili daha fazla bilgi için [makaleme](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) bakın.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-384">See [my article](http://aspnet.4guysfromrolla.com/articles/031506-1.aspx) for more information on these results along with code and a database you can download to reproduce these tests in your own environment.</span></span>

## <a name="summary"></a><span data-ttu-id="fbf4b-385">Özet</span><span class="sxs-lookup"><span data-stu-id="fbf4b-385">Summary</span></span>

<span data-ttu-id="fbf4b-386">Varsayılan sayfalama, veri Web denetimi 'nin akıllı etiketinde yalnızca Sayfalamayı Etkinleştir onay kutusunu işaretleyin, ancak bu tür kolaylık da performans maliyetine girer.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-386">Default paging is a cinch to implement just check the Enable Paging checkbox in the data Web control s smart tag but such simplicity comes at the cost of performance.</span></span> <span data-ttu-id="fbf4b-387">Varsayılan sayfalama ile, bir Kullanıcı herhangi bir veri sayfası istediğinde, yalnızca küçük bir kesri gösterilse bile *Tüm* kayıtlar döndürülür.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-387">With default paging, when a user requests any page of data *all* records are returned, even though only a tiny fraction of them may be shown.</span></span> <span data-ttu-id="fbf4b-388">Bu performans yüküyle mücadele etmek için, ObjectDataSource alternatif bir sayfalama seçeneği özel sayfalama seçeneği sunar.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-388">To combat this performance overhead, the ObjectDataSource offers an alternative paging option custom paging.</span></span>

<span data-ttu-id="fbf4b-389">Özel sayfalama, yalnızca görüntülenmesi gereken kayıtları alarak varsayılan sayfalama performansı sorunları üzerinde gelişirken, özel sayfalama uygulamak daha da dahil olur.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-389">While custom paging improves upon default paging s performance issues by retrieving only those records that need to be displayed, it s more involved to implement custom paging.</span></span> <span data-ttu-id="fbf4b-390">İlk olarak, bir sorgu, istenen kayıt alt kümesine doğru şekilde (ve etkili bir şekilde) yazılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-390">First, a query must be written that correctly (and efficiently) accesses the specific subset of records requested.</span></span> <span data-ttu-id="fbf4b-391">Bu, çeşitli yollarla gerçekleştirilebilir; Bu öğreticide incelenen bir tane, sonuçları derecelendirmek için SQL Server 2005 s yeni `ROW_NUMBER()` işlevi kullanmak ve sonra yalnızca derecelendirmesi belirtilen bir aralık dahilinde olan sonuçları döndürmek için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-391">This can be accomplished in a number of ways; the one we examined in this tutorial is to use SQL Server 2005 s new `ROW_NUMBER()` function to rank results, and then to return just those results whose ranking falls within a specified range.</span></span> <span data-ttu-id="fbf4b-392">Ayrıca, üzerinden disk belleğine alınan toplam kayıt sayısını belirlemede bir yol eklememiz gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-392">Furthermore, we need to add a means to determine the total number of records being paged through.</span></span> <span data-ttu-id="fbf4b-393">Bu DAL ve BLL yöntemlerini oluşturduktan sonra Ayrıca, ObjectDataSource 'un kaç toplam kayıt sayfalanmakta olduğunu belirleyebilmesi ve başlangıç satırı dizinini ve en yüksek satır değerlerini BLL 'ye doğru bir şekilde geçebilmesini sağlayacak şekilde yapılandırmamız gerekir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-393">After creating these DAL and BLL methods, we also need to configure the ObjectDataSource so that it can determine how many total records are being paged through and can correctly pass the Start Row Index and Maximum Rows values to the BLL.</span></span>

<span data-ttu-id="fbf4b-394">Özel sayfalama uygulamak için birkaç adım gerekir ve varsayılan disk belleği olarak neredeyse basit değildir. özel sayfalama, yeterince büyük miktarda veri ile sayfalama yaparken bir zorunludur.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-394">While implementing custom paging does require a number of steps and is not nearly as simple as default paging, custom paging is a necessity when paging through sufficiently large amounts of data.</span></span> <span data-ttu-id="fbf4b-395">Sonuçlar incelendiği için, özel sayfalama, ASP.NET sayfa işleme süresinin sonuna kadar bir azalma olabilir ve veritabanı sunucusundaki yükü bir veya daha fazla büyüklük ile açabilir.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-395">As the results examined showed, custom paging can shed seconds off of the ASP.NET page render time and can lighten the load on the database server by one ore more orders of magnitude.</span></span>

<span data-ttu-id="fbf4b-396">Programlamanın kutlu olsun!</span><span class="sxs-lookup"><span data-stu-id="fbf4b-396">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="fbf4b-397">Yazar hakkında</span><span class="sxs-lookup"><span data-stu-id="fbf4b-397">About the Author</span></span>

<span data-ttu-id="fbf4b-398">4GuysFromRolla.com 'in, [Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), yedi ASP/ASP. net books ve [](http://www.4guysfromrolla.com)'in yazarı, 1998 sürümünden bu yana Microsoft Web teknolojileriyle çalışmaktadır.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-398">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="fbf4b-399">Scott bağımsız danışman, Trainer ve yazıcı olarak çalışıyor.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-399">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="fbf4b-400">En son kitabı, [*24 saat içinde ASP.NET 2,0 kendi kendinize eğitim*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco)ister.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-400">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="fbf4b-401">mitchell@4GuysFromRolla.comadresinden erişilebilir [.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="fbf4b-401">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="fbf4b-402">ya da blog aracılığıyla [http://ScottOnWriting.NET](http://ScottOnWriting.NET)bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="fbf4b-402">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="fbf4b-403">[Önceki](paging-and-sorting-report-data-cs.md)
> [İleri](sorting-custom-paged-data-cs.md)</span><span class="sxs-lookup"><span data-stu-id="fbf4b-403">[Previous](paging-and-sorting-report-data-cs.md)
[Next](sorting-custom-paged-data-cs.md)</span></span>
