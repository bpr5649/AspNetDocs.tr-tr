---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: SignalR'de Bağlantı ÖmrünüN Boyu Olayları Anlama ve İşleme | Microsoft Dokümanlar
author: bradygaster
description: Bu makalede, Hub'lar API tarafından maruz kalan olayların nasıl kullanılacağı açıklanmaktadır.
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/06/2020
ms.locfileid: "80676218"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="75889-103">SignalR’da Bağlantı Ömrü Olaylarını Anlama ve İşleme</span><span class="sxs-lookup"><span data-stu-id="75889-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="75889-104">Bu makalede, işleyebilir SinyalR bağlantısı, yeniden bağlantı ve kopukluk olayları ve zaman aşımı ve yapılandırabilirsiniz ayarları canlı tutmak genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="75889-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="75889-105">Makale zaten SignalR ve bağlantı yaşam olayları bazı bilgilere sahip varsayar.</span><span class="sxs-lookup"><span data-stu-id="75889-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="75889-106">SignalR'a giriş için [SignalR'a Giriş 'e](../getting-started/introduction-to-signalr.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="75889-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="75889-107">Bağlantı yaşam boyu olayları nın listeleri için aşağıdaki kaynaklara bakın:</span><span class="sxs-lookup"><span data-stu-id="75889-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="75889-108">Hub sınıfındaki bağlantı ömrü olayları nasıl işleyebilir?</span><span class="sxs-lookup"><span data-stu-id="75889-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="75889-109">JavaScript istemcilerinde bağlantı ömrü ndeki olayları nasıl işlersiniz?</span><span class="sxs-lookup"><span data-stu-id="75889-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="75889-110">.NET istemcilerinde bağlantı ömrü olayları nasıl işleyebilir?</span><span class="sxs-lookup"><span data-stu-id="75889-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="75889-111">Bu konuda kullanılan yazılım sürümleri</span><span class="sxs-lookup"><span data-stu-id="75889-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="75889-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="75889-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="75889-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="75889-113">.NET 4.5</span></span>
> - <span data-ttu-id="75889-114">SignalR sürüm 2</span><span class="sxs-lookup"><span data-stu-id="75889-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="75889-115">Bu konunun önceki sürümleri</span><span class="sxs-lookup"><span data-stu-id="75889-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="75889-116">SignalR'ın önceki sürümleri hakkında daha fazla bilgi için [SignalR Eski Sürümleri'ne](../older-versions/index.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="75889-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="75889-117">Sorular ve yorumlar</span><span class="sxs-lookup"><span data-stu-id="75889-117">Questions and comments</span></span>
>
> <span data-ttu-id="75889-118">Lütfen bu öğreticiyi nasıl beğendiğiniz ve sayfanın altındaki yorumlarda neler geliştirebileceğimiz hakkında geri bildirim de bırakın.</span><span class="sxs-lookup"><span data-stu-id="75889-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="75889-119">Öğreticiyle doğrudan ilgili olmayan sorularınız varsa, bunları ASP.NET [SignalR forumuna](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) veya [StackOverflow.com](http://stackoverflow.com/)gönderebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="75889-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="75889-120">Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="75889-120">Overview</span></span>

<span data-ttu-id="75889-121">Bu makalede aşağıdaki bölümler yer alıyor:</span><span class="sxs-lookup"><span data-stu-id="75889-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="75889-122">Bağlantı ömür boyu terminoloji ve senaryolar</span><span class="sxs-lookup"><span data-stu-id="75889-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="75889-123">SinyalR bağlantıları, aktarım bağlantıları ve fiziksel bağlantılar</span><span class="sxs-lookup"><span data-stu-id="75889-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="75889-124">Aktarım kopukluğu senaryoları</span><span class="sxs-lookup"><span data-stu-id="75889-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="75889-125">İstemci kopukluk senaryoları</span><span class="sxs-lookup"><span data-stu-id="75889-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="75889-126">Sunucu kopukluğu senaryoları</span><span class="sxs-lookup"><span data-stu-id="75889-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="75889-127">Zaman sonu ve canlı tutma ayarları</span><span class="sxs-lookup"><span data-stu-id="75889-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="75889-128">Connectiontimeout</span><span class="sxs-lookup"><span data-stu-id="75889-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="75889-129">Bağlantıyı KesmeTimeout</span><span class="sxs-lookup"><span data-stu-id="75889-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="75889-130">Keepalive</span><span class="sxs-lookup"><span data-stu-id="75889-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="75889-131">Zaman ayarı ve canlı ayarları tutma</span><span class="sxs-lookup"><span data-stu-id="75889-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="75889-132">Bağlantı kesilmeleri hakkında kullanıcıya nasıl bilgi verene</span><span class="sxs-lookup"><span data-stu-id="75889-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="75889-133">Sürekli olarak yeniden bağlanma</span><span class="sxs-lookup"><span data-stu-id="75889-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="75889-134">Sunucu kodundaki istemci nin bağlantısını kesme</span><span class="sxs-lookup"><span data-stu-id="75889-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="75889-135">Kopma nedenini algılama</span><span class="sxs-lookup"><span data-stu-id="75889-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="75889-136">API Başvuru konularına bağlantılar, API'nin .NET 4.5 sürümüne bağlantılardır.</span><span class="sxs-lookup"><span data-stu-id="75889-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="75889-137">.NET 4 kullanıyorsanız, [API konularının .NET 4 sürümüne](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx)bakın.</span><span class="sxs-lookup"><span data-stu-id="75889-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="75889-138">Bağlantı ömür boyu terminoloji ve senaryolar</span><span class="sxs-lookup"><span data-stu-id="75889-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="75889-139">SignalR Hub'daki `OnReconnected` olay işleyicisi, belirli bir istemci için doğrudan sonra `OnConnected` yürütebilir, ancak sonra `OnDisconnected` yürütülemez.</span><span class="sxs-lookup"><span data-stu-id="75889-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="75889-140">Bağlantı kopmadan yeniden bağlantı kuramanın nedeni, SignalR'da "bağlantı" sözcüğünün kullanıldığı çeşitli yollar olmasıdır.</span><span class="sxs-lookup"><span data-stu-id="75889-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="75889-141">SinyalR bağlantıları, aktarım bağlantıları ve fiziksel bağlantılar</span><span class="sxs-lookup"><span data-stu-id="75889-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="75889-142">Bu makalede *SinyalR bağlantıları,* *aktarım bağlantıları*ve *fiziksel bağlantılar*arasında ayrım yapılacaktır:</span><span class="sxs-lookup"><span data-stu-id="75889-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="75889-143">**SignalR bağlantısı,** SignalR API tarafından korunan ve bir bağlantı kimliğiyle benzersiz olarak tanımlanan bir istemci ve sunucu URL'si arasındaki mantıksal ilişkiyi ifade eder.</span><span class="sxs-lookup"><span data-stu-id="75889-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="75889-144">Bu ilişkiyle ilgili veriler SignalR tarafından korunur ve bir aktarım bağlantısı kurmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="75889-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="75889-145">İlişki sona erer ve SignalR, istemci `Stop` yöntemi aradığında veya SignalR kayıp bir aktarım bağlantısını yeniden kurmaya çalışırken bir zaman sonu sınırına ulaşıldığında verileri imha eder.</span><span class="sxs-lookup"><span data-stu-id="75889-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="75889-146">**Aktarım bağlantısı,** dört aktarım API'lerinden biri tarafından korunan istemci ve sunucu arasındaki mantıksal ilişkiyi ifade eder: WebSockets, sunucu tarafından gönderilen olaylar, sonsuza kadar çerçeve veya uzun yoklama.</span><span class="sxs-lookup"><span data-stu-id="75889-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="75889-147">SignalR, aktarım bağlantısı oluşturmak için aktarım API'sini kullanır ve aktarım API'si aktarım bağlantısını oluşturmak için fiziksel bir ağ bağlantısının varlığına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="75889-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="75889-148">Aktarım bağlantısı SignalR sonlandırdığinde veya aktarım API'sı fiziksel bağlantının koptuğunda sona erer.</span><span class="sxs-lookup"><span data-stu-id="75889-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="75889-149">**Fiziksel bağlantı,** istemci bilgisayar ile sunucu bilgisayarı arasındaki iletişimi kolaylaştıran fiziksel ağ bağlantılarını (kablolar, kablosuz sinyaller, yönlendiriciler, vb.) ifade eder.</span><span class="sxs-lookup"><span data-stu-id="75889-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="75889-150">Bir aktarım bağlantısı kurmak için fiziksel bağlantı nın bulunması ve SinyalR bağlantısı kurmak için bir aktarım bağlantısı nın kurulması gerekir.</span><span class="sxs-lookup"><span data-stu-id="75889-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="75889-151">Ancak, fiziksel bağlantıyı kırmak, bu konuda daha sonra açıklanacağı gibi, aktarım bağlantısını veya SignalR bağlantısını her zaman hemen sona erdirmez.</span><span class="sxs-lookup"><span data-stu-id="75889-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="75889-152">Aşağıdaki diyagramda, SignalR bağlantısı Hubs API ve PersistentConnection API SignalR katmanı tarafından temsil edilir, aktarım bağlantısı Aktarımlar katmanı tarafından temsil edilir ve fiziksel bağlantı sunucu ve istemciler arasındaki çizgilerle temsil edilir.</span><span class="sxs-lookup"><span data-stu-id="75889-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![SignalR mimari diyagramı](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="75889-154">Bir SignalR `Start` istemcisinde yöntemi aradiğinizde, bir sunucuya fiziksel bir bağlantı kurmak için gereken tüm bilgileri sinyalr istemci kodu sağlarsınız.</span><span class="sxs-lookup"><span data-stu-id="75889-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="75889-155">SignalR istemci kodu, bir HTTP isteği nde bulunmak ve dört aktarım yönteminden birini kullanan fiziksel bir bağlantı kurmak için bu bilgileri kullanır.</span><span class="sxs-lookup"><span data-stu-id="75889-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="75889-156">Aktarım bağlantısı başarısız olursa veya sunucu başarısız olursa, istemci aynı SignalR URL'sine otomatik olarak yeni bir aktarım bağlantısı kurmak için gereken bilgilere sahip olduğundan SignalR bağlantısı hemen silinmez.</span><span class="sxs-lookup"><span data-stu-id="75889-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="75889-157">Bu senaryoda, kullanıcı uygulamasından hiçbir müdahale söz konusu değildir ve SignalR istemci kodu yeni bir aktarım bağlantısı kurduğunda, yeni bir SinyalR bağlantısı başlatmaz.</span><span class="sxs-lookup"><span data-stu-id="75889-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="75889-158">SignalR bağlantısının sürekliliği, yöntemi aradığınızda oluşturulan bağlantı kimliğinin `Start` değişmediği gerçeğine yansıtılır.</span><span class="sxs-lookup"><span data-stu-id="75889-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="75889-159">Hub'daki `OnReconnected` olay işleyicisi, bir aktarım bağlantısı kaybolduktan sonra otomatik olarak yeniden kurulduğunda çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="75889-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="75889-160">Olay `OnDisconnected` işleyicisi bir SignalR bağlantısının sonunda yürütür.</span><span class="sxs-lookup"><span data-stu-id="75889-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="75889-161">SignalR bağlantısı aşağıdaki yollardan herhangi birinde sona erebilir:</span><span class="sxs-lookup"><span data-stu-id="75889-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="75889-162">İstemci `Stop` yöntemi çağırırsa, sunucuya bir durdurma iletisi gönderilir ve hem istemci hem de sunucu SignalR bağlantısını hemen sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="75889-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="75889-163">İstemci ve sunucu arasındaki bağlantı kaybolduktan sonra, istemci yeniden bağlanmaya çalışır ve sunucu istemcinin yeniden bağlanmasını bekler.</span><span class="sxs-lookup"><span data-stu-id="75889-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="75889-164">Yeniden bağlanma girişimleri başarısız olursa ve bağlantı kesme zaman sonu süresi sona ererse, hem istemci hem de sunucu SignalR bağlantısını sona erdirin.</span><span class="sxs-lookup"><span data-stu-id="75889-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="75889-165">İstemci yeniden bağlanmaya çalışmayı durdurur ve sunucu SignalR bağlantısının temsilini ortadan kaldırabilir.</span><span class="sxs-lookup"><span data-stu-id="75889-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="75889-166">İstemci `Stop` yöntemi arama şansı olmadan çalışmayı durdurursa, sunucu istemcinin yeniden bağlanmasını bekler ve devre son verme süresinin kesilmesinden sonra SinyalR bağlantısını sona erdirer.</span><span class="sxs-lookup"><span data-stu-id="75889-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="75889-167">Sunucu çalışmayı durdurursa, istemci yeniden bağlanmaya çalışır (aktarım bağlantısını yeniden oluşturur) ve ardından bağlantı kesme devresi bittikten sonra SinyalR bağlantısını sona erdirer.</span><span class="sxs-lookup"><span data-stu-id="75889-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="75889-168">Bağlantı sorunu olmadığında ve kullanıcı uygulaması `Stop` yöntemi çağırarak SignalR bağlantısını sona erdirdiğinde, SignalR bağlantısı ve aktarım bağlantısı yaklaşık aynı anda başlar ve biter.</span><span class="sxs-lookup"><span data-stu-id="75889-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="75889-169">Aşağıdaki bölümlerde diğer senaryolar daha ayrıntılı olarak açıklayınız.</span><span class="sxs-lookup"><span data-stu-id="75889-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="75889-170">Aktarım kopukluğu senaryoları</span><span class="sxs-lookup"><span data-stu-id="75889-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="75889-171">Fiziksel bağlantılar yavaş olabilir veya bağlantıda kesintiler olabilir.</span><span class="sxs-lookup"><span data-stu-id="75889-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="75889-172">Kesintinin uzunluğu gibi etkenlere bağlı olarak, aktarım bağlantısı kesilebilir.</span><span class="sxs-lookup"><span data-stu-id="75889-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="75889-173">SignalR daha sonra taşıma bağlantısını yeniden kurmaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="75889-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="75889-174">Bazen aktarım bağlantısı API kesintisi algılar ve aktarım bağlantısını düşürür ve SignalR bağlantının kaybolduğunu hemen öğrenir.</span><span class="sxs-lookup"><span data-stu-id="75889-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="75889-175">Diğer senaryolarda, ne aktarım bağlantısı API'si ne de SignalR bağlantının kaybolduğunu hemen fark etmez.</span><span class="sxs-lookup"><span data-stu-id="75889-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="75889-176">Uzun yoklama dışındaki tüm taşımalar için SignalR istemcisi, aktarım API'sinin algılayamadığı bağlantı kaybını kontrol etmek için *canlı tutma* adı verilen bir işlev kullanır.</span><span class="sxs-lookup"><span data-stu-id="75889-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="75889-177">Uzun yoklama bağlantıları hakkında daha fazla bilgi için, bu konunun ilerleyen saatlerinde [Zaman Ekine ve canlı ayarları na](#timeoutkeepalive) bakın.</span><span class="sxs-lookup"><span data-stu-id="75889-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="75889-178">Bir bağlantı etkin olmadığında, sunucu düzenli aralıklarla istemciye canlı bir paket gönderir.</span><span class="sxs-lookup"><span data-stu-id="75889-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="75889-179">Bu makalenin yazıldığı tarih itibariyle varsayılan sıklık her 10 saniyede bir olur.</span><span class="sxs-lookup"><span data-stu-id="75889-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="75889-180">Bu paketleri dinleyerek, istemciler bir bağlantı sorunu olup olmadığını anlayabilir.</span><span class="sxs-lookup"><span data-stu-id="75889-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="75889-181">Beklenen zamanda bir keepalive paketi alınmazsa, kısa bir süre sonra istemci yavaşlık veya kesinti gibi bağlantı sorunları olduğunu varsayar.</span><span class="sxs-lookup"><span data-stu-id="75889-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="75889-182">Canlı tutma daha uzun bir süre sonra hala alınmazsa, istemci bağlantının bırakıldığını varsayar ve yeniden bağlanmaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="75889-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="75889-183">Aşağıdaki diyagram, aktarım API'si tarafından hemen tanınmayan fiziksel bağlantıyla ilgili sorunlar olduğunda, tipik bir senaryoda ortaya çıkan istemci ve sunucu olaylarını göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="75889-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="75889-184">Diyagram aşağıdaki durumlar için geçerlidir:</span><span class="sxs-lookup"><span data-stu-id="75889-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="75889-185">Aktarım WebSockets, sonsuza kadar çerçeve veya sunucu tarafından gönderilen olaylardır.</span><span class="sxs-lookup"><span data-stu-id="75889-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="75889-186">Fiziksel ağ bağlantısında çeşitli kesinti dönemleri vardır.</span><span class="sxs-lookup"><span data-stu-id="75889-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="75889-187">Aktarım API'si kesintilerin farkına varmaz, bu nedenle SignalR bunları algılamak için canlı tutma işlevine güvenir.</span><span class="sxs-lookup"><span data-stu-id="75889-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Taşıma kopuklukları](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="75889-189">İstemci yeniden bağlanma moduna geçerse ancak bağlantı kesme zaman sınırı içinde bir aktarım bağlantısı kuramazsa, sunucu SignalR bağlantısını sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="75889-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="75889-190">Bu durumda, sunucu Hub'ın `OnDisconnected` yöntemini yürütür ve istemcinin daha sonra bağlanmayı başarması durumunda istemciye göndermek üzere bir bağlantı kesme iletisi sıraya alır.</span><span class="sxs-lookup"><span data-stu-id="75889-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="75889-191">İstemci daha sonra yeniden bağlanırsa, bağlantı `Stop` kesme komutunu alır ve yöntemi çağırır.</span><span class="sxs-lookup"><span data-stu-id="75889-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="75889-192">Bu senaryoda, `OnReconnected` istemci yeniden bağlandığında yürütülmez ve `OnDisconnected` istemci aradığında `Stop`yürütülmez.</span><span class="sxs-lookup"><span data-stu-id="75889-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="75889-193">Aşağıdaki diyagram bu senaryoyu göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="75889-193">The following diagram illustrates this scenario.</span></span>

![Aktarım kesintileri - sunucu zaman ayarı](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="75889-195">İstemci üzerinde gündeme getirilebilecek SignalR bağlantı yaşam boyu olaylar şunlardır:</span><span class="sxs-lookup"><span data-stu-id="75889-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="75889-196">`ConnectionSlow`istemci olay.</span><span class="sxs-lookup"><span data-stu-id="75889-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="75889-197">Son iletiden bu yana canlı tutma süresinin önceden ayarlanmış bir oranı geçtiğinde veya ping'i canlı tuttuğunda yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="75889-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="75889-198">Varsayılan tutma zaman dışarısı uyarı süresi, keepalive zaman anının 2/3'üdür.</span><span class="sxs-lookup"><span data-stu-id="75889-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="75889-199">Keepalive zaman dilimi 20 saniyedir, bu nedenle uyarı yaklaşık 13 saniye de gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="75889-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="75889-200">Varsayılan olarak, sunucu her 10 saniyede bir canlı ping gönderir ve istemci her 2 saniyede bir ping'i canlı tutmayı denetler (hayatta kalma zaman ayırma değeri ile keepalive zaman ayırma uyarı değeri arasındaki farkın üçte biri).</span><span class="sxs-lookup"><span data-stu-id="75889-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="75889-201">Aktarım API'si bir kopukluk tanhaberdar olursa, signalr sürekli zaman zaman dilimi uyarı süresi geçmeden önce kopukluk hakkında bilgilendirilebilir.</span><span class="sxs-lookup"><span data-stu-id="75889-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="75889-202">Bu durumda, `ConnectionSlow` olay yükseltilmiş olmaz ve SignalR `Reconnecting` doğrudan olay gider.</span><span class="sxs-lookup"><span data-stu-id="75889-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="75889-203">`Reconnecting`istemci olay.</span><span class="sxs-lookup"><span data-stu-id="75889-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="75889-204">(a) aktarım API'sı bağlantının kaybolduğunu algıladığında veya (b) son iletiden veya keepalive ping'den bu yana geçen zaman diliminde yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="75889-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="75889-205">SignalR istemci kodu yeniden bağlanmaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="75889-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="75889-206">Bir aktarım bağlantısı kaybolduğunda uygulamanızın bazı eylemlerde bulunmasını istiyorsanız, bu olayı işleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="75889-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="75889-207">Varsayılan tutma zaman dışarı sı şu anda 20 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="75889-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="75889-208">İstemciniz kodunuz SignalR yeniden bağlanma modundayken Hub yöntemini çağırmaya çalışırsa, SignalR komutu göndermeye çalışır.</span><span class="sxs-lookup"><span data-stu-id="75889-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="75889-209">Çoğu zaman, bu tür girişimler başarısız olur, ancak bazı durumlarda başarılı olabilir.</span><span class="sxs-lookup"><span data-stu-id="75889-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="75889-210">Sunucu tarafından gönderilen olaylar, sonsuza kadar çerçeve ve uzun yoklama aktarımları için SignalR, istemcinin ileti göndermek için kullandığı ve ileti almak için kullandığı iki iletişim kanalı kullanır.</span><span class="sxs-lookup"><span data-stu-id="75889-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="75889-211">Almak için kullanılan kanal kalıcı olarak açık olandır ve fiziksel bağlantı kesildiğinde kapalı olan kanaldır.</span><span class="sxs-lookup"><span data-stu-id="75889-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="75889-212">Göndermek için kullanılan kanal kullanılabilir durumda kalır, bu nedenle fiziksel bağlantı geri yüklenirse, istemciden sunucuya bir yöntem çağrısı, alma kanalı yeniden kurulmadan önce başarılı olabilir.</span><span class="sxs-lookup"><span data-stu-id="75889-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="75889-213">SignalR almak için kullanılan kanalı yeniden açana kadar iade değeri alınmaz.</span><span class="sxs-lookup"><span data-stu-id="75889-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="75889-214">`Reconnected`istemci olay.</span><span class="sxs-lookup"><span data-stu-id="75889-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="75889-215">Aktarım bağlantısı yeniden kurulduğunda yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="75889-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="75889-216">Hub'daki `OnReconnected` olay işleyicisi yürütülür.</span><span class="sxs-lookup"><span data-stu-id="75889-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="75889-217">`Closed`istemci olayı`disconnected` (JavaScript'teki olay).</span><span class="sxs-lookup"><span data-stu-id="75889-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="75889-218">SignalR istemci kodu aktarım bağlantısını kaybettikten sonra yeniden bağlanmaya çalışırken bağlantı kesme süresi sona erdiğinde yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="75889-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="75889-219">Varsayılan kesme süresi 30 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="75889-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="75889-220">(Bu olay, `Stop` yöntem çağrıldığında bağlantı sona erdiğinde de yükselir.)</span><span class="sxs-lookup"><span data-stu-id="75889-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="75889-221">Aktarım API'si tarafından algılanmayan ve sunucudan canlı tutma pinglerinin alımını, canlı tutma zaman aşımı uyarı süresinden daha uzun süre geciktirmeyen aktarım bağlantısı kesintileri, bağlantı ömrü boyunca herhangi bir olayın yükseltilmesine neden olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="75889-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="75889-222">Bazı ağ ortamları boşta kalan bağlantıları kasıtlı olarak kapatır ve keepalive paketlerinin bir diğer işlevi de bu ağlara SignalR bağlantısının kullanıldığını bildirerek bunu önlemeye yardımcı olmaktır.</span><span class="sxs-lookup"><span data-stu-id="75889-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="75889-223">Ekstrem durumlarda ping'leri canlı tutmanın varsayılan sıklığı kapalı bağlantıları önlemek için yeterli olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="75889-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="75889-224">Bu durumda, keepalive ping'leri daha sık gönderilecek şekilde yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="75889-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="75889-225">Daha fazla bilgi için, bu konuda daha sonra [Timeout ve keepalive ayarları](#timeoutkeepalive) bakın.</span><span class="sxs-lookup"><span data-stu-id="75889-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="75889-226">**Önemli**: Burada açıklanan olayların sırası garanti edilmez.</span><span class="sxs-lookup"><span data-stu-id="75889-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="75889-227">SignalR, bağlantı ömrü ndeki olayları bu şemaya göre öngörülebilir bir şekilde yükseltmek için her türlü girişimi yapar, ancak ağ olaylarının birçok varyasyonu ve taşıma API'leri gibi temel iletişim çerçevelerinin bunları ele aldığı birçok yöntem vardır.</span><span class="sxs-lookup"><span data-stu-id="75889-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="75889-228">Örneğin, istemci `Reconnected` yeniden bağlandığında olay yükseltilmeyebilir veya `OnConnected` bağlantı kurma girişimi başarısız olduğunda sunucudaki işleyici çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="75889-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="75889-229">Bu konu, yalnızca normalde belirli tipik koşullar tarafından üretilecek etkileri açıklar.</span><span class="sxs-lookup"><span data-stu-id="75889-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="75889-230">İstemci kopukluk senaryoları</span><span class="sxs-lookup"><span data-stu-id="75889-230">Client disconnection scenarios</span></span>

<span data-ttu-id="75889-231">Tarayıcı istemcisinde, SignalR bağlantısını koruyan SignalR istemci kodu, bir web sayfasının JavaScript bağlamında çalışır.</span><span class="sxs-lookup"><span data-stu-id="75889-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="75889-232">Bu nedenle, bir sayfadan diğerine gezinirken SignalR bağlantısının sona ermesi gerekir ve bu nedenle birden çok tarayıcı penceresinden veya sekmeden bağlanırsanız birden çok bağlantı bağlantısına sahip birden fazla bağlantınız vardır.</span><span class="sxs-lookup"><span data-stu-id="75889-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="75889-233">Kullanıcı bir tarayıcı penceresini veya sekmesini kapattığında veya yeni bir sayfaya gittiğinde veya sayfayı yenilediğinde, SignalR istemci kodu `Stop` bu tarayıcı olayını sizin için işlediği ve yöntemi aradığı için SignalR bağlantısı hemen sona erer.</span><span class="sxs-lookup"><span data-stu-id="75889-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="75889-234">Bu senaryolarda veya `Stop` uygulamanız yöntemi aradığında herhangi bir `OnDisconnected` istemci platformunda, olay işleyicisi `Closed` sunucuda hemen yürütür ve istemci olayı yükseltir (olay JavaScript'te adlandırılır). `disconnected`</span><span class="sxs-lookup"><span data-stu-id="75889-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="75889-235">Bir istemci uygulaması veya çalışan bilgisayar kilitlenirse veya uyku moduna geçerse (örneğin, kullanıcı dizüstü bilgisayarı kapattığında), sunucuya ne olduğu hakkında bilgi vermez.</span><span class="sxs-lookup"><span data-stu-id="75889-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="75889-236">Sunucunun bildiği kadarıyla, istemcinin kaybı bağlantı kesintisinden kaynaklanıyor olabilir ve istemci yeniden bağlanmaya çalışıyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="75889-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="75889-237">Bu nedenle, bu senaryolarda sunucu istemciye yeniden bağlanma şansı `OnDisconnected` vermek için bekler ve bağlantı kesme süresi dolana kadar (varsayılan olarak yaklaşık 30 saniye) yürütmez.</span><span class="sxs-lookup"><span data-stu-id="75889-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="75889-238">Aşağıdaki diyagram bu senaryoyu göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="75889-238">The following diagram illustrates this scenario.</span></span>

![İstemci bilgisayar hatası](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="75889-240">Sunucu kopukluğu senaryoları</span><span class="sxs-lookup"><span data-stu-id="75889-240">Server disconnection scenarios</span></span>

<span data-ttu-id="75889-241">Bir sunucu çevrimdışı olduğunda -yeniden başlatıldığında, başarısız oluyor, uygulama etki alanı geri dönüşümleri, vb.) sonuç kayıp bir bağlantıya benzer olabilir veya aktarım API'si ve `ConnectionSlow` SignalR sunucunun gittiğini hemen anlayabilir ve SignalR olayı yükseltmeden yeniden bağlanmaya çalışabilir.</span><span class="sxs-lookup"><span data-stu-id="75889-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="75889-242">İstemci yeniden bağlanma moduna geçerse ve sunucu iyileşirse veya yeniden başlatılırsa veya bağlantı kesme süresi dolmadan önce yeni bir sunucu çevrimiçi duruma getirilirse, istemci geri yüklenen veya yeni sunucuya yeniden bağlanır.</span><span class="sxs-lookup"><span data-stu-id="75889-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="75889-243">Bu durumda, Sinyalr bağlantısı istemci üzerinde `Reconnected` devam ediyor ve olay yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="75889-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="75889-244">İlk sunucuda, `OnDisconnected` yürütülmez ve yeni sunucuda, `OnReconnected` `OnConnected` daha önce bu istemci için yürütülmemiş olmasına rağmen yürütülür.</span><span class="sxs-lookup"><span data-stu-id="75889-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="75889-245">(Sunucu önceki bağlantı etkinliği hiçbir bellek olduğu için, istemci yeniden başlatma veya uygulama etki alanı geri dönüşümsonra aynı sunucuya yeniden bağlanır, çünkü etkisi aynıdır.) Aşağıdaki diyagram, aktarım API'sinin kayıp bağlantının hemen `ConnectionSlow` farkına vardığını, bu nedenle olayın yükseltilmediğini varsayar.</span><span class="sxs-lookup"><span data-stu-id="75889-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Sunucu hatası ve yeniden bağlantı](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="75889-247">Bir sunucu bağlantı kesme süresi içinde kullanılamıyorsa, SignalR bağlantısı sona erer.</span><span class="sxs-lookup"><span data-stu-id="75889-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="75889-248">Bu senaryoda, `Closed` olay`disconnected` (JavaScript istemcilerinde) istemcide `OnDisconnected` yükseltilir, ancak sunucuda asla çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="75889-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="75889-249">Aşağıdaki diyagram, aktarım API'sinin kayıp bağlantıdan haberdar olmadığını varsayar, bu nedenle SignalR tarafından algılanır ve `ConnectionSlow` olay yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="75889-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Sunucu hatası ve zaman arızası](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="75889-251">Zaman sonu ve canlı tutma ayarları</span><span class="sxs-lookup"><span data-stu-id="75889-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="75889-252">Varsayılan `ConnectionTimeout`, `DisconnectTimeout`ve `KeepAlive` değerler çoğu senaryo için uygundur, ancak ortamınızın özel gereksinimleri varsa değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="75889-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="75889-253">Örneğin, ağ ortamınız boşta kalan bağlantıları 5 saniye liğine kapatıyorsa, canlı kalma değerini azaltmanız gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="75889-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="75889-254">Connectiontimeout</span><span class="sxs-lookup"><span data-stu-id="75889-254">ConnectionTimeout</span></span>

<span data-ttu-id="75889-255">Bu ayar, aktarım bağlantısını açık bırakma ve kapatmadan ve yeni bir bağlantı açmadan önce yanıt bekleme süresini gösterir.</span><span class="sxs-lookup"><span data-stu-id="75889-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="75889-256">Varsayılan değer 110 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="75889-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="75889-257">Bu ayar yalnızca keepalive işlevselliği devre dışı bırakıldığında geçerlidir ve normalde yalnızca uzun yoklama aktarımları için geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="75889-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="75889-258">Aşağıdaki diyagram, bu ayarın uzun bir yoklama aktarım bağlantısı üzerindeki etkisini göstermektedir.</span><span class="sxs-lookup"><span data-stu-id="75889-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Uzun yoklama taşıma bağlantısı](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="75889-260">Bağlantıyı KesmeTimeout</span><span class="sxs-lookup"><span data-stu-id="75889-260">DisconnectTimeout</span></span>

<span data-ttu-id="75889-261">Bu ayar, `Disconnected` olayı yükseltmeden önce aktarım bağlantısı kaybolduktan sonra bekleme süresini gösterir.</span><span class="sxs-lookup"><span data-stu-id="75889-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="75889-262">Varsayılan değer 30 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="75889-262">The default value is 30 seconds.</span></span> <span data-ttu-id="75889-263">Ayarladığınızda, `DisconnectTimeout` `KeepAlive` otomatik olarak değerin 1/3'ü `DisconnectTimeout` olarak ayarlanır.</span><span class="sxs-lookup"><span data-stu-id="75889-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="75889-264">Keepalive</span><span class="sxs-lookup"><span data-stu-id="75889-264">KeepAlive</span></span>

<span data-ttu-id="75889-265">Bu ayar, boşta kalan bir paketten boşta kalma dan önce bekleme süresini gösterir.</span><span class="sxs-lookup"><span data-stu-id="75889-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="75889-266">Varsayılan değer 10 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="75889-266">The default value is 10 seconds.</span></span> <span data-ttu-id="75889-267">Bu değer, değerin `DisconnectTimeout` 1/3'ünden fazla olmamalıdır.</span><span class="sxs-lookup"><span data-stu-id="75889-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="75889-268">Her ikisini `DisconnectTimeout` de ayarlamak `KeepAlive`istiyorsanız `KeepAlive` `DisconnectTimeout`ve sonra ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="75889-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="75889-269">Aksi `KeepAlive` takdirde, zaman ödeme `DisconnectTimeout` değerinin `KeepAlive` 1/3'ü otomatik olarak ayarlandığında ayarınız üzerine yazılır.</span><span class="sxs-lookup"><span data-stu-id="75889-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="75889-270">Keepalive işlevini devre dışı atmak istiyorsanız, null `KeepAlive` ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="75889-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="75889-271">Keepalive işlevi, uzun yoklama taşıması için otomatik olarak devre dışı bırakılır.</span><span class="sxs-lookup"><span data-stu-id="75889-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="75889-272">Zaman ayarı ve canlı ayarları tutma</span><span class="sxs-lookup"><span data-stu-id="75889-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="75889-273">Bu ayarların varsayılan değerlerini değiştirmek için, aşağıdaki örnekte gösterildiği gibi `Application_Start` *Global.asax* dosyanızda ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="75889-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="75889-274">Örnek kodda gösterilen değerler varsayılan değerlerle aynıdır.</span><span class="sxs-lookup"><span data-stu-id="75889-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="75889-275">Bağlantı kesilmeleri hakkında kullanıcıya nasıl bilgi verene</span><span class="sxs-lookup"><span data-stu-id="75889-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="75889-276">Bazı uygulamalarda bağlantı sorunları olduğunda kullanıcıya bir ileti görüntülemek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="75889-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="75889-277">Bunu nasıl ve ne zaman yapacağınız için çeşitli seçenekleriniz var.</span><span class="sxs-lookup"><span data-stu-id="75889-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="75889-278">Aşağıdaki kod örnekleri, oluşturulan proxy'yi kullanan bir JavaScript istemcisi içindir.</span><span class="sxs-lookup"><span data-stu-id="75889-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="75889-279">SignalR `connectionSlow` bağlantı sorunlarının farkına varır varmaz, yeniden bağlanma moduna geçmeden önce bir iletiyi görüntülemek için olayı işleyin.</span><span class="sxs-lookup"><span data-stu-id="75889-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="75889-280">SignalR `reconnecting` bir bağlantının kopukluğu ndan haberdar olduğunda ve yeniden bağlanma moduna geçtiğinde, olayı bir iletiyi görüntülemek için işleyin.</span><span class="sxs-lookup"><span data-stu-id="75889-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="75889-281">Yeniden `disconnected` bağlanma denemesi zaman dolduğunda bir ileti görüntülemek için olayı işleyebilir. Bu senaryoda, sunucuyla yeniden bağlantı kurmanın tek yolu, yeni bir bağlantı kimliği `Start` oluşturacak yöntemi arayarak SignalR bağlantısını yeniden başlatmaktır.</span><span class="sxs-lookup"><span data-stu-id="75889-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="75889-282">Aşağıdaki kod örneği, `Stop` bildirimi yalnızca yeniden bağlanma zaman anından sonra düzenlediğinden emin olmak için bir bayrak kullanır, yöntemi çağırmanın neden olduğu SignalR bağlantısının normal bir sonundan sonra değil.</span><span class="sxs-lookup"><span data-stu-id="75889-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="75889-283">Sürekli olarak yeniden bağlanma</span><span class="sxs-lookup"><span data-stu-id="75889-283">How to continuously reconnect</span></span>

<span data-ttu-id="75889-284">Bazı uygulamalarda, bağlantı kaybolduktan ve yeniden bağlanma denemesi zaman dolduktan sonra otomatik olarak yeniden bağlantı kurmak isteyebilirsiniz. Bunu yapmak `Start` için, yöntemi olay `Closed` işleyicinizden`disconnected` (JavaScript istemcilerinde olay işleyicisi) arayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="75889-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="75889-285">Sunucu veya fiziksel bağlantı kullanılamadığında `Start` bunu çok sık yapmamak için aramadan önce bir süre beklemek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="75889-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="75889-286">Aşağıdaki kod örneği, oluşturulan proxy'yi kullanan bir JavaScript istemcisi içindir.</span><span class="sxs-lookup"><span data-stu-id="75889-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="75889-287">Mobil istemcilerde dikkat edilmesi gereken olası bir sorun, sunucu veya fiziksel bağlantı kullanılamadığında sürekli yeniden bağlantı denemelerinin gereksiz pil indene neden olabilmesidir.</span><span class="sxs-lookup"><span data-stu-id="75889-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="75889-288">Sunucu kodundaki istemci nin bağlantısını kesme</span><span class="sxs-lookup"><span data-stu-id="75889-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="75889-289">SignalR sürüm 2 istemcileri kesmek için yerleşik bir sunucu API'si yok.</span><span class="sxs-lookup"><span data-stu-id="75889-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="75889-290">Gelecekte [bu işlevselliği eklemek için planlar](https://github.com/SignalR/SignalR/issues/2101)vardır.</span><span class="sxs-lookup"><span data-stu-id="75889-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="75889-291">Geçerli SignalR sürümünde, istemcinin sunucudan bağlantısını kesmenin en basit yolu istemciye bir bağlantı kesme yöntemi uygulamak ve bu yöntemi sunucudan aramaktır.</span><span class="sxs-lookup"><span data-stu-id="75889-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="75889-292">Aşağıdaki kod örneği, oluşturulan proxy'yi kullanarak bir JavaScript istemcisi için bir bağlantı kesme yöntemini gösterir.</span><span class="sxs-lookup"><span data-stu-id="75889-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="75889-293">Güvenlik - İstemciler yeniden bağlanabildiği veya ele geçirilen kod `stopClient` yöntemi kaldırabileceğinden veya ne yaptığını değiştirebildiği için, istemcilerin bağlantısını kesmek için ne de önerilen yerleşik API, kötü amaçlı kod çalıştıran istemcilerin senaryosunu ele almaz.</span><span class="sxs-lookup"><span data-stu-id="75889-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="75889-294">Devlet hizmeti reddi (DOS) koruması uygulamak için uygun yer çerçeve veya sunucu katmanı değil, ön uç altyapısıdır.</span><span class="sxs-lookup"><span data-stu-id="75889-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="75889-295">Kopma nedenini algılama</span><span class="sxs-lookup"><span data-stu-id="75889-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="75889-296">SignalR 2.1, sunucu `OnDisconnect` olayına, istemcinin zamanlama yerine kasıtlı olarak bağlantının kesilip kesilmediğini gösteren aşırı yük ekler. İstemci `StopCalled` bağlantıyı açıkça kapattıysa parametre doğrudur.</span><span class="sxs-lookup"><span data-stu-id="75889-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="75889-297">JavaScript'te, bir sunucu hatası istemcinin bağlantısını kesmeye neden olduysa, hata bilgileri istemciye `$.connection.hub.lastError`.</span><span class="sxs-lookup"><span data-stu-id="75889-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="75889-298">**C# sunucu `stopCalled` kodu: parametre**</span><span class="sxs-lookup"><span data-stu-id="75889-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="75889-299">**JavaScript istemci kodu: `lastError` `disconnect` olay erişim.**</span><span class="sxs-lookup"><span data-stu-id="75889-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
