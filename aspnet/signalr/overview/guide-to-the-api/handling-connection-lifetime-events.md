---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: Signalr'da bağlantı ömrü olaylarını işleme ve anlama | Microsoft Docs
author: bradygaster
description: Bu makalede, hub'ları API'si tarafından kullanıma sunulan olayları kullanmayı açıklar.
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 9e6b0b3b86839efa393659531d8b74770226f383
ms.sourcegitcommit: 0f1119340e4464720cfd16d0ff15764746ea1fea
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/09/2019
ms.locfileid: "59401471"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="b55c7-103">SignalR’da Bağlantı Ömrü Olaylarını Anlama ve İşleme</span><span class="sxs-lookup"><span data-stu-id="b55c7-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>


[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="b55c7-104">Bu makalede başa çıkabilir SignalR bağlantı yeniden bağlanma ve bağlantıyı kesme olaylarını ve yapılandırabileceğiniz zaman aşımı ve keepalive ayarları genel bir bakış sağlar.</span><span class="sxs-lookup"><span data-stu-id="b55c7-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="b55c7-105">SignalR ve bağlantı ömrü olaylarını biraz bilgi zaten sahip olduğunuz varsayılır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="b55c7-106">Signalr'a giriş için bkz [signalr'a giriş](../getting-started/introduction-to-signalr.md).</span><span class="sxs-lookup"><span data-stu-id="b55c7-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="b55c7-107">Bağlantı ömrü olaylarını bir listesi için aşağıdaki kaynaklara bakın:</span><span class="sxs-lookup"><span data-stu-id="b55c7-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="b55c7-108">Hub sınıfında bağlantı ömrü olaylarını işlemek nasıl</span><span class="sxs-lookup"><span data-stu-id="b55c7-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="b55c7-109">JavaScript istemcilerinin bağlantı ömrü olaylarını işlemek nasıl</span><span class="sxs-lookup"><span data-stu-id="b55c7-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="b55c7-110">.NET istemcileri bağlantı ömrü olaylarını işlemek nasıl</span><span class="sxs-lookup"><span data-stu-id="b55c7-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="b55c7-111">Bu konu başlığında kullanılan yazılım sürümleri</span><span class="sxs-lookup"><span data-stu-id="b55c7-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="b55c7-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="b55c7-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="b55c7-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="b55c7-113">.NET 4.5</span></span>
> - <span data-ttu-id="b55c7-114">SignalR sürüm 2</span><span class="sxs-lookup"><span data-stu-id="b55c7-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="b55c7-115">Bu konunun önceki sürümleri</span><span class="sxs-lookup"><span data-stu-id="b55c7-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="b55c7-116">SignalR eski sürümleri hakkında daha fazla bilgi için bkz: [SignalR eski sürümleri](../older-versions/index.md).</span><span class="sxs-lookup"><span data-stu-id="b55c7-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="b55c7-117">Sorularınız ve yorumlarınız</span><span class="sxs-lookup"><span data-stu-id="b55c7-117">Questions and comments</span></span>
>
> <span data-ttu-id="b55c7-118">Lütfen bu öğreticide sevmediğinizi nasıl ve ne sayfanın alt kısmındaki açıklamalarda geliştirebileceğimiz hakkında geri bildirim bırakın.</span><span class="sxs-lookup"><span data-stu-id="b55c7-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="b55c7-119">Öğretici için doğrudan ilgili olmayan sorularınız varsa, bunları gönderebilir [ASP.NET SignalR Forumu](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) veya [StackOverflow.com](http://stackoverflow.com/).</span><span class="sxs-lookup"><span data-stu-id="b55c7-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="b55c7-120">Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="b55c7-120">Overview</span></span>

<span data-ttu-id="b55c7-121">Bu makalede, aşağıdaki bölümleri içerir:</span><span class="sxs-lookup"><span data-stu-id="b55c7-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="b55c7-122">Bağlantı ömrü terminoloji ve senaryolar</span><span class="sxs-lookup"><span data-stu-id="b55c7-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="b55c7-123">SignalR bağlantıları, aktarım bağlantılarının ve fiziksel bağlantıları</span><span class="sxs-lookup"><span data-stu-id="b55c7-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="b55c7-124">Taşıma bağlantısı kesme senaryoları</span><span class="sxs-lookup"><span data-stu-id="b55c7-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="b55c7-125">İstemci bağlantı kesilmesi senaryoları</span><span class="sxs-lookup"><span data-stu-id="b55c7-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="b55c7-126">Sunucu bağlantı kesilmesi senaryoları</span><span class="sxs-lookup"><span data-stu-id="b55c7-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="b55c7-127">Zaman aşımı ve keepalive ayarları</span><span class="sxs-lookup"><span data-stu-id="b55c7-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="b55c7-128">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="b55c7-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="b55c7-129">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="b55c7-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="b55c7-130">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="b55c7-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="b55c7-131">Zaman aşımı ve keepalive ayarlarını değiştirme</span><span class="sxs-lookup"><span data-stu-id="b55c7-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="b55c7-132">Kullanıcı bağlantı kesilmesi hakkında bilgilendirme</span><span class="sxs-lookup"><span data-stu-id="b55c7-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="b55c7-133">Sürekli olarak yeniden bağlama</span><span class="sxs-lookup"><span data-stu-id="b55c7-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="b55c7-134">Bir istemci sunucu kodunda kesme hakkında</span><span class="sxs-lookup"><span data-stu-id="b55c7-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="b55c7-135">Bağlantı kesilmesi nedeni algılama</span><span class="sxs-lookup"><span data-stu-id="b55c7-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="b55c7-136">API başvuru konularına bağlar API .NET 4.5 sürümü var.</span><span class="sxs-lookup"><span data-stu-id="b55c7-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="b55c7-137">.NET 4 kullanıyorsanız, bkz. [API konuları .NET 4 sürümünü](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span><span class="sxs-lookup"><span data-stu-id="b55c7-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="b55c7-138">Bağlantı ömrü terminoloji ve senaryolar</span><span class="sxs-lookup"><span data-stu-id="b55c7-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="b55c7-139">`OnReconnected` Olay işleyicisinde bir SignalR hub'ı hemen sonra yürütebilir `OnConnected` ancak sonra değil `OnDisconnected` belirli bir istemci için.</span><span class="sxs-lookup"><span data-stu-id="b55c7-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="b55c7-140">Bir yeniden olmadan bağlantı kesilmesi olabilir "bağlantısı" sözcüğü SignalR öğesinde kullanılan çeşitli yolları vardır nedenidir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="b55c7-141">SignalR bağlantıları, aktarım bağlantılarının ve fiziksel bağlantıları</span><span class="sxs-lookup"><span data-stu-id="b55c7-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="b55c7-142">Bu makalede birbirinden ayırt *SignalR bağlantıları*, *taşıma bağlantıları*, ve *fiziksel bağlantıları*:</span><span class="sxs-lookup"><span data-stu-id="b55c7-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="b55c7-143">**SignalR bağlantı** bir istemci ve sunucu URL'si, SignalR API'sı tarafından bakımı yapılan ve benzersiz bir bağlantı kimliği tarafından tanımlanan arasında mantıksal bir ilişki başvurur</span><span class="sxs-lookup"><span data-stu-id="b55c7-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="b55c7-144">Bu ilişki hakkındaki verileri SignalR tarafından korunur ve aktarım bağlantı kurmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="b55c7-145">İlişki sona erer ve SignalR istemci çağırdığında verilerini siler `Stop` yöntemi ve bir zaman aşımı sınırı SignalR kayıp taşıma bağlantısını yeniden kurmaya çalışıyor durumdayken ulaşıldığında.</span><span class="sxs-lookup"><span data-stu-id="b55c7-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="b55c7-146">**Aktarım bağlantı** dört aktarım API'lerini biri tarafından korunan bir sunucu ile istemci arasındaki mantıksal ilişkisi ifade eder: WebSockets, sunucu tarafından gönderilen olayları, sonsuza kadar çerçeve veya uzun yoklama.</span><span class="sxs-lookup"><span data-stu-id="b55c7-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="b55c7-147">Aktarım bağlantısı oluşturmak için API taşıma SignalR kullanır ve aktarım API Aktarım bağlantısı oluşturmak için bir fiziksel ağ bağlantısı varlığı üzerinde bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="b55c7-148">SignalR sonlandığında veya taşıma API'si fiziksel bağlantının bozuk olduğunu algıladığında taşıma bağlantısını sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="b55c7-149">**Fiziksel bağlantı** --kablo, fiziksel ağ bağlantıları kablosuz sinyalleri, yönlendiriciler, bir istemci bilgisayarı ile sunucu bilgisayarı arasındaki iletişimi kolaylaştırır vb.--başvuruyor.</span><span class="sxs-lookup"><span data-stu-id="b55c7-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="b55c7-150">Fiziksel bağlantı Aktarım bağlantısı kurabilmek için mevcut olması gerekir ve bir SignalR bağlantısı kurabilmek için taşıma bağlantı kurulması gerekir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="b55c7-151">Bu konunun ilerleyen kısımlarında açıklandığı gibi ancak fiziksel bağlantı kesme her zaman hemen taşıma veya SignalR bağlantısı sonlanmıyor.</span><span class="sxs-lookup"><span data-stu-id="b55c7-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="b55c7-152">Aşağıdaki diyagramda, SignalR bağlantı hub'ları API ve PersistentConnection API SignalR katmanı tarafından temsil edilen, Aktarım bağlantısı taşımalar katmanı tarafından temsil edilir ve fiziksel bağlantı sunucusu arasındaki çizgilerle gösterilir ve istemciler.</span><span class="sxs-lookup"><span data-stu-id="b55c7-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![SignalR mimarisi diyagramı](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="b55c7-154">Çağırdığınızda `Start` SignalR istemci yönteminde, sağlamaya SignalR istemci kodu fiziksel bir sunucuya bağlantı kurmak için gereken tüm bilgileri.</span><span class="sxs-lookup"><span data-stu-id="b55c7-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="b55c7-155">SignalR istemci kodu, bir HTTP istek ve dört aktarım yöntemi kullanan fiziksel bir ağ bağlantısı kurmak için bu bilgileri kullanır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="b55c7-156">İstemci, otomatik olarak yeni bir aktarım bağlantısı aynı SignalR URL'ye yeniden oluşturmak için gereken bilgileri yine de sahip olduğu Aktarım bağlantısı başarısız veya sunucu başarısız olursa, SignalR bağlantı hemen hemen gideceği anlamına gelmez.</span><span class="sxs-lookup"><span data-stu-id="b55c7-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="b55c7-157">Bu senaryoda, kullanıcı uygulamadaki herhangi bir müdahalesi söz konusu ve SignalR istemci kodu yeni bir aktarım bağlantı kurduğunda, yeni bir SignalR bağlantısı başlamaz.</span><span class="sxs-lookup"><span data-stu-id="b55c7-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="b55c7-158">Sürekliliği SignalR bağlantısının bulgusunda yansıtılır, çağırdığınızda oluşturulduğu bağlantı kimliği `Start` yöntemi değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="b55c7-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="b55c7-159">`OnReconnected` Olay işleyicisi Hub'ında bir aktarım bağlantısı kesilmiş sonra otomatik olarak yeniden kurulduğunda yürütür.</span><span class="sxs-lookup"><span data-stu-id="b55c7-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="b55c7-160">`OnDisconnected` Olay işleyicisi bir SignalR bağlantısının sonunda yürütür.</span><span class="sxs-lookup"><span data-stu-id="b55c7-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="b55c7-161">Bir SignalR bağlantısının aşağıdaki yollardan biriyle sona erdirilebilir:</span><span class="sxs-lookup"><span data-stu-id="b55c7-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="b55c7-162">İstemci çağırırsa `Stop` yöntemi, bir Dur iletisi sunucuya gönderilir ve hem istemci hem de sunucu son SignalR bağlantı hemen.</span><span class="sxs-lookup"><span data-stu-id="b55c7-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="b55c7-163">İstemci ve sunucu arasında bağlantı kaybedildikten sonra istemci yeniden dener ve istemci yeniden bağlanmak sunucunun bekler.</span><span class="sxs-lookup"><span data-stu-id="b55c7-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="b55c7-164">Yeniden bağlanma girişimleri başarısız olur ve bağlantı kesme zaman aşımı süresi sona erer, istemci ve sunucu SignalR bağlantı sonlandır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="b55c7-165">İstemci yeniden bağlanmayı denemeden durdurur ve sunucunun SignalR bağlantı gösterimine siler.</span><span class="sxs-lookup"><span data-stu-id="b55c7-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="b55c7-166">İstemci çağırmak için bir fırsat zorunda kalmadan çalıştıran durduğunda `Stop` yöntemi, sunucunun beklediği istemci yeniden bağlamak ve sonra bağlantı kesme zaman aşımı süresi sonrasında SignalR bağlantıyı sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="b55c7-167">Çalıştırmayı, sunucu durdurur, istemci yeniden denediğinde (Aktarım bağlantısı yeniden oluşturursanız) ve sonra bağlantı kesme zaman aşımı süresi sonrasında SignalR bağlantıyı sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="b55c7-168">Ne zaman bağlantı sorunu olmadığından ve kullanıcı uygulaması çağırarak SignalR bağlantı sona erer `Stop` yöntemi, SignalR bağlantı ve taşıma bağlantısını başlayıp bitmelidir aynı zamanda hakkında.</span><span class="sxs-lookup"><span data-stu-id="b55c7-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="b55c7-169">Aşağıdaki bölümlerde, diğer senaryolar daha ayrıntılı olarak açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="b55c7-170">Taşıma bağlantısı kesme senaryoları</span><span class="sxs-lookup"><span data-stu-id="b55c7-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="b55c7-171">Fiziksel bağlantı yavaş olabilir veya bağlantı kesintiler olabilir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="b55c7-172">Taşıma bağlantısını kesinti uzunluğu gibi faktörlere bağlı olarak bırakılabilir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="b55c7-173">SignalR, ardından taşıma bağlantısını yeniden kurmaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="b55c7-174">Bazen taşıma bağlantısını API kesinti algılar ve taşıma bağlantısını keser ve SignalR hemen bağlantısı kesildiği öğrenir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="b55c7-175">Diğer senaryolarda ne taşıma bağlantısını API ve SignalR hemen bağlantı kaybedildi haberdar olur.</span><span class="sxs-lookup"><span data-stu-id="b55c7-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="b55c7-176">Uzun yoklama dışındaki tüm aktarımları için çağrılan bir işlev SignalR istemcinin *keepalive* taşıma API'si algılayamaz bağlantı kaybı için denetlenecek.</span><span class="sxs-lookup"><span data-stu-id="b55c7-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="b55c7-177">Uzun yoklama bağlantılar hakkında daha fazla bilgi için bkz: [zaman aşımı ve keepalive ayarları](#timeoutkeepalive) bu konuda.</span><span class="sxs-lookup"><span data-stu-id="b55c7-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="b55c7-178">Düzenli aralıklarla bir bağlantı etkin olduğunda sunucu istemciye keepalive paket gönderir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="b55c7-179">Bu makalenin yazıldığı tarih itibarıyla varsayılan sıklık her 10 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="b55c7-180">Bu paketler için dinleyerek istemciler bir bağlantı sorunu olmadığını söyleyebilir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="b55c7-181">Keepalive paket beklendiğinde alınmazsa, kısa bir süre sonra istemci yavaşlık veya kesintiler gibi bağlantı sorunlarını olduğunu varsayar.</span><span class="sxs-lookup"><span data-stu-id="b55c7-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="b55c7-182">Keepalive uzun bir süre sonra hala alınmazsa, bağlantı kesildi ve yeniden bağlanmayı deniyor başlar istemci varsayar.</span><span class="sxs-lookup"><span data-stu-id="b55c7-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="b55c7-183">Aşağıdaki diyagram tipik bir senaryoda hemen taşıma API'si tarafından tanınmayan fiziksel bağlantı sorunları olduğunda oluşan istemci ve sunucu olayları gösterir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="b55c7-184">Diyagram için aşağıdaki koşullar geçerlidir:</span><span class="sxs-lookup"><span data-stu-id="b55c7-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="b55c7-185">Taşıma WebSockets, sonsuza kadar çerçeve veya sunucu tarafından gönderilen olayların ' dir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="b55c7-186">Fiziksel ağ bağlantısını kesinti değişen dönemlerini vardır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="b55c7-187">SignalR bunları algılamak için keepalive işlevselliğini kullanır. böylece taşıma API'si kesintileri farkında olmaz.</span><span class="sxs-lookup"><span data-stu-id="b55c7-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Aktarım bağlantı kesilmesi](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="b55c7-189">İstemci modu yeniden bağlanmayı içine geçer, ancak bağlantı kesme zaman aşımı sınırı içinde aktarım bağlantı kuramıyor. sunucu SignalR bağlantıyı sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="b55c7-190">Bu durum oluştuğunda, Hub'ın sunucu yürütür `OnDisconnected` yöntemi ve daha sonra bağlanmak istemci yöneten olasılığına istemciye gönderilecek bir bağlantı kesme iletisi sıralarını.</span><span class="sxs-lookup"><span data-stu-id="b55c7-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="b55c7-191">İstemci, daha sonra yeniden bağlarsanız, çağrıları ve bağlantıyı kesme komutu aldığı `Stop` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="b55c7-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="b55c7-192">Bu senaryoda, `OnReconnected` istemci bağlandığında yürütülmez ve `OnDisconnected` istemci çağırdığında yürütülmez `Stop`.</span><span class="sxs-lookup"><span data-stu-id="b55c7-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="b55c7-193">Aşağıdaki diyagramda, bu senaryo gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-193">The following diagram illustrates this scenario.</span></span>

![Aktarım kesintileri - sunucu zaman aşımı](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="b55c7-195">İstemcide oluşturulabilir SignalR bağlantı ömrü olaylarını aşağıda verilmiştir:</span><span class="sxs-lookup"><span data-stu-id="b55c7-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- `ConnectionSlow` <span data-ttu-id="b55c7-196">İstemci olay.</span><span class="sxs-lookup"><span data-stu-id="b55c7-196">client event.</span></span>

    <span data-ttu-id="b55c7-197">Keepalive ping alındı veya önceden belirlenmiş bir keepalive zaman aşımı süresi oranını son yapılacak itibaren geçen zaman oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="b55c7-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="b55c7-198">Varsayılan keepalive uyarı zaman aşımını 2/3 keepalive zaman aşımı olur.</span><span class="sxs-lookup"><span data-stu-id="b55c7-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="b55c7-199">Keepalive zaman aşımı süresi 20 saniye olduğundan yaklaşık 13 saniyede uyarı oluşur.</span><span class="sxs-lookup"><span data-stu-id="b55c7-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="b55c7-200">Varsayılan olarak, sunucu, 10 saniyede keepalive ping gönderir ve istemci keepalive ping her 2 saniyede (keepalive zaman aşımı değeri keepalive zaman aşımı uyarısı değeri arasındaki farkı üçüncü bir) ilgili olup olmadığını denetler.</span><span class="sxs-lookup"><span data-stu-id="b55c7-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="b55c7-201">Taşıma API'si bir bağlantısının kesilmesi uyumlu hale gelirse keepalive uyarı zaman aşımını geçirmeden önce SignalR bağlantısının kesilmesi haberdar olması.</span><span class="sxs-lookup"><span data-stu-id="b55c7-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="b55c7-202">Bu durumda, `ConnectionSlow` olay değil yükseltilebilir ve SignalR Git doğrudan `Reconnecting` olay.</span><span class="sxs-lookup"><span data-stu-id="b55c7-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- `Reconnecting` <span data-ttu-id="b55c7-203">İstemci olay.</span><span class="sxs-lookup"><span data-stu-id="b55c7-203">client event.</span></span>

    <span data-ttu-id="b55c7-204">Bağlantı kaybedilirse veya (b) keepalive zaman aşımı süresi son yapılacak itibaren geçen veya keepalive ping alındı (a) aktarım API tespit ettiğinde oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="b55c7-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="b55c7-205">SignalR istemci kodu yeniden bağlanmaya çalışılırken başlar.</span><span class="sxs-lookup"><span data-stu-id="b55c7-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="b55c7-206">Taşıma bağlantısı kesildiğinde, bazı işlemler yapması için uygulamanızı isterseniz bu olay işleyebilir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="b55c7-207">Varsayılan keepalive zaman aşımı süresi şu anda 20 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="b55c7-208">İstemci kodunuz SignalR modu yeniden bağlanmayı de olsa bir Hub yöntemini çağırmaya çalışırsa, SignalR komutu göndermeyi yeniden deneyecek.</span><span class="sxs-lookup"><span data-stu-id="b55c7-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="b55c7-209">Çoğu zaman, bu tür denemeleri başarısız olur, ancak bazı durumlarda bunlar başarılı olabilir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="b55c7-210">Sunucu tarafından gönderilen olayları, sonsuza kadar çerçeve ve uzun yoklama taşıma için iki iletişim kanalı, istemcinin göndermek için kullandığı diğeri iletileri almak için kullandığı SignalR kullanır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="b55c7-211">Kanal alma için kullanılan kalıcı olarak açık olur ve fiziksel bağlantı kesildiğinde kapalı bir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="b55c7-212">Fiziksel bağlantısı geri alma kanal yeniden kurulur önce istemciden sunucuya bir yöntem çağrısının başarılı olabilir kullanılabilir kalır göndermek için kullanılan kanal.</span><span class="sxs-lookup"><span data-stu-id="b55c7-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="b55c7-213">SignalR alma için kullanılan kanal yeniden açılana kadar dönüş değeri alınmayan.</span><span class="sxs-lookup"><span data-stu-id="b55c7-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- `Reconnected` <span data-ttu-id="b55c7-214">İstemci olay.</span><span class="sxs-lookup"><span data-stu-id="b55c7-214">client event.</span></span>

    <span data-ttu-id="b55c7-215">Aktarım bağlantısı yeniden kurulduğunda oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="b55c7-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="b55c7-216">`OnReconnected` Hub olay işleyicisinde yürütür.</span><span class="sxs-lookup"><span data-stu-id="b55c7-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- `Closed` <span data-ttu-id="b55c7-217">İstemci olayı (`disconnected` JavaScript olay).</span><span class="sxs-lookup"><span data-stu-id="b55c7-217">client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="b55c7-218">SignalR istemci kodu Aktarım bağlantısı kaybettikten sonra yeniden bağlanmaya çalışırken bağlantı kesme zaman aşımı süresi dolduğunda oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="b55c7-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="b55c7-219">Varsayılan bağlantı kesme zaman aşımı olan 30 saniye.</span><span class="sxs-lookup"><span data-stu-id="b55c7-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="b55c7-220">(Bu olay için bağlantı sona erdiğinde de tetiklenir `Stop` yöntemi çağrılır.)</span><span class="sxs-lookup"><span data-stu-id="b55c7-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="b55c7-221">Taşıma API'si tarafından algılanmayan ve keepalive ping keepalive zaman aşımı uyarısı süresinden daha uzun bir süre sunucudan alımını beklemeyin aktarım bağlantı kesintilerini herhangi bir bağlantı oluşturulması yaşam süresi olayları neden.</span><span class="sxs-lookup"><span data-stu-id="b55c7-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="b55c7-222">Bazı ağ ortamları boşta kalan bağlantıların kasıtlı olarak kapatın ve bu ağların bir SignalR bağlantısı kullanımda almayacağınızı tarafından bu önlemeye yardımcı olmak için keepalive paketlerinin başka bir işlev.</span><span class="sxs-lookup"><span data-stu-id="b55c7-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="b55c7-223">Aşırı durumlarda varsayılan keepalive ping sıklığını kapalı bağlantılarını önlemek için yeterli olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="b55c7-224">Bu durumda, daha sık gönderilmesini keepalive ping yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b55c7-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="b55c7-225">Daha fazla bilgi için [zaman aşımı ve keepalive ayarları](#timeoutkeepalive) bu konuda.</span><span class="sxs-lookup"><span data-stu-id="b55c7-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="b55c7-226">**Önemli**: Burada açıklanan olayların sırasını garanti edilmez.</span><span class="sxs-lookup"><span data-stu-id="b55c7-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="b55c7-227">SignalR bağlantı ömrü olaylarını bu düzene göre öngörülebilir bir şekilde yükseltmek için her girişimlerde bulunur, ancak ağ olayları çeşitli kullanımları ve hangi aktarım API'leri gibi temel iletişim çerçeveleri bunları işlemesi birçok yolu vardır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="b55c7-228">Örneğin, `Reconnected` istemci bağlandığında, olay oluşmayabilir veya `OnConnected` işleyici sunucudaki bağlantı girişimi başarısız olduğunda çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b55c7-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="b55c7-229">Bu konuda, genellikle bazı tipik durumlarda tarafından üretilen etkileri açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>


<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="b55c7-230">İstemci bağlantı kesilmesi senaryoları</span><span class="sxs-lookup"><span data-stu-id="b55c7-230">Client disconnection scenarios</span></span>

<span data-ttu-id="b55c7-231">Bir tarayıcı istemcisinin bir SignalR bağlantısının tutan SignalR istemci kodu bir web sayfasının JavaScript bağlamında çalıştırılır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="b55c7-232">Sahip bir gittiğinizde sonlandırmak SignalR bağlantısı neden sayfa için başka bir ve söz konusu bilgisayarın neden varsa birden çok bağlantı kimlikleri birden fazla bağlantıyla birden çok tarayıcı pencerelerini veya sekmeleri bağlanın.</span><span class="sxs-lookup"><span data-stu-id="b55c7-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="b55c7-233">Kullanıcı bir tarayıcı penceresi veya sekmesi kapatır veya yeni bir sayfaya gider veya sayfa yenilendikten sonra ve aramalar için SignalR istemci kodu, tarayıcı olayını işler çünkü SignalR bağlantı hemen sona `Stop` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="b55c7-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="b55c7-234">Bu senaryolar ya da uygulamanız çağırdığında istemci platformu `Stop` yöntemi `OnDisconnected` olay işleyicisi sunucuda hemen yürütür ve istemcinin oluşturduğu `Closed` olay (olay adlı `disconnected` içinde JavaScript için).</span><span class="sxs-lookup"><span data-stu-id="b55c7-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="b55c7-235">Bir istemci uygulaması veya üzerinde çalıştığı bilgisayar kilitleniyor veya (örneğin, kullanıcının bir dizüstü bilgisayar kapandığında) uyku moduna geçer, sunucunun ne hakkında bilgisi verilmediği için.</span><span class="sxs-lookup"><span data-stu-id="b55c7-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="b55c7-236">Sunucu bilir kadar istemci kaybı nedeniyle bağlantı kesintisi olabilir ve istemciyi yeniden çalışıyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="b55c7-237">Bu nedenle, sunucunun beklediği istemci yeniden bağlanmak için bir fırsat vermek için bu senaryolarda ve `OnDisconnected` (yaklaşık 30 saniye varsayılan olarak) bağlantı kesme zaman aşımı süresi dolana kadar yürütmez.</span><span class="sxs-lookup"><span data-stu-id="b55c7-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="b55c7-238">Aşağıdaki diyagramda, bu senaryo gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-238">The following diagram illustrates this scenario.</span></span>

![İstemci bilgisayar hatası](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="b55c7-240">Sunucu bağlantı kesilmesi senaryoları</span><span class="sxs-lookup"><span data-stu-id="b55c7-240">Server disconnection scenarios</span></span>

<span data-ttu-id="b55c7-241">Bir sunucu çevrimdışı--olduğunda yeniden başlatır, başarısız olursa uygulama etki alanı geri dönüştürme işlemleri, vb.--sonuç bir bağlantı kesildi benzer olabilir veya aktarım API ve SignalR hemen sunucu kalktığını ve SignalR başlayın olmadan yeniden bağlanmaya çalışılırken biliyor olabilirsiniz yükseltme `ConnectionSlow` olay.</span><span class="sxs-lookup"><span data-stu-id="b55c7-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="b55c7-242">İstemci, istemci modu yeniden bağlanmayı içine aşması durumunda ve sunucu kurtarır ya da bağlantı kesme zaman aşımı süresi dolmadan önce yeniden başlatma veya yeni bir sunucu çevrimiçi duruma geri yüklendi veya yeni sunucuya yeniden bağlanır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="b55c7-243">Bu durumda, istemcide SignalR bağlantısı devam eder ve `Reconnected` olayı oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="b55c7-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="b55c7-244">İlk sunucusunda `OnDisconnected` asla yürütülmez ve yeni sunucudaki `OnReconnected` rağmen yürütülür `OnConnected` hiçbir zaman önce bu sunucuda istemci için yürütüldü.</span><span class="sxs-lookup"><span data-stu-id="b55c7-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="b55c7-245">(Aynı sunucu da başlatıldığında çünkü istemci bir yeniden başlatma veya uygulama etki alanı dönüşüm sonra aynı sunucuya bağlanırsa önceki bağlantı etkinlik belleğe sahip değil etkili olur.) Aşağıdaki diyagramda taşıma API'si hemen bağlantı kesildi haberdar olur varsayar. Bu nedenle `ConnectionSlow` olayı oluşmaz.</span><span class="sxs-lookup"><span data-stu-id="b55c7-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Sunucu hatası ve yeniden bağlanma](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="b55c7-247">Bir sunucu bağlantı kesme zaman aşımı süresi içinde kullanılabilir hale gelmezse, SignalR bağlantısı ile sona erer.</span><span class="sxs-lookup"><span data-stu-id="b55c7-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="b55c7-248">Bu senaryoda, `Closed` olay (`disconnected` JavaScript istemcilerinin) istemcide oluşturulur ancak `OnDisconnected` sunucuda hiçbir zaman çağrılır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="b55c7-249">Aşağıdaki diyagramda, SignalR keepalive işlevi tarafından algılandığı şekilde taşıma API'si bağlantı kesildi, farkında haline gelmediğinden emin varsayar ve `ConnectionSlow` olayı oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="b55c7-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Sunucu hatası ve zaman aşımı](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="b55c7-251">Zaman aşımı ve keepalive ayarları</span><span class="sxs-lookup"><span data-stu-id="b55c7-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="b55c7-252">Varsayılan `ConnectionTimeout`, `DisconnectTimeout`, ve `KeepAlive` değerler çoğu senaryo için uygun olan ancak ortamınıza özel gereksinimleri varsa değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="b55c7-253">Örneğin, ağ ortamınızda 5 saniye boyunca boşta bağlantılar kapanıyorsa keepalive değerini azaltın gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="b55c7-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="b55c7-254">ConnectionTimeout</span></span>

<span data-ttu-id="b55c7-255">Bu ayarı açık ve yeni bir bağlantı açmak ve kapatmadan önce yanıt bekleyen bir aktarım bağlantısı kalma süresini temsil eder.</span><span class="sxs-lookup"><span data-stu-id="b55c7-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="b55c7-256">Varsayılan değer 110 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="b55c7-257">Bu ayar, yalnızca zaman keepalive işlevi, normalde yalnızca uzun olarak uygulandığı devre dışı geçerlidir yoklama taşıması.</span><span class="sxs-lookup"><span data-stu-id="b55c7-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="b55c7-258">Aşağıdaki diyagram bu ayarı uzun etkisini gösterir. yoklama taşıma bağlantısı.</span><span class="sxs-lookup"><span data-stu-id="b55c7-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Uzun yoklama taşıma bağlantısı](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="b55c7-260">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="b55c7-260">DisconnectTimeout</span></span>

<span data-ttu-id="b55c7-261">Bu ayar tetiklenmeden önce bir aktarım bağlantısı kayboldu sonra beklenecek süreyi temsil eden `Disconnected` olay.</span><span class="sxs-lookup"><span data-stu-id="b55c7-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="b55c7-262">Varsayılan değer 30 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-262">The default value is 30 seconds.</span></span> <span data-ttu-id="b55c7-263">Ayarladığınızda `DisconnectTimeout`, `KeepAlive` 1/3'e ayarlandığında otomatik olarak `DisconnectTimeout` değeri.</span><span class="sxs-lookup"><span data-stu-id="b55c7-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="b55c7-264">KeepAlive</span><span class="sxs-lookup"><span data-stu-id="b55c7-264">KeepAlive</span></span>

<span data-ttu-id="b55c7-265">Bu ayar, boştaki bir bağlantı üzerinden canlı tutma paketi göndermeden önce beklenecek süreyi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="b55c7-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="b55c7-266">Varsayılan değer 10 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-266">The default value is 10 seconds.</span></span> <span data-ttu-id="b55c7-267">Bu değer, birden fazla 1/3 / olmamalıdır `DisconnectTimeout` değeri.</span><span class="sxs-lookup"><span data-stu-id="b55c7-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="b55c7-268">Hem ayarlamak istiyorsanız `DisconnectTimeout` ve `KeepAlive`ayarlayın `KeepAlive` sonra `DisconnectTimeout`.</span><span class="sxs-lookup"><span data-stu-id="b55c7-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="b55c7-269">Aksi takdirde, `KeepAlive` ayar olacak üzerine ne zaman `DisconnectTimeout` otomatik olarak ayarlar `KeepAlive` zaman aşımı değeri 1/3.</span><span class="sxs-lookup"><span data-stu-id="b55c7-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="b55c7-270">Keepalive işlevini devre dışı bırakmak istiyorsanız, `KeepAlive` null.</span><span class="sxs-lookup"><span data-stu-id="b55c7-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="b55c7-271">KeepAlive işlevleri otomatik olarak uzun süre devre dışı yoklama taşıması.</span><span class="sxs-lookup"><span data-stu-id="b55c7-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="b55c7-272">Zaman aşımı ve keepalive ayarlarını değiştirme</span><span class="sxs-lookup"><span data-stu-id="b55c7-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="b55c7-273">Bu ayarlar için varsayılan değerleri değiştirmek için bunları kümesinde `Application_Start` içinde *Global.asax* , aşağıdaki örnekte gösterildiği gibi dosya.</span><span class="sxs-lookup"><span data-stu-id="b55c7-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="b55c7-274">Örnek kodda gösterilen değerleri varsayılan değerleri ile aynıdır.</span><span class="sxs-lookup"><span data-stu-id="b55c7-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="b55c7-275">Kullanıcı bağlantı kesilmesi hakkında bilgilendirme</span><span class="sxs-lookup"><span data-stu-id="b55c7-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="b55c7-276">Bazı uygulamalarda bağlantı sorunları olduğunda, kullanıcıya bir ileti görüntülemek isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="b55c7-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="b55c7-277">Çeşitli seçenekler nasıl ve ne zaman bunu yapmak var.</span><span class="sxs-lookup"><span data-stu-id="b55c7-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="b55c7-278">Aşağıdaki kod örnekleri, oluşturulan proxy kullanmak için bir JavaScript istemcisi olan.</span><span class="sxs-lookup"><span data-stu-id="b55c7-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="b55c7-279">Tanıtıcı `connectionSlow` modu yeniden bağlanmayı içine geçmeden önce SignalR, bağlantı sorunların farkında hemen sonra bir ileti görüntülemek için olay.</span><span class="sxs-lookup"><span data-stu-id="b55c7-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="b55c7-280">Tanıtıcı `reconnecting` SignalR bağlantı kesilmesi farkındadır ve modu yeniden bağlanmayı uygulamasına gidip bir ileti görüntülemek için olay.</span><span class="sxs-lookup"><span data-stu-id="b55c7-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="b55c7-281">Tanıtıcı `disconnected` yeniden bağlanma girişimi olduğunda bir ileti görüntülemek için olay zaman aşımına uğradı. Bu senaryoda, bir sunucu ile yeniden yeniden bağlantı kurmayı tek yolu çağırarak SignalR bağlantı yeniden başlatmaktır `Start` yeni bir bağlantı kimliği oluşturur, yöntemi</span><span class="sxs-lookup"><span data-stu-id="b55c7-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="b55c7-282">Aşağıdaki kod örneği, yalnızca yeniden bağlanan bir zaman aşımından sonra bildirim çağırarak neden SignalR bağlantı normal bir ucuna değil sonra sorun emin olmak için bir bayrak kullanır. `Stop` yöntemi.</span><span class="sxs-lookup"><span data-stu-id="b55c7-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="b55c7-283">Sürekli olarak yeniden bağlama</span><span class="sxs-lookup"><span data-stu-id="b55c7-283">How to continuously reconnect</span></span>

<span data-ttu-id="b55c7-284">Bazı uygulamalarda otomatik olarak kaybolmuş olabilir ve yeniden bağlanma girişimi zaman aşımına uğradı sonra yeniden bağlantı isteyebilirsiniz. Bunu yapmak için çağırabilirsiniz `Start` yönteminden, `Closed` olay işleyicisi (`disconnected` JavaScript istemcilerde olay işleyicisi).</span><span class="sxs-lookup"><span data-stu-id="b55c7-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="b55c7-285">Çağırmadan önce bir süre bekleyin isteyebileceğiniz `Start` çok Bunu önlemek için sık sunucu veya fiziksel bağlantısı olduğunda kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="b55c7-286">Aşağıdaki kod örneği, oluşturulan proxy kullanarak JavaScript istemcisi için ' dir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="b55c7-287">Mobil istemciler dikkat edilmesi gereken olası bir sorunu, sunucu ya da fiziksel bağlantı kullanılamadığında sürekli yeniden bağlanma denemesi gereksiz pil boşaltma neden olabilecek ' dir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="b55c7-288">Bir istemci sunucu kodunda kesme hakkında</span><span class="sxs-lookup"><span data-stu-id="b55c7-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="b55c7-289">SignalR sürüm 2, istemcilerin bağlantıları kesiliyor için yerleşik bir sunucu API yok.</span><span class="sxs-lookup"><span data-stu-id="b55c7-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="b55c7-290">Vardır [gelecekte bu işlevsellik eklemek için planlar](https://github.com/SignalR/SignalR/issues/2101).</span><span class="sxs-lookup"><span data-stu-id="b55c7-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="b55c7-291">Geçerli SignalR, en basit yolu, bir istemcinin sunucudan bağlantısını kesmek için istemcide bir bağlantıyı kes yöntemi uygulaması ve sunucudan bu yöntemi çağırmak için sürümündedir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="b55c7-292">Aşağıdaki kod örneği oluşturulan proxy kullanarak JavaScript istemcisi için bir bağlantı kesme yöntemi gösterir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="b55c7-293">Güvenlik - ne istemcilerin bağlantıları kesiliyor için bu yöntem ya da önerilen yerleşik API adres kötü amaçlı kod çalıştıran istemcilerin adresine yeniden bağlanılamadı veya ele geçirilen kodu kaldırabilir kullanılan istemcilerin senaryo `stopClient` yöntemi veya değiştirme ne işe yarar.</span><span class="sxs-lookup"><span data-stu-id="b55c7-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="b55c7-294">Durum bilgisi olan hizmet reddi (DOS) koruması uygulamak için en uygun framework veya sunucusu katmanı değil, ön uç altyapısı yerdir.</span><span class="sxs-lookup"><span data-stu-id="b55c7-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>


<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="b55c7-295">Bağlantı kesilmesi nedeni algılama</span><span class="sxs-lookup"><span data-stu-id="b55c7-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="b55c7-296">SignalR 2.1 sunucuya aşırı ekler `OnDisconnect` aşımından yerine istemci kasıtlı olarak bağlı olmadığını gösteren bir olay. `StopCalled` Parametredir istemci açıkça bağlantı kapalı değilse true.</span><span class="sxs-lookup"><span data-stu-id="b55c7-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="b55c7-297">İstemci bağlantısını kesmek için bir sunucu hatası neden olursa JavaScript'te hata bilgilerini istemci olarak geçirilecek `$.connection.hub.lastError`.</span><span class="sxs-lookup"><span data-stu-id="b55c7-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

**<span data-ttu-id="b55c7-298">C#sunucu kodu: `stopCalled` parametresi</span><span class="sxs-lookup"><span data-stu-id="b55c7-298">C# server code: `stopCalled` parameter</span></span>**

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

**<span data-ttu-id="b55c7-299">JavaScript istemci kodu: erişme `lastError` içinde `disconnect` olay.</span><span class="sxs-lookup"><span data-stu-id="b55c7-299">JavaScript client code: accessing `lastError` in the `disconnect` event.</span></span>**

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
