---
uid: signalr/overview/guide-to-the-api/handling-connection-lifetime-events
title: SignalR 'de bağlantı ömrü olaylarını anlama ve Işleme | Microsoft Docs
author: bradygaster
description: Bu makalede, hub API 'SI tarafından kullanıma sunulan olayların nasıl kullanılacağı açıklanır.
ms.author: bradyg
ms.date: 01/15/2019
ms.assetid: 03960de2-8d95-4444-9169-4426dcc64913
msc.legacyurl: /signalr/overview/guide-to-the-api/handling-connection-lifetime-events
msc.type: authoredcontent
ms.openlocfilehash: 5bdf20549fccab5d644e35fdf4ce351540c8620d
ms.sourcegitcommit: c62ec20b453cee3249eb894ecd75013b57d078f0
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/21/2020
ms.locfileid: "92345226"
---
# <a name="understanding-and-handling-connection-lifetime-events-in-signalr"></a><span data-ttu-id="33db8-103">SignalR’da Bağlantı Ömrü Olaylarını Anlama ve İşleme</span><span class="sxs-lookup"><span data-stu-id="33db8-103">Understanding and Handling Connection Lifetime Events in SignalR</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="33db8-104">Bu makalede, işleyebilmeniz gereken SignalR bağlantısı, yeniden bağlanma ve bağlantı kesme olayları ve yapılandırabileceğiniz zaman aşımı ve KeepAlive ayarları hakkında genel bir bakış sunulmaktadır.</span><span class="sxs-lookup"><span data-stu-id="33db8-104">This article provides an overview of the SignalR connection, reconnection, and disconnection events that you can handle, and timeout and keepalive settings that you can configure.</span></span>
>
> <span data-ttu-id="33db8-105">Makalede, bir SignalR ve bağlantı ömrü olayları hakkında bilgi sahibi olduğunuz varsayılmaktadır.</span><span class="sxs-lookup"><span data-stu-id="33db8-105">The article assumes you already have some knowledge of SignalR and connection lifetime events.</span></span> <span data-ttu-id="33db8-106">SignalR 'ye giriş için bkz. [SignalR 'ye giriş](../getting-started/introduction-to-signalr.md).</span><span class="sxs-lookup"><span data-stu-id="33db8-106">For an introduction to SignalR, see [Introduction to SignalR](../getting-started/introduction-to-signalr.md).</span></span> <span data-ttu-id="33db8-107">Bağlantı ömrü olaylarının listesi için aşağıdaki kaynaklara bakın:</span><span class="sxs-lookup"><span data-stu-id="33db8-107">For lists of connection lifetime events, see the following resources:</span></span>
>
> - [<span data-ttu-id="33db8-108">Hub sınıfında bağlantı ömrü olaylarını işleme</span><span class="sxs-lookup"><span data-stu-id="33db8-108">How to handle connection lifetime events in the Hub class</span></span>](hubs-api-guide-server.md#connectionlifetime)
> - [<span data-ttu-id="33db8-109">JavaScript istemcilerinde bağlantı ömrü olaylarını işleme</span><span class="sxs-lookup"><span data-stu-id="33db8-109">How to handle connection lifetime events in JavaScript clients</span></span>](hubs-api-guide-javascript-client.md#connectionlifetime)
> - [<span data-ttu-id="33db8-110">.NET istemcilerindeki bağlantı ömrü olaylarını işleme</span><span class="sxs-lookup"><span data-stu-id="33db8-110">How to handle connection lifetime events in .NET clients</span></span>](hubs-api-guide-net-client.md#connectionlifetime)
>
> ## <a name="software-versions-used-in-this-topic"></a><span data-ttu-id="33db8-111">Bu konuda kullanılan yazılım sürümleri</span><span class="sxs-lookup"><span data-stu-id="33db8-111">Software versions used in this topic</span></span>
>
>
> - [<span data-ttu-id="33db8-112">Visual Studio 2017</span><span class="sxs-lookup"><span data-stu-id="33db8-112">Visual Studio 2017</span></span>](https://visualstudio.microsoft.com/downloads/)
> - <span data-ttu-id="33db8-113">.NET 4.5</span><span class="sxs-lookup"><span data-stu-id="33db8-113">.NET 4.5</span></span>
> - <span data-ttu-id="33db8-114">SignalR sürüm 2</span><span class="sxs-lookup"><span data-stu-id="33db8-114">SignalR version 2</span></span>
>
>
>
> ## <a name="previous-versions-of-this-topic"></a><span data-ttu-id="33db8-115">Bu konunun önceki sürümleri</span><span class="sxs-lookup"><span data-stu-id="33db8-115">Previous versions of this topic</span></span>
>
> <span data-ttu-id="33db8-116">SignalR 'nin önceki sürümleri hakkında daha fazla bilgi için bkz. [SignalR daha eski sürümleri](../older-versions/index.md).</span><span class="sxs-lookup"><span data-stu-id="33db8-116">For information about earlier versions of SignalR, see [SignalR Older Versions](../older-versions/index.md).</span></span>
>
> ## <a name="questions-and-comments"></a><span data-ttu-id="33db8-117">Sorular ve açıklamalar</span><span class="sxs-lookup"><span data-stu-id="33db8-117">Questions and comments</span></span>
>
> <span data-ttu-id="33db8-118">Lütfen bu öğreticiyi nasıl beğentireceğiniz ve sayfanın en altındaki açıklamalarda İyileştiğimiz hakkında geri bildirimde bulunun.</span><span class="sxs-lookup"><span data-stu-id="33db8-118">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="33db8-119">Öğreticiyle doğrudan ilgili olmayan sorularınız varsa, bunları [ASP.NET SignalR forumuna](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) veya [StackOverflow.com](http://stackoverflow.com/)'e gönderebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33db8-119">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](http://stackoverflow.com/).</span></span>

## <a name="overview"></a><span data-ttu-id="33db8-120">Genel Bakış</span><span class="sxs-lookup"><span data-stu-id="33db8-120">Overview</span></span>

<span data-ttu-id="33db8-121">Bu makale aşağıdaki bölümleri içerir:</span><span class="sxs-lookup"><span data-stu-id="33db8-121">This article contains the following sections:</span></span>

- [<span data-ttu-id="33db8-122">Bağlantı ömrü terimleri ve senaryoları</span><span class="sxs-lookup"><span data-stu-id="33db8-122">Connection lifetime terminology and scenarios</span></span>](#terminology)

    - [<span data-ttu-id="33db8-123">SignalR bağlantıları, aktarım bağlantıları ve fiziksel bağlantılar</span><span class="sxs-lookup"><span data-stu-id="33db8-123">SignalR connections, transport connections, and physical connections</span></span>](#signalrvstransport)
    - [<span data-ttu-id="33db8-124">Taşıma bağlantısının kesilmesi senaryoları</span><span class="sxs-lookup"><span data-stu-id="33db8-124">Transport disconnection scenarios</span></span>](#transportdisconnect)
    - [<span data-ttu-id="33db8-125">İstemci bağlantısının kesilmesi senaryoları</span><span class="sxs-lookup"><span data-stu-id="33db8-125">Client disconnection scenarios</span></span>](#clientdisconnect)
    - [<span data-ttu-id="33db8-126">Sunucu bağlantısı kesme senaryoları</span><span class="sxs-lookup"><span data-stu-id="33db8-126">Server disconnection scenarios</span></span>](#serverdisconnect)
- [<span data-ttu-id="33db8-127">Zaman aşımı ve KeepAlive ayarları</span><span class="sxs-lookup"><span data-stu-id="33db8-127">Timeout and keepalive settings</span></span>](#timeoutkeepalive)

    - [<span data-ttu-id="33db8-128">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="33db8-128">ConnectionTimeout</span></span>](#connectiontimeout)
    - [<span data-ttu-id="33db8-129">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="33db8-129">DisconnectTimeout</span></span>](#disconnecttimeout)
    - [<span data-ttu-id="33db8-130">Alı</span><span class="sxs-lookup"><span data-stu-id="33db8-130">KeepAlive</span></span>](#keepalive)
    - [<span data-ttu-id="33db8-131">Zaman aşımı ve KeepAlive ayarlarını değiştirme</span><span class="sxs-lookup"><span data-stu-id="33db8-131">How to change timeout and keepalive settings</span></span>](#changetimeout)
- [<span data-ttu-id="33db8-132">Kullanıcıya, bağlantısı kesilme hakkında bildirme</span><span class="sxs-lookup"><span data-stu-id="33db8-132">How to notify the user about disconnections</span></span>](#notifydisconnect)
- [<span data-ttu-id="33db8-133">Sürekli yeniden bağlanma</span><span class="sxs-lookup"><span data-stu-id="33db8-133">How to continuously reconnect</span></span>](#continuousreconnect)
- [<span data-ttu-id="33db8-134">Sunucu kodundaki bir istemcinin bağlantısını kesme</span><span class="sxs-lookup"><span data-stu-id="33db8-134">How to disconnect a client in server code</span></span>](#disconnectclientfromserver)
- [<span data-ttu-id="33db8-135">Bağlantısının kesilmesi nedenini algılama</span><span class="sxs-lookup"><span data-stu-id="33db8-135">Detecting the reason for a disconnection</span></span>](#detectingreasonfordisconnection)

<span data-ttu-id="33db8-136">API başvuru konularına bağlantılar, API 'nin .NET 4,5 sürümüdür.</span><span class="sxs-lookup"><span data-stu-id="33db8-136">Links to API Reference topics are to the .NET 4.5 version of the API.</span></span> <span data-ttu-id="33db8-137">.NET 4 kullanıyorsanız, [API konularının .NET 4 sürümüne](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx)bakın.</span><span class="sxs-lookup"><span data-stu-id="33db8-137">If you're using .NET 4, see [the .NET 4 version of the API topics](https://msdn.microsoft.com/library/jj891075(v=vs.100).aspx).</span></span>

<a id="terminology"></a>

## <a name="connection-lifetime-terminology-and-scenarios"></a><span data-ttu-id="33db8-138">Bağlantı ömrü terimleri ve senaryoları</span><span class="sxs-lookup"><span data-stu-id="33db8-138">Connection lifetime terminology and scenarios</span></span>

<span data-ttu-id="33db8-139">`OnReconnected`Bir SignalR hub 'ındaki olay işleyicisi, `OnConnected` `OnDisconnected` belirli bir istemci için doğrudan değil, sonra da çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-139">The `OnReconnected` event handler in a SignalR Hub can execute directly after `OnConnected` but not after `OnDisconnected` for a given client.</span></span> <span data-ttu-id="33db8-140">Bağlantı kesilmesi olmadan bir yeniden bağlantınızın olması, SignalR 'de "bağlantı" sözcüğünün kullanıldığı birkaç yol olmasının nedenidir.</span><span class="sxs-lookup"><span data-stu-id="33db8-140">The reason you can have a reconnection without a disconnection is that there are several ways in which the word "connection" is used in SignalR.</span></span>

<a id="signalrvstransport"></a>

### <a name="signalr-connections-transport-connections-and-physical-connections"></a><span data-ttu-id="33db8-141">SignalR bağlantıları, aktarım bağlantıları ve fiziksel bağlantılar</span><span class="sxs-lookup"><span data-stu-id="33db8-141">SignalR connections, transport connections, and physical connections</span></span>

<span data-ttu-id="33db8-142">Bu makale, *SignalR bağlantıları*, *Aktarım bağlantıları*ve *fiziksel bağlantılar*arasında ayrım sağlayacaktır:</span><span class="sxs-lookup"><span data-stu-id="33db8-142">This article will differentiate between *SignalR connections*, *transport connections*, and *physical connections*:</span></span>

- <span data-ttu-id="33db8-143">**SignalR bağlantısı** , bir istemci ile sunucu URL 'si arasındaki, SIGNALR API 'si tarafından tutulan ve BIR bağlantı kimliğiyle benzersiz bir ilişki anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="33db8-143">**SignalR connection** refers to a logical relationship between a client and a server URL, maintained by the SignalR API and uniquely identified by a connection ID.</span></span> <span data-ttu-id="33db8-144">Bu ilişkiyle ilgili veriler SignalR tarafından korunur ve bir aktarım bağlantısı kurmak için kullanılır.</span><span class="sxs-lookup"><span data-stu-id="33db8-144">The data about this relationship is maintained by SignalR and is used to establish a transport connection.</span></span> <span data-ttu-id="33db8-145">İstemci `Stop` yöntemi çağırdığında veya SignalR kayıp bir aktarım bağlantısını yeniden kurmaya çalışırken bir zaman aşımı sınırına ulaşıldığında ilişki sonlanır ve SignalR bu verileri ortadan kaldırmıştır.</span><span class="sxs-lookup"><span data-stu-id="33db8-145">The relationship ends and SignalR disposes of the data when the client calls the `Stop` method or a timeout limit is reached while SignalR is attempting to re-establish a lost transport connection.</span></span>
- <span data-ttu-id="33db8-146">**Aktarım bağlantısı** , bir istemci ile sunucu arasındaki, dört aktarım API 'si ile korunan bir mantıksal ilişki anlamına gelir: WebSockets, sunucu tarafından gönderilen olaylar, süresiz çerçeve veya uzun yoklama.</span><span class="sxs-lookup"><span data-stu-id="33db8-146">**Transport connection** refers to a logical relationship between a client and a server, maintained by one of the four transport APIs: WebSockets, server-sent events, forever frame, or long polling.</span></span> <span data-ttu-id="33db8-147">SignalR bir aktarım bağlantısı oluşturmak için aktarım API 'sini kullanır ve aktarım API 'SI, aktarım bağlantısı oluşturmak için fiziksel bir ağ bağlantısının varlığına bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="33db8-147">SignalR uses the transport API to create a transport connection, and the transport API depends on the existence of a physical network connection to create the transport connection.</span></span> <span data-ttu-id="33db8-148">SignalR bunu sonlandırdığında veya aktarım API 'SI fiziksel bağlantının kopuk olduğunu algıladığında aktarım bağlantısı sona erer.</span><span class="sxs-lookup"><span data-stu-id="33db8-148">The transport connection ends when SignalR terminates it or when the transport API detects that the physical connection is broken.</span></span>
- <span data-ttu-id="33db8-149">**Fiziksel bağlantı** , bir istemci bilgisayarı ile sunucu bilgisayarı arasındaki iletişimi kolaylaştıran fiziksel ağ bağlantıları--kablolar, kablosuz sinyaller, yönlendiriciler vb. anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="33db8-149">**Physical connection** refers to the physical network links -- wires, wireless signals, routers, etc. -- that facilitate communication between a client computer and a server computer.</span></span> <span data-ttu-id="33db8-150">Bir aktarım bağlantısı kurmak için fiziksel bağlantı bulunmalı ve bir SignalR bağlantısı kurmak için bir aktarım bağlantısı kurulması gerekir.</span><span class="sxs-lookup"><span data-stu-id="33db8-150">The physical connection must be present in order to establish a transport connection, and a transport connection must be established in order to establish a SignalR connection.</span></span> <span data-ttu-id="33db8-151">Bununla birlikte, fiziksel bağlantının kesilmesi, bu konunun ilerleyen kısımlarında açıklanacak olan aktarım bağlantısını veya SignalR bağlantısını her zaman hemen sonlandırmaz.</span><span class="sxs-lookup"><span data-stu-id="33db8-151">However, breaking the physical connection doesn't always immediately end the transport connection or the SignalR connection, as will be explained later in this topic.</span></span>

<span data-ttu-id="33db8-152">Aşağıdaki diyagramda, SignalR bağlantısı hub API 'SI ve PersistentConnection API SignalR katmanı tarafından temsil edilir. aktarım bağlantısı, aktarımlar katmanı tarafından temsil edilir ve fiziksel bağlantı, sunucu ve istemci arasındaki çizgilerle gösterilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-152">In the following diagram, the SignalR connection is represented by the Hubs API and PersistentConnection API SignalR layer, the transport connection is represented by the Transports layer, and the physical connection is represented by the lines between the server and the clients.</span></span>

![SignalR mimarisi diyagramı](handling-connection-lifetime-events/_static/image1.png)

<span data-ttu-id="33db8-154">`Start`Yöntemini bir SignalR istemcisinde çağırdığınızda, bir sunucuya fiziksel bağlantı kurmak için ihtiyaç duyduğunuz tüm bilgileri Içeren SignalR istemci kodu sağladığınızda.</span><span class="sxs-lookup"><span data-stu-id="33db8-154">When you call the `Start` method in a SignalR client, you are providing SignalR client code with all the information it needs in order to establish a physical connection to a server.</span></span> <span data-ttu-id="33db8-155">SignalR istemci kodu, bir HTTP isteği oluşturmak ve dört taşıma yönteminden birini kullanan fiziksel bir bağlantı kurmak için bu bilgileri kullanır.</span><span class="sxs-lookup"><span data-stu-id="33db8-155">SignalR client code uses this information to make an HTTP request and establish a physical connection that uses one of the four transport methods.</span></span> <span data-ttu-id="33db8-156">Aktarım bağlantısı başarısız olursa veya sunucu başarısız olursa, istemci hala aynı SignalR URL 'sine yönelik yeni bir aktarım bağlantısını otomatik olarak yeniden oluşturmak için gereken bilgileri içerdiğinden, SignalR bağlantısı hemen kaybolur.</span><span class="sxs-lookup"><span data-stu-id="33db8-156">If the transport connection fails or the server fails, the SignalR connection doesn't go away immediately because the client still has the information it needs to automatically re-establish a new transport connection to the same SignalR URL.</span></span> <span data-ttu-id="33db8-157">Bu senaryoda, Kullanıcı uygulamasından bir müdahale yoktur ve SignalR istemci kodu yeni bir aktarım bağlantısı kurduğunda yeni bir SignalR bağlantısı başlatılmaz.</span><span class="sxs-lookup"><span data-stu-id="33db8-157">In this scenario, no intervention from the user application is involved, and when the SignalR client code establishes a new transport connection, it does not start a new SignalR connection.</span></span> <span data-ttu-id="33db8-158">SignalR bağlantısının sürekliliği, yöntemi çağırdığınızda oluşturulan bağlantı KIMLIĞININ değişmemesi durumunda yansıtılır ve `Start` değişiklik yapmaz.</span><span class="sxs-lookup"><span data-stu-id="33db8-158">The continuity of the SignalR connection is reflected in the fact that the connection ID, which is created when you call the `Start` method, does not change.</span></span>

<span data-ttu-id="33db8-159">`OnReconnected`Bir aktarım bağlantısı kaybolduktan sonra otomatik olarak yeniden oluşturulduğunda, hub 'daki olay işleyicisi yürütülür.</span><span class="sxs-lookup"><span data-stu-id="33db8-159">The `OnReconnected` event handler on the Hub executes when a transport connection is automatically re-established after having been lost.</span></span> <span data-ttu-id="33db8-160">`OnDisconnected`Olay işleyicisi bir SignalR bağlantısının sonunda yürütülür.</span><span class="sxs-lookup"><span data-stu-id="33db8-160">The `OnDisconnected` event handler executes at the end of a SignalR connection.</span></span> <span data-ttu-id="33db8-161">Bir SignalR bağlantısı aşağıdaki yollarla bitebilirler:</span><span class="sxs-lookup"><span data-stu-id="33db8-161">A SignalR connection can end in any of the following ways:</span></span>

- <span data-ttu-id="33db8-162">İstemci yöntemi çağırırsa, `Stop` sunucuya bir durdurma iletisi gönderilir ve hem istemci hem de sunucu, SignalR bağlantısını hemen sona erdir.</span><span class="sxs-lookup"><span data-stu-id="33db8-162">If the client calls the `Stop` method, a stop message is sent to the server, and both client and server end the SignalR connection immediately.</span></span>
- <span data-ttu-id="33db8-163">İstemci ve sunucu arasındaki bağlantı kaybolduktan sonra istemci yeniden bağlanmaya çalışır ve sunucu istemcinin yeniden bağlanmasını bekler.</span><span class="sxs-lookup"><span data-stu-id="33db8-163">After connectivity between client and server is lost, the client tries to reconnect and the server waits for the client to reconnect.</span></span> <span data-ttu-id="33db8-164">Yeniden bağlantı girişimleri başarısız olursa ve kesme zaman aşımı süresi sona erdiğinde, hem istemci hem de sunucu SignalR bağlantısını sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="33db8-164">If the attempts to reconnect are unsuccessful and the disconnect timeout period ends, both client and server end the SignalR connection.</span></span> <span data-ttu-id="33db8-165">İstemci yeniden bağlanmaya çalışmayı durduruyor ve sunucu, SignalR bağlantısının temsilini ortadan kaldırmaktadır.</span><span class="sxs-lookup"><span data-stu-id="33db8-165">The client stops trying to reconnect, and the server disposes of its representation of the SignalR connection.</span></span>
- <span data-ttu-id="33db8-166">İstemci, yöntemi çağırma şansı olmadan çalışmayı durdursa `Stop` , sunucu istemcinin yeniden bağlanmasını bekler ve sonra bağlantı kesme zaman aşımı süresinden sonra SignalR bağlantısını sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="33db8-166">If the client stops running without having a chance to call the `Stop` method, the server waits for the client to reconnect, and then ends the SignalR connection after the disconnect timeout period.</span></span>
- <span data-ttu-id="33db8-167">Sunucu çalışmayı durdurduktan sonra, istemci yeniden bağlanmaya çalışır (aktarım bağlantısını yeniden oluşturun) ve ardından kesme zaman aşımı süresinden sonra SignalR bağlantısını sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="33db8-167">If the server stops running, the client tries to reconnect (re-create the transport connection), and then ends the SignalR connection after the disconnect timeout period.</span></span>

<span data-ttu-id="33db8-168">Herhangi bir bağlantı sorunu olmadığında ve Kullanıcı uygulaması, yöntemi çağırarak SignalR bağlantısını sonlandırıyorsa `Stop` , SignalR bağlantısı ve aktarım bağlantısı aynı anda başlar ve biter.</span><span class="sxs-lookup"><span data-stu-id="33db8-168">When there are no connection problems, and the user application ends the SignalR connection by calling the `Stop` method, the SignalR connection and the transport connection begin and end at about the same time.</span></span> <span data-ttu-id="33db8-169">Aşağıdaki bölümlerde diğer senaryolar daha ayrıntılı olarak açıklanır.</span><span class="sxs-lookup"><span data-stu-id="33db8-169">The following sections describe in more detail the other scenarios.</span></span>

<a id="transportdisconnect"></a>

### <a name="transport-disconnection-scenarios"></a><span data-ttu-id="33db8-170">Taşıma bağlantısının kesilmesi senaryoları</span><span class="sxs-lookup"><span data-stu-id="33db8-170">Transport disconnection scenarios</span></span>

<span data-ttu-id="33db8-171">Fiziksel bağlantılar yavaş olabilir veya bağlantıda kesintiler olabilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-171">Physical connections might be slow or there might be interruptions in connectivity.</span></span> <span data-ttu-id="33db8-172">Kesinti uzunluğu gibi faktörlere bağlı olarak, aktarım bağlantısı bırakılmış olabilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-172">Depending on factors such as the length of the interruption, the transport connection might be dropped.</span></span> <span data-ttu-id="33db8-173">SignalR daha sonra aktarım bağlantısını yeniden kurmaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="33db8-173">SignalR then tries to re-establish the transport connection.</span></span> <span data-ttu-id="33db8-174">Bazen aktarım bağlantısı API 'SI kesintiyi algılar ve aktarım bağlantısını bırakır ve SignalR bağlantının kaybolduğunu hemen bulur.</span><span class="sxs-lookup"><span data-stu-id="33db8-174">Sometimes the transport connection API detects the interruption and drops the transport connection, and SignalR finds out immediately that the connection is lost.</span></span> <span data-ttu-id="33db8-175">Diğer senaryolarda, aktarım bağlantısı API 'SI veya SignalR, bağlantının kaybedildiğinden hemen haberdar değildir.</span><span class="sxs-lookup"><span data-stu-id="33db8-175">In other scenarios, neither the transport connection API nor SignalR becomes aware immediately that connectivity has been lost.</span></span> <span data-ttu-id="33db8-176">Uzun yoklama haricinde tüm aktarımlar için, SignalR istemcisi, aktarım API 'sinin algılayamayacağı bağlantı kaybını denetlemek için *KeepAlive* adlı bir işlev kullanır.</span><span class="sxs-lookup"><span data-stu-id="33db8-176">For all transports except long polling, the SignalR client uses a function called *keepalive* to check for loss of connectivity that the transport API is unable to detect.</span></span> <span data-ttu-id="33db8-177">Uzun yoklama bağlantıları hakkında daha fazla bilgi için bu konunun ilerleyen bölümlerindeki [zaman aşımı ve KeepAlive ayarları](#timeoutkeepalive) bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="33db8-177">For information about long polling connections, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

<span data-ttu-id="33db8-178">Bir bağlantı etkin olmadığında, sunucu, düzenli aralıklarla istemciye bir canlı tutma paketi gönderir.</span><span class="sxs-lookup"><span data-stu-id="33db8-178">When a connection is inactive, periodically the server sends a keepalive packet to the client.</span></span> <span data-ttu-id="33db8-179">Bu makalenin yazıldığı tarihten itibaren, varsayılan sıklık her 10 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="33db8-179">As of the date this article is being written, the default frequency is every 10 seconds.</span></span> <span data-ttu-id="33db8-180">İstemciler, bu paketleri dinleyerek bir bağlantı sorunu olup olmadığını söyleyebilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-180">By listening for these packets, clients can tell if there is a connection problem.</span></span> <span data-ttu-id="33db8-181">Beklendiğinde bir KeepAlive paketi alınmadığında, istemci kısa bir süre sonra yavaşlık veya kesintiler gibi bağlantı sorunları olduğunu varsaymaz.</span><span class="sxs-lookup"><span data-stu-id="33db8-181">If a keepalive packet is not received when expected, after a short time the client assumes that there are connection problems such as slowness or interruptions.</span></span> <span data-ttu-id="33db8-182">KeepAlive, daha uzun bir süre sonra alınmadıysa, istemci bağlantının bırakılmakta olduğunu varsayar ve yeniden bağlanmaya çalışmaya başlar.</span><span class="sxs-lookup"><span data-stu-id="33db8-182">If the keepalive is still not received after a longer time, the client assumes that the connection has been dropped, and it begins trying to reconnect.</span></span>

<span data-ttu-id="33db8-183">Aşağıdaki diyagramda, aktarım API 'SI tarafından hemen tanınmayan fiziksel bağlantıyla ilgili sorunlar olduğunda tipik bir senaryoda oluşturulan istemci ve sunucu olayları gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="33db8-183">The following diagram illustrates the client and server events that are raised in a typical scenario when there are problems with the physical connection that aren't immediately recognized by the transport API.</span></span> <span data-ttu-id="33db8-184">Diyagram aşağıdaki durumlar için geçerlidir:</span><span class="sxs-lookup"><span data-stu-id="33db8-184">The diagram applies to the following circumstances:</span></span>

- <span data-ttu-id="33db8-185">Taşıma WebSockets, süresiz çerçeve veya sunucu tarafından gönderilen olaylardır.</span><span class="sxs-lookup"><span data-stu-id="33db8-185">The transport is WebSockets, forever frame, or server-sent events.</span></span>
- <span data-ttu-id="33db8-186">Fiziksel ağ bağlantısında farklı bir kesinti dönemi vardır.</span><span class="sxs-lookup"><span data-stu-id="33db8-186">There are varying periods of interruption in the physical network connection.</span></span>
- <span data-ttu-id="33db8-187">Aktarım API 'SI kesintileri bilmez, bu nedenle SignalR bunları algılamak için canlı tutma işlevselliğine bağımlıdır.</span><span class="sxs-lookup"><span data-stu-id="33db8-187">The transport API does not become aware of the interruptions, so SignalR relies on the keepalive functionality to detect them.</span></span>

![Aktarım bağlantılarını kaldır](handling-connection-lifetime-events/_static/image2.png)

<span data-ttu-id="33db8-189">İstemci yeniden bağlanma moduna geçtiğinde ancak bağlantı kesme zaman aşımı sınırı içinde bir aktarım bağlantısı kuramazsa, sunucu SignalR bağlantısını sonlandırır.</span><span class="sxs-lookup"><span data-stu-id="33db8-189">If the client goes into reconnecting mode but can't establish a transport connection within the disconnect timeout limit, the server terminates the SignalR connection.</span></span> <span data-ttu-id="33db8-190">Bu gerçekleştiğinde sunucu, hub 'ın `OnDisconnected` yöntemini yürütür ve istemcinin daha sonra bağlanmayı yönetmesi durumunda istemciye göndermek için bir bağlantı kesme iletisi gönderir.</span><span class="sxs-lookup"><span data-stu-id="33db8-190">When that happens, the server executes the Hub's `OnDisconnected` method and queues up a disconnect message to send to the client in case the client manages to connect later.</span></span> <span data-ttu-id="33db8-191">İstemci daha sonra yeniden bağlanırsa, bağlantıyı kes komutunu alır ve `Stop` yöntemini çağırır.</span><span class="sxs-lookup"><span data-stu-id="33db8-191">If the client then does reconnect, it receives the disconnect command and calls the `Stop` method.</span></span> <span data-ttu-id="33db8-192">Bu senaryoda, `OnReconnected` istemci yeniden bağlandığında yürütülmez ve `OnDisconnected` istemci çağırdığında yürütülmez `Stop` .</span><span class="sxs-lookup"><span data-stu-id="33db8-192">In this scenario, `OnReconnected` is not executed when the client reconnects, and `OnDisconnected` is not executed when the client calls `Stop`.</span></span> <span data-ttu-id="33db8-193">Aşağıdaki diyagramda bu senaryo gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="33db8-193">The following diagram illustrates this scenario.</span></span>

![Aktarım kesintilerini-sunucu zaman aşımı](handling-connection-lifetime-events/_static/image3.png)

<span data-ttu-id="33db8-195">İstemcide ortaya çıkarılan SignalR bağlantı ömrü olayları şunlardır:</span><span class="sxs-lookup"><span data-stu-id="33db8-195">The SignalR connection lifetime events that may be raised on the client are the following:</span></span>

- <span data-ttu-id="33db8-196">`ConnectionSlow` istemci olayı.</span><span class="sxs-lookup"><span data-stu-id="33db8-196">`ConnectionSlow` client event.</span></span>

    <span data-ttu-id="33db8-197">En son ileti veya KeepAlive ping alındıktan sonra canlı tutma zaman aşımı süresi için önceden ayarlanmış bir oran geçtiğinde tetiklenir.</span><span class="sxs-lookup"><span data-stu-id="33db8-197">Raised when a preset proportion of the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="33db8-198">Varsayılan canlı tutma zaman aşımı uyarı dönemi, KeepAlive zaman aşımının 2/3 ' dir.</span><span class="sxs-lookup"><span data-stu-id="33db8-198">The default keepalive timeout warning period is 2/3 of the keepalive timeout.</span></span> <span data-ttu-id="33db8-199">Canlı tutma zaman aşımı 20 saniyedir, bu nedenle uyarı yaklaşık 13 saniye içinde gerçekleşir.</span><span class="sxs-lookup"><span data-stu-id="33db8-199">The keepalive timeout is 20 seconds, so the warning occurs at about 13 seconds.</span></span>

    <span data-ttu-id="33db8-200">Varsayılan olarak, sunucu her 10 saniyede bir KeepAlive ping gönderir ve istemci, her 2 saniyede bir KeepAlive ping isteği gönderir (KeepAlive zaman aşımı değeri ve KeepAlive zaman aşımı uyarı değeri arasındaki fark).</span><span class="sxs-lookup"><span data-stu-id="33db8-200">By default, the server sends keepalive pings every 10 seconds, and the client checks for keepalive pings about every 2 seconds (one third of the difference between the keepalive timeout value and the keepalive timeout warning value).</span></span>

    <span data-ttu-id="33db8-201">Aktarım API 'sinin bağlantısının kesilmesi durumunda, canlı tutma zaman aşımı uyarı süresi geçmeden önce SignalR bağlantısının kesilmesi hakkında bilgi alabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33db8-201">If the transport API becomes aware of a disconnection, SignalR might be informed of the disconnection before the keepalive timeout warning period passes.</span></span> <span data-ttu-id="33db8-202">Bu durumda, `ConnectionSlow` olay oluşturulmaz ve SignalR doğrudan `Reconnecting` olaya gider.</span><span class="sxs-lookup"><span data-stu-id="33db8-202">In that case, the `ConnectionSlow` event would not be raised, and SignalR would go directly to the `Reconnecting` event.</span></span>
- <span data-ttu-id="33db8-203">`Reconnecting` istemci olayı.</span><span class="sxs-lookup"><span data-stu-id="33db8-203">`Reconnecting` client event.</span></span>

    <span data-ttu-id="33db8-204">(A) aktarım API 'SI bağlantının kaybolduğunu algıladığında veya (b) son ileti veya KeepAlive ping alındıktan sonra canlı tutma zaman aşımı süresi geçtiğinde tetiklenir.</span><span class="sxs-lookup"><span data-stu-id="33db8-204">Raised when (a) the transport API detects that the connection is lost, or (b) the keepalive timeout period has passed since the last message or keepalive ping was received.</span></span> <span data-ttu-id="33db8-205">SignalR istemci kodu yeniden bağlanmaya çalışıyor.</span><span class="sxs-lookup"><span data-stu-id="33db8-205">The SignalR client code begins trying to reconnect.</span></span> <span data-ttu-id="33db8-206">Bir aktarım bağlantısı kesildiğinde uygulamanızın bazı işlemleri yapması istiyorsanız bu olayı işleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33db8-206">You can handle this event if you want your application to take some action when a transport connection is lost.</span></span> <span data-ttu-id="33db8-207">Varsayılan canlı tutma zaman aşımı süresi 20 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="33db8-207">The default keepalive timeout period is currently 20 seconds.</span></span>

    <span data-ttu-id="33db8-208">SignalR yeniden bağlanma modundayken istemci kodunuz bir hub yöntemi çağırmaya çalışırsa, SignalR komutu göndermeyi dener.</span><span class="sxs-lookup"><span data-stu-id="33db8-208">If your client code tries to call a Hub method while SignalR is in reconnecting mode, SignalR will try to send the command.</span></span> <span data-ttu-id="33db8-209">Çoğu zaman, bu tür denemeler başarısız olur, ancak bazı durumlarda başarılı olabilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-209">Most of the time, such attempts will fail, but in some circumstances they might succeed.</span></span> <span data-ttu-id="33db8-210">Sunucu tarafından gönderilen olaylar, süresiz çerçeve ve uzun yoklama aktarımları için, SignalR iki iletişim kanalı kullanır, biri istemcinin iletileri göndermek için kullandığı bir ileti ve iletiyi almak için kullandığı bir tane.</span><span class="sxs-lookup"><span data-stu-id="33db8-210">For the server-sent events, forever frame, and long polling transports, SignalR uses two communication channels, one that the client uses to send messages and one that it uses to receive messages.</span></span> <span data-ttu-id="33db8-211">Alma için kullanılan kanal kalıcı olarak açılır ve fiziksel bağlantı kesintiye uğradığında kapalı olur.</span><span class="sxs-lookup"><span data-stu-id="33db8-211">The channel used for receiving is the permanently open one, and that's the one that is closed when the physical connection is interrupted.</span></span> <span data-ttu-id="33db8-212">Gönderme için kullanılan kanal kullanılabilir durumda kalır, bu nedenle fiziksel bağlantı geri yüklenirse, alma kanalının yeniden kurulması için istemciden sunucuya bir yöntem çağrısı başarılı olabilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-212">The channel used for sending remains available, so if physical connectivity is restored, a method call from client to server might be successful before the receive channel is re-established.</span></span> <span data-ttu-id="33db8-213">SignalR, almak için kullanılan kanalı yeniden açıncaya kadar dönüş değeri alınmaz.</span><span class="sxs-lookup"><span data-stu-id="33db8-213">The return value would not be received until SignalR re-opens the channel used for receiving.</span></span>
- <span data-ttu-id="33db8-214">`Reconnected` istemci olayı.</span><span class="sxs-lookup"><span data-stu-id="33db8-214">`Reconnected` client event.</span></span>

    <span data-ttu-id="33db8-215">Aktarım bağlantısı yeniden kurulduğunda tetiklenir.</span><span class="sxs-lookup"><span data-stu-id="33db8-215">Raised when the transport connection is reestablished.</span></span> <span data-ttu-id="33db8-216">`OnReconnected`Hub 'daki olay işleyicisi yürütülür.</span><span class="sxs-lookup"><span data-stu-id="33db8-216">The `OnReconnected` event handler in the Hub executes.</span></span>
- <span data-ttu-id="33db8-217">`Closed` istemci olayı ( `disconnected` JavaScript 'te olay).</span><span class="sxs-lookup"><span data-stu-id="33db8-217">`Closed` client event (`disconnected` event in JavaScript).</span></span>

    <span data-ttu-id="33db8-218">SignalR istemci kodu aktarım bağlantısını kaybetmeden sonra yeniden bağlanmaya çalışırken kesme zaman aşımı süresi dolduğunda tetiklenir.</span><span class="sxs-lookup"><span data-stu-id="33db8-218">Raised when the disconnect timeout period expires while the SignalR client code is trying to reconnect after losing the transport connection.</span></span> <span data-ttu-id="33db8-219">Varsayılan bağlantı kesme zaman aşımı 30 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="33db8-219">The default disconnect timeout is 30 seconds.</span></span> <span data-ttu-id="33db8-220">(Bu olay Ayrıca, bağlantı sona erdiğinde, yöntem çağrıldığı için de oluşturulur `Stop` .)</span><span class="sxs-lookup"><span data-stu-id="33db8-220">(This event is also raised when the connection ends because the `Stop` method is called.)</span></span>

<span data-ttu-id="33db8-221">Aktarım API 'SI tarafından algılanmayan aktarım bağlantısı kesintileri; canlı tutma zaman aşımı uyarısı süresinden daha uzun bir süre için sunucudan canlı tutma pinglerinin alımına hiçbir bağlantı ömrü olaylarının oluşturulmasına neden olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-221">Transport connection interruptions that are not detected by the transport API and don't delay the reception of keepalive pings from the server for longer than the keepalive timeout warning period might not cause any connection lifetime events to be raised.</span></span>

<span data-ttu-id="33db8-222">Bazı ağ ortamları, boştaki bağlantıları kasıtlı olarak kapatır ve canlı tutma paketlerine ait başka bir işlev, bu ağların bir SignalR bağlantısının kullanımda olduğunu bilmesini sağlayarak bunu önlemeye yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="33db8-222">Some network environments deliberately close idle connections, and another function of the keepalive packets is to help prevent this by letting these networks know that a SignalR connection is in use.</span></span> <span data-ttu-id="33db8-223">Olağanüstü durumlarda, varsayılan canlı tutma ping işlemleri, kapalı bağlantıları engellemek için yeterli olmayabilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-223">In extreme cases the default frequency of keepalive pings might not be enough to prevent closed connections.</span></span> <span data-ttu-id="33db8-224">Bu durumda, canlı tutma pingleri daha sık gönderilmek üzere yapılandırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33db8-224">In that case you can configure keepalive pings to be sent more often.</span></span> <span data-ttu-id="33db8-225">Daha fazla bilgi için bu konunun ilerleyen kısımlarında [zaman aşımı ve KeepAlive ayarları](#timeoutkeepalive) bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="33db8-225">For more information, see [Timeout and keepalive settings](#timeoutkeepalive) later in this topic.</span></span>

> [!NOTE]
>
> <span data-ttu-id="33db8-226">**Önemli**: burada açıklanan olay sırası garanti edilmez.</span><span class="sxs-lookup"><span data-stu-id="33db8-226">**Important**: The sequence of events described here is not guaranteed.</span></span> <span data-ttu-id="33db8-227">SignalR her zaman, bu düzene göre öngörülebilir bir şekilde bağlantı ömrü olayları oluşturma girişiminde bulunur, ancak ağ olaylarının çok çeşitli çeşitlemeleri ve taşıma API 'Leri gibi temel iletişim çerçevelerinin bunları işlemesi gibi birçok yol vardır.</span><span class="sxs-lookup"><span data-stu-id="33db8-227">SignalR makes every attempt to raise connection lifetime events in a predictable manner according to this scheme, but there are many variations of network events and many ways in which underlying communications frameworks such as transport APIs handle them.</span></span> <span data-ttu-id="33db8-228">Örneğin, `Reconnected` istemci yeniden bağlandığında olay çıkarılmayabilir veya `OnConnected` bağlantı kurma girişimi başarısız olduğunda sunucudaki işleyici çalıştırılabilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-228">For example, the `Reconnected` event might not be raised when the client reconnects, or the `OnConnected` handler on the server might run when the attempt to establish a connection is unsuccessful.</span></span> <span data-ttu-id="33db8-229">Bu konu, yalnızca belirli tipik koşullarda normalde üretilmekte olan etkileri açıklamaktadır.</span><span class="sxs-lookup"><span data-stu-id="33db8-229">This topic describes only the effects that would normally be produced by certain typical circumstances.</span></span>

<a id="clientdisconnect"></a>

### <a name="client-disconnection-scenarios"></a><span data-ttu-id="33db8-230">İstemci bağlantısının kesilmesi senaryoları</span><span class="sxs-lookup"><span data-stu-id="33db8-230">Client disconnection scenarios</span></span>

<span data-ttu-id="33db8-231">Bir tarayıcı istemcisinde, bir SignalR bağlantısını koruyan SignalR istemci kodu bir Web sayfasının JavaScript bağlamında çalışır.</span><span class="sxs-lookup"><span data-stu-id="33db8-231">In a browser client, the SignalR client code that maintains a SignalR connection runs in the JavaScript context of a web page.</span></span> <span data-ttu-id="33db8-232">Bu nedenle, bir sayfadan diğerine gittiğinizde SignalR bağlantısının bitmesi ve birden çok tarayıcı penceresi veya sekmeden bağlanıyorsanız birden çok bağlantı kimliğiyle birden çok bağlantınız olması neden vardır.</span><span class="sxs-lookup"><span data-stu-id="33db8-232">That's why the SignalR connection has to end when you navigate from one page to another, and that's why you have multiple connections with multiple connection IDs if you connect from multiple browser windows or tabs.</span></span> <span data-ttu-id="33db8-233">Kullanıcı bir tarayıcı penceresini veya sekmeyi kapattığında veya yeni bir sayfaya gittiğinde veya sayfayı yenilediğinde, SignalR istemci kodu bu tarayıcı olayını sizin için işlediği ve yöntemi çağıran için SignalR bağlantısı hemen sona erer `Stop` .</span><span class="sxs-lookup"><span data-stu-id="33db8-233">When the user closes a browser window or tab, or navigates to a new page or refreshes the page, the SignalR connection immediately ends because SignalR client code handles that browser event for you and calls the `Stop` method.</span></span> <span data-ttu-id="33db8-234">Bu senaryolarda veya uygulamanız yöntemini çağırdığında, `Stop` `OnDisconnected` olay işleyicisi sunucuda hemen yürütülür ve istemci `Closed` olayı başlatır (olay `disconnected` JavaScript 'te adlandırılır).</span><span class="sxs-lookup"><span data-stu-id="33db8-234">In these scenarios, or in any client platform when your application calls the `Stop` method, the `OnDisconnected` event handler executes immediately on the server and the client raises the `Closed` event (the event is named `disconnected` in JavaScript).</span></span>

<span data-ttu-id="33db8-235">Bir istemci uygulaması veya üzerinde çalıştığı bilgisayar kilitlenirse veya uyku moduna geçtiğinde (örneğin, Kullanıcı dizüstü bilgisayarı kapattığında), sunucu ne olduğunu bilgilenmez.</span><span class="sxs-lookup"><span data-stu-id="33db8-235">If a client application or the computer that it's running on crashes or goes to sleep (for example, when the user closes the laptop), the server is not informed about what happened.</span></span> <span data-ttu-id="33db8-236">Sunucu bildiği kadar, istemcinin kaybı bağlantı kesintiden kaynaklanabilir ve istemci yeniden bağlanmaya çalışıyor olabilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-236">As far as the server knows, the loss of the client might be due to connectivity interruption and the client might be trying to reconnect.</span></span> <span data-ttu-id="33db8-237">Bu nedenle, bu senaryolarda sunucu istemciye yeniden bağlanma şansı vermenizi bekler ve `OnDisconnected` kesme zaman aşımı süresi dolana kadar (varsayılan olarak yaklaşık 30 saniye) yürütülmez.</span><span class="sxs-lookup"><span data-stu-id="33db8-237">Therefore, in these scenarios the server waits to give the client a chance to reconnect, and `OnDisconnected` does not execute until the disconnect timeout period expires (about 30 seconds by default).</span></span> <span data-ttu-id="33db8-238">Aşağıdaki diyagramda bu senaryo gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="33db8-238">The following diagram illustrates this scenario.</span></span>

![İstemci bilgisayar hatası](handling-connection-lifetime-events/_static/image4.png)

<a id="serverdisconnect"></a>

### <a name="server-disconnection-scenarios"></a><span data-ttu-id="33db8-240">Sunucu bağlantısı kesme senaryoları</span><span class="sxs-lookup"><span data-stu-id="33db8-240">Server disconnection scenarios</span></span>

<span data-ttu-id="33db8-241">Bir sunucu çevrimdışı olduğunda, yeniden başlatılır, başarısız olur, uygulama etki alanı geri dönüştürme, vb.--sonuç, kayıp bir bağlantıya benzer olabilir veya aktarım API 'SI ile SignalR, olayın hemen bir bağlantı kurmaya başlayabilir ve SignalR, olayı oluşturmadan yeniden bağlanmayı deniyor olabilir `ConnectionSlow` .</span><span class="sxs-lookup"><span data-stu-id="33db8-241">When a server goes offline -- it reboots, fails, the app domain recycles, etc. -- the result might be similar to a lost connection, or the transport API and SignalR might know immediately that the server is gone, and SignalR might begin trying to reconnect without raising the `ConnectionSlow` event.</span></span> <span data-ttu-id="33db8-242">İstemci yeniden bağlama moduna geçtiğinde ve sunucu kurtarıldığında veya yeniden başlatılırsa veya bağlantı kesme zaman aşımı süresi dolmadan önce yeni bir sunucu çevrimiçi hale getirildiyse, istemci geri yüklenen veya yeni sunucuya yeniden bağlanır.</span><span class="sxs-lookup"><span data-stu-id="33db8-242">If the client goes into reconnecting mode, and if the server recovers or restarts or a new server is brought online before the disconnect timeout period expires, the client will reconnect to the restored or new server.</span></span> <span data-ttu-id="33db8-243">Bu durumda, SignalR bağlantısı istemci üzerinde devam eder ve `Reconnected` olay tetiklenir.</span><span class="sxs-lookup"><span data-stu-id="33db8-243">In that case, the SignalR connection continues on the client and the `Reconnected` event is raised.</span></span> <span data-ttu-id="33db8-244">İlk sunucuda, hiçbir şekilde `OnDisconnected` yürütülmez ve yeni sunucuda, daha `OnReconnected` `OnConnected` önce o sunucuda bu istemci için hiç yürütülmedi de yürütülür.</span><span class="sxs-lookup"><span data-stu-id="33db8-244">On the first server, `OnDisconnected` is never executed, and on the new server, `OnReconnected` is executed although `OnConnected` was never executed for that client on that server before.</span></span> <span data-ttu-id="33db8-245">(Bir yeniden başlatma veya uygulama etki alanı geri dönüştürme sonrasında istemci aynı sunucuya yeniden bağlanırsa, bu, sunucu yeniden başlatıldığında önceki bağlantı etkinlikinden bellek olmadığından, bu efekt aynıdır.) Aşağıdaki diyagramda, taşıma API 'sinin kayıp bağlantıyı hemen haberdar ettiğini varsayar, bu nedenle `ConnectionSlow` olay oluşturulmaz.</span><span class="sxs-lookup"><span data-stu-id="33db8-245">(The effect is the same if the client reconnects to the same server after a reboot or app domain recycle, because when the server restarts it has no memory of prior connection activity.) The following diagram assumes that the transport API becomes aware of the lost connection immediately, so the `ConnectionSlow` event is not raised.</span></span>

![Sunucu hatası ve yeniden bağlantı](handling-connection-lifetime-events/_static/image5.png)

<span data-ttu-id="33db8-247">Bir sunucu, bağlantı kesme zaman aşımı süresi içinde kullanılabilir duruma gelmezse, SignalR bağlantısı sona erer.</span><span class="sxs-lookup"><span data-stu-id="33db8-247">If a server does not become available within the disconnect timeout period, the SignalR connection ends.</span></span> <span data-ttu-id="33db8-248">Bu senaryoda, `Closed` Olay ( `disconnected` JavaScript istemcilerindeki) istemcide oluşturulur ancak `OnDisconnected` sunucuda hiçbir şekilde çağrılmaz.</span><span class="sxs-lookup"><span data-stu-id="33db8-248">In this scenario, the `Closed` event (`disconnected` in JavaScript clients) is raised on the client but `OnDisconnected` is never called on the server.</span></span> <span data-ttu-id="33db8-249">Aşağıdaki diyagramda, aktarım API 'sinin kayıp bağlantıyı bilmeyeceği varsayılmaktadır. bu nedenle, SignalR KeepAlive işlevselliği tarafından algılanır ve `ConnectionSlow` olay tetiklenir.</span><span class="sxs-lookup"><span data-stu-id="33db8-249">The following diagram assumes that the transport API does not become aware of the lost connection, so it is detected by SignalR keepalive functionality and the `ConnectionSlow` event is raised.</span></span>

![Sunucu hatası ve zaman aşımı](handling-connection-lifetime-events/_static/image6.png)

<a id="timeoutkeepalive"></a>

## <a name="timeout-and-keepalive-settings"></a><span data-ttu-id="33db8-251">Zaman aşımı ve KeepAlive ayarları</span><span class="sxs-lookup"><span data-stu-id="33db8-251">Timeout and keepalive settings</span></span>

<span data-ttu-id="33db8-252">Varsayılan `ConnectionTimeout` , `DisconnectTimeout` ve `KeepAlive` değerleri çoğu senaryo için uygundur, ancak ortamınız özel gereksinimleriniz varsa bu değiştirilebilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-252">The default `ConnectionTimeout`, `DisconnectTimeout`, and `KeepAlive` values are appropriate for most scenarios but can be changed if your environment has special needs.</span></span> <span data-ttu-id="33db8-253">Örneğin, ağ ortamınız 5 saniye boyunca boşta olan bağlantıları kapatırsa, KeepAlive değerini azaltmayı düşünebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33db8-253">For example, if your network environment closes connections that are idle for 5 seconds, you might have to decrease the keepalive value.</span></span>

<a id="connectiontimeout"></a>

### <a name="connectiontimeout"></a><span data-ttu-id="33db8-254">ConnectionTimeout</span><span class="sxs-lookup"><span data-stu-id="33db8-254">ConnectionTimeout</span></span>

<span data-ttu-id="33db8-255">Bu ayar, bir aktarım bağlantısının açık olarak ayrılma ve kapatmadan önce yanıt beklerken yeni bir bağlantı açılmadan önce bir yanıt beklediği süreyi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="33db8-255">This setting represents the amount of time to leave a transport connection open and waiting for a response before closing it and opening a new connection.</span></span> <span data-ttu-id="33db8-256">Varsayılan değer 110 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="33db8-256">The default value is 110 seconds.</span></span>

<span data-ttu-id="33db8-257">Bu ayar yalnızca, normal olarak yalnızca uzun yoklama taşıması için geçerli olan KeepAlive işlevselliği devre dışı bırakıldığında geçerlidir.</span><span class="sxs-lookup"><span data-stu-id="33db8-257">This setting applies only when keepalive functionality is disabled, which normally applies only to the long polling transport.</span></span> <span data-ttu-id="33db8-258">Aşağıdaki diyagramda, bu ayarın uzun bir yoklama aktarımı bağlantısında etkileri gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="33db8-258">The following diagram illustrates the effect of this setting on a long polling transport connection.</span></span>

![Uzun yoklama taşıma bağlantısı](handling-connection-lifetime-events/_static/image7.png)

<a id="disconnecttimeout"></a>

### <a name="disconnecttimeout"></a><span data-ttu-id="33db8-260">DisconnectTimeout</span><span class="sxs-lookup"><span data-stu-id="33db8-260">DisconnectTimeout</span></span>

<span data-ttu-id="33db8-261">Bu ayar, olayı oluşturmadan önce bir aktarım bağlantısı kaybolduktan sonra beklenecek süreyi temsil eder `Disconnected` .</span><span class="sxs-lookup"><span data-stu-id="33db8-261">This setting represents the amount of time to wait after a transport connection is lost before raising the `Disconnected` event.</span></span> <span data-ttu-id="33db8-262">Varsayılan değer 30 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="33db8-262">The default value is 30 seconds.</span></span> <span data-ttu-id="33db8-263">Ayarladığınızda `DisconnectTimeout` , `KeepAlive` otomatik olarak değerin 1/3 olarak ayarlanır `DisconnectTimeout` .</span><span class="sxs-lookup"><span data-stu-id="33db8-263">When you set `DisconnectTimeout`, `KeepAlive` is automatically set to 1/3 of the `DisconnectTimeout` value.</span></span>

<a id="keepalive"></a>

### <a name="keepalive"></a><span data-ttu-id="33db8-264">Alı</span><span class="sxs-lookup"><span data-stu-id="33db8-264">KeepAlive</span></span>

<span data-ttu-id="33db8-265">Bu ayar, boştaki bir bağlantı üzerinden bir KeepAlive paketi gönderilmeden önce beklenecek süreyi temsil eder.</span><span class="sxs-lookup"><span data-stu-id="33db8-265">This setting represents the amount of time to wait before sending a keepalive packet over an idle connection.</span></span> <span data-ttu-id="33db8-266">Varsayılan değer 10 saniyedir.</span><span class="sxs-lookup"><span data-stu-id="33db8-266">The default value is 10 seconds.</span></span> <span data-ttu-id="33db8-267">Bu değer değerin 1/3 ' inden büyük olmamalıdır `DisconnectTimeout` .</span><span class="sxs-lookup"><span data-stu-id="33db8-267">This value must not be more than 1/3 of the `DisconnectTimeout` value.</span></span>

<span data-ttu-id="33db8-268">Hem hem de ayarlamak istiyorsanız `DisconnectTimeout` `KeepAlive` , `KeepAlive` öğesinden sonra ayarlayın `DisconnectTimeout` .</span><span class="sxs-lookup"><span data-stu-id="33db8-268">If you want to set both `DisconnectTimeout` and `KeepAlive`, set `KeepAlive` after `DisconnectTimeout`.</span></span> <span data-ttu-id="33db8-269">Aksi takdirde `KeepAlive` `DisconnectTimeout` `KeepAlive` , zaman aşımı değerinin otomatik olarak 1/3 olarak ayarlandığında ayarınız üzerine yazılır.</span><span class="sxs-lookup"><span data-stu-id="33db8-269">Otherwise your `KeepAlive` setting will be overwritten when `DisconnectTimeout` automatically sets `KeepAlive` to 1/3 of the timeout value.</span></span>

<span data-ttu-id="33db8-270">Canlı tutma işlevini devre dışı bırakmak istiyorsanız, `KeepAlive` null olarak ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="33db8-270">If you want to disable keepalive functionality, set `KeepAlive` to null.</span></span> <span data-ttu-id="33db8-271">Canlı tutma işlevleri uzun yoklama taşıması için otomatik olarak devre dışıdır.</span><span class="sxs-lookup"><span data-stu-id="33db8-271">Keepalive functionality is automatically disabled for the long polling transport.</span></span>

<a id="changetimeout"></a>

### <a name="how-to-change-timeout-and-keepalive-settings"></a><span data-ttu-id="33db8-272">Zaman aşımı ve KeepAlive ayarlarını değiştirme</span><span class="sxs-lookup"><span data-stu-id="33db8-272">How to change timeout and keepalive settings</span></span>

<span data-ttu-id="33db8-273">Bu ayarların varsayılan değerlerini değiştirmek için, `Application_Start` Aşağıdaki örnekte gösterildiği gibi bunları *Global. asax* dosyanızda ayarlayın.</span><span class="sxs-lookup"><span data-stu-id="33db8-273">To change the default values for these settings, set them in `Application_Start` in your *Global.asax* file, as shown in the following example.</span></span> <span data-ttu-id="33db8-274">Örnek kodda gösterilen değerler varsayılan değerlerle aynıdır.</span><span class="sxs-lookup"><span data-stu-id="33db8-274">The values shown in the sample code are the same as the default values.</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample1.cs)]

<a id="notifydisconnect"></a>

## <a name="how-to-notify-the-user-about-disconnections"></a><span data-ttu-id="33db8-275">Kullanıcıya, bağlantısı kesilme hakkında bildirme</span><span class="sxs-lookup"><span data-stu-id="33db8-275">How to notify the user about disconnections</span></span>

<span data-ttu-id="33db8-276">Bazı uygulamalarda, bağlantı sorunları olduğunda kullanıcıya bir ileti görüntülenmesini isteyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33db8-276">In some applications you might want to display a message to the user when there are connectivity problems.</span></span> <span data-ttu-id="33db8-277">Bunun nasıl ve ne zaman yapılacağı konusunda birkaç seçeneğiniz vardır.</span><span class="sxs-lookup"><span data-stu-id="33db8-277">You have several options for how and when to do this.</span></span> <span data-ttu-id="33db8-278">Aşağıdaki kod örnekleri, oluşturulan proxy kullanan bir JavaScript istemcisi içindir.</span><span class="sxs-lookup"><span data-stu-id="33db8-278">The following code samples are for a JavaScript client using the generated proxy.</span></span>

- <span data-ttu-id="33db8-279">`connectionSlow`SignalR bağlantı sorunlarından haberdar olduğu anda, yeniden bağlanma moduna geçmeden önce bir iletiyi göstermek için olayı işleyin.</span><span class="sxs-lookup"><span data-stu-id="33db8-279">Handle the `connectionSlow` event to display a message as soon as SignalR is aware of connection problems, before it goes into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample2.js)]
- <span data-ttu-id="33db8-280">`reconnecting`SignalR 'nin bir bağlantısının kesilmesi olduğu ve yeniden bağlama moduna aldığı durumlarda bir iletiyi göstermek için olayı işleyin.</span><span class="sxs-lookup"><span data-stu-id="33db8-280">Handle the `reconnecting` event to display a message when SignalR is aware of a disconnection and is going into reconnecting mode.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample3.js)]
- <span data-ttu-id="33db8-281">`disconnected`Yeniden bağlanma girişimi zaman aşımına uğradığından bir iletiyi göstermek için olayı işleyin. Bu senaryoda, sunucuyla yeniden bağlantı kurmayı sağlayan tek yol, yöntemi çağırarak SignalR bağlantısını yeniden başlatmaktan `Start` sonra yeni bir bağlantı kimliği oluşturacak.</span><span class="sxs-lookup"><span data-stu-id="33db8-281">Handle the `disconnected` event to display a message when an attempt to reconnect has timed out. In this scenario, the only way to re-establish a connection with the server again is to restart the SignalR connection by calling the `Start` method, which will create a new connection ID.</span></span> <span data-ttu-id="33db8-282">Aşağıdaki kod örneği, yöntemi çağırarak SignalR bağlantısına normal bir uçtan sonra değil, bildirimi yalnızca yeniden bağlama zaman aşımından sonra yayıntığınızdan emin olmak için bir bayrak kullanır `Stop` .</span><span class="sxs-lookup"><span data-stu-id="33db8-282">The following code sample uses a flag to make sure that you issue the notification only after a reconnecting timeout, not after a normal end to the SignalR connection caused by calling the `Stop` method.</span></span>

    [!code-javascript[Main](handling-connection-lifetime-events/samples/sample4.js)]

<a id="continuousreconnect"></a>

## <a name="how-to-continuously-reconnect"></a><span data-ttu-id="33db8-283">Sürekli yeniden bağlanma</span><span class="sxs-lookup"><span data-stu-id="33db8-283">How to continuously reconnect</span></span>

<span data-ttu-id="33db8-284">Bazı uygulamalarda, kaybolduktan sonra otomatik olarak yeniden bağlantı kurmak isteyebilirsiniz ve yeniden bağlanma girişimi zaman aşımına uğradı. Bunu yapmak için `Start` `Closed` olay işleyicinizden ( `disconnected` JavaScript istemcilerindeki olay işleyicisi) yöntemi çağırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="33db8-284">In some applications you might want to automatically re-establish a connection after it has been lost and the attempt to reconnect has timed out. To do that, you can call the `Start` method from your `Closed` event handler (`disconnected` event handler on JavaScript clients).</span></span> <span data-ttu-id="33db8-285">`Start`Sunucu veya fiziksel bağlantı kullanılamadığında bunu çok sık yapmamak için çağrılmadan önce bir süre beklemeniz gerekebilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-285">You might want to wait a period of time before calling `Start` in order to avoid doing this too frequently when the server or the physical connection are unavailable.</span></span> <span data-ttu-id="33db8-286">Aşağıdaki kod örneği, oluşturulan proxy kullanan bir JavaScript istemcisi içindir.</span><span class="sxs-lookup"><span data-stu-id="33db8-286">The following code sample is for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample5.js)]

<span data-ttu-id="33db8-287">Mobil istemcilerde farkında olabilecek olası bir sorun, sunucu veya fiziksel bağlantı kullanılamadığında sürekli yeniden bağlanma girişimlerinin gereksiz pil boşaltmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-287">A potential problem to be aware of in mobile clients is that continuous reconnection attempts when the server or physical connection isn't available could cause unnecessary battery drain.</span></span>

<a id="disconnectclientfromserver"></a>

## <a name="how-to-disconnect-a-client-in-server-code"></a><span data-ttu-id="33db8-288">Sunucu kodundaki bir istemcinin bağlantısını kesme</span><span class="sxs-lookup"><span data-stu-id="33db8-288">How to disconnect a client in server code</span></span>

<span data-ttu-id="33db8-289">SignalR sürüm 2 ' nin, istemcilerin bağlantısını kesmek için yerleşik bir sunucu API 'SI yoktur.</span><span class="sxs-lookup"><span data-stu-id="33db8-289">SignalR version 2 does not have a built-in server API for disconnecting clients.</span></span> <span data-ttu-id="33db8-290">[Gelecekte bu işlevselliği eklemeye yönelik planlar](https://github.com/SignalR/SignalR/issues/2101)vardır.</span><span class="sxs-lookup"><span data-stu-id="33db8-290">There are [plans for adding this functionality in the future](https://github.com/SignalR/SignalR/issues/2101).</span></span> <span data-ttu-id="33db8-291">Geçerli SignalR sürümünde, bir istemcinin sunucudan bağlantısının en kolay yolu, istemcide bir bağlantı kesme yöntemi uygulamak ve bu yöntemi sunucudan çağırmanız kullanmaktır.</span><span class="sxs-lookup"><span data-stu-id="33db8-291">In the current SignalR release, the simplest way to disconnect a client from the server is to implement a disconnect method on the client and call that method from the server.</span></span> <span data-ttu-id="33db8-292">Aşağıdaki kod örneğinde, oluşturulan proxy 'yi kullanan bir JavaScript istemcisi için bir bağlantı kesme yöntemi gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="33db8-292">The following code sample shows a disconnect method for a JavaScript client using the generated proxy.</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample6.js)]

> [!WARNING]
> <span data-ttu-id="33db8-293">Güvenlik-istemcilerin bağlantısının kesilmesinin veya sunulan yerleşik API 'nin bu yöntemi, kötü amaçlı kod çalıştıran, güvenli olmayan istemci senaryosuna yöneliktir, çünkü istemciler yeniden bağlanır veya güvenliği çıkarılan kod `stopClient` yöntemi kaldırabilir veya BT 'nin yaptığı şeyi değiştirebilir.</span><span class="sxs-lookup"><span data-stu-id="33db8-293">Security - Neither this method for disconnecting clients nor the proposed built-in API will address the scenario of hacked clients that are running malicious code, since the clients could reconnect or the hacked code might remove the `stopClient` method or change what it does.</span></span> <span data-ttu-id="33db8-294">Durum bilgisi olmayan hizmet reddi (DOS) korumasını uygulamak için uygun yer, çerçeve veya sunucu katmanında değil, ön uç altyapısında değildir.</span><span class="sxs-lookup"><span data-stu-id="33db8-294">The appropriate place to implement stateful denial-of-service (DOS) protection is not in the framework or the server layer, but rather in front-end infrastructure.</span></span>

<a id="detectingreasonfordisconnection"></a>
## <a name="detecting-the-reason-for-a-disconnection"></a><span data-ttu-id="33db8-295">Bağlantısının kesilmesi nedenini algılama</span><span class="sxs-lookup"><span data-stu-id="33db8-295">Detecting the reason for a disconnection</span></span>

<span data-ttu-id="33db8-296">SignalR 2,1, sunucu olayına, istemcinin zaman `OnDisconnect` aşımı yerine kasıtlı olarak kesileceğini belirten bir aşırı yükleme ekler. `StopCalled` İstemci bağlantıyı açıkça kapatrsa parametresi true olur.</span><span class="sxs-lookup"><span data-stu-id="33db8-296">SignalR 2.1 adds an overload to the server `OnDisconnect` event that indicates if the client deliberately disconnected rather than timing out. The `StopCalled` parameter is true if the client explicitly closed the connection.</span></span> <span data-ttu-id="33db8-297">JavaScript 'te, bir sunucu hatası istemciye bağlantıyı kesmeye karşı, hata bilgileri istemciye geçirilir `$.connection.hub.lastError` .</span><span class="sxs-lookup"><span data-stu-id="33db8-297">In JavaScript, if a server error led the client to disconnect, the error information will be passed to the client as `$.connection.hub.lastError`.</span></span>

<span data-ttu-id="33db8-298">**C# sunucu kodu: `stopCalled` parametre**</span><span class="sxs-lookup"><span data-stu-id="33db8-298">**C# server code: `stopCalled` parameter**</span></span>

[!code-csharp[Main](handling-connection-lifetime-events/samples/sample7.cs?highlight=1,3)]

<span data-ttu-id="33db8-299">**JavaScript istemci kodu: `lastError` `disconnect` olaya erişme.**</span><span class="sxs-lookup"><span data-stu-id="33db8-299">**JavaScript client code: accessing `lastError` in the `disconnect` event.**</span></span>

[!code-javascript[Main](handling-connection-lifetime-events/samples/sample8.js?highlight=2-3)]
