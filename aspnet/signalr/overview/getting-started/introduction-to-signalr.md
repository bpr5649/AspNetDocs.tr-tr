---
uid: signalr/overview/getting-started/introduction-to-signalr
title: SignalR'a Giriş | Microsoft Dokümanlar
author: bradygaster
description: Bu makalede SignalR'ın ne olduğu ve oluşturmak için tasarladığı çözümlerden bazıları açıklanmaktadır.
ms.author: bradyg
ms.date: 06/10/2014
ms.assetid: 0fab5e35-8c1f-43d4-8635-b8aba8766a71
msc.legacyurl: /signalr/overview/getting-started/introduction-to-signalr
msc.type: authoredcontent
ms.openlocfilehash: 8dbc31a5c8d59fa55dc5b513c1a51d24d18a685f
ms.sourcegitcommit: ce28244209db8615bc9bdd576a2e2c88174d318d
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 04/06/2020
ms.locfileid: "80676351"
---
# <a name="introduction-to-signalr"></a><span data-ttu-id="439df-103">SignalR’a Giriş</span><span class="sxs-lookup"><span data-stu-id="439df-103">Introduction to SignalR</span></span>

<span data-ttu-id="439df-104">tarafından [Patrick Fletcher](https://github.com/pfletcher)</span><span class="sxs-lookup"><span data-stu-id="439df-104">by [Patrick Fletcher](https://github.com/pfletcher)</span></span>

[!INCLUDE [Consider ASP.NET Core SignalR](~/includes/signalr/signalr-version-disambiguation.md)]

> <span data-ttu-id="439df-105">Bu makalede SignalR'ın ne olduğu ve oluşturmak için tasarladığı çözümlerden bazıları açıklanmaktadır.</span><span class="sxs-lookup"><span data-stu-id="439df-105">This article describes what SignalR is, and some of the solutions it was designed to create.</span></span> 
> 
> ## <a name="questions-and-comments"></a><span data-ttu-id="439df-106">Sorular ve yorumlar</span><span class="sxs-lookup"><span data-stu-id="439df-106">Questions and comments</span></span>
> 
> <span data-ttu-id="439df-107">Lütfen bu öğreticiyi nasıl beğendiğiniz ve sayfanın altındaki yorumlarda neler geliştirebileceğimiz hakkında geri bildirim de bırakın.</span><span class="sxs-lookup"><span data-stu-id="439df-107">Please leave feedback on how you liked this tutorial and what we could improve in the comments at the bottom of the page.</span></span> <span data-ttu-id="439df-108">Öğreticiyle doğrudan ilgili olmayan sorularınız varsa, bunları ASP.NET [SignalR forumuna](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) veya [StackOverflow.com](https://stackoverflow.com/questions/tagged/signalr)gönderebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="439df-108">If you have questions that are not directly related to the tutorial, you can post them to the [ASP.NET SignalR forum](https://forums.asp.net/1254.aspx/1?ASP+NET+SignalR) or [StackOverflow.com](https://stackoverflow.com/questions/tagged/signalr).</span></span>

## <a name="what-is-signalr"></a><span data-ttu-id="439df-109">SignalR nedir?</span><span class="sxs-lookup"><span data-stu-id="439df-109">What is SignalR?</span></span>

<span data-ttu-id="439df-110">ASP.NET SignalR, ASP.NET geliştiriciler için, uygulamalara gerçek zamanlı web işlevselliği ekleme işlemini kolaylaştıran bir kitaplıktır.</span><span class="sxs-lookup"><span data-stu-id="439df-110">ASP.NET SignalR is a library for ASP.NET developers that simplifies the process of adding real-time web functionality to applications.</span></span> <span data-ttu-id="439df-111">Gerçek zamanlı web işlevi, sunucunun istemcinin yeni veri istemesini beklemesi yerine, sunucu kodunun içeriği kullanılabilir hale geldiğinde bağlı istemcilere anında itme sidir.</span><span class="sxs-lookup"><span data-stu-id="439df-111">Real-time web functionality is the ability to have server code push content to connected clients instantly as it becomes available, rather than having the server wait for a client to request new data.</span></span>

<span data-ttu-id="439df-112">SignalR, ASP.NET uygulamanıza her türlü "gerçek zamanlı" web işlevselliği eklemek için kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="439df-112">SignalR can be used to add any sort of "real-time" web functionality to your ASP.NET application.</span></span> <span data-ttu-id="439df-113">Sohbet genellikle bir örnek olarak kullanılırken, çok daha fazlasını yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="439df-113">While chat is often used as an example, you can do a whole lot more.</span></span> <span data-ttu-id="439df-114">Bir kullanıcı yeni verileri görmek için bir web sayfasını yenilese veya sayfa yeni veri almak için [uzun yoklama](http://en.wikipedia.org/wiki/Push_technology#Long_polling) lar uyguladığında, SignalR'ı kullanmaya aday olur.</span><span class="sxs-lookup"><span data-stu-id="439df-114">Any time a user refreshes a web page to see new data, or the page implements [long polling](http://en.wikipedia.org/wiki/Push_technology#Long_polling) to retrieve new data, it is a candidate for using SignalR.</span></span> <span data-ttu-id="439df-115">Örnekler arasında panolar ve izleme uygulamaları, ortak uygulamalar (belgelerin eşzamanlı olarak düzenlenmesi gibi), iş ilerleme güncelleştirmeleri ve gerçek zamanlı formlar yer almaktadır.</span><span class="sxs-lookup"><span data-stu-id="439df-115">Examples include dashboards and monitoring applications, collaborative applications (such as simultaneous editing of documents), job progress updates, and real-time forms.</span></span>

<span data-ttu-id="439df-116">SignalR ayrıca sunucudan yüksek frekansgüncellemeleri gerektiren tamamen yeni web uygulamaları türlerine de olanak tanır, örneğin gerçek zamanlı oyun.</span><span class="sxs-lookup"><span data-stu-id="439df-116">SignalR also enables completely new types of web applications that require high frequency updates from the server, for example, real-time gaming.</span></span>

<span data-ttu-id="439df-117">SignalR, sunucu tarafındaki .NET kodundan istemci tarayıcılarında (ve diğer istemci platformlarında) JavaScript işlevlerini çağıran sunucudan istemciye uzak yordam çağrıları (RPC) oluşturmak için basit bir API sağlar.</span><span class="sxs-lookup"><span data-stu-id="439df-117">SignalR provides a simple API for creating server-to-client remote procedure calls (RPC) that call JavaScript functions in client browsers (and other client platforms) from server-side .NET code.</span></span> <span data-ttu-id="439df-118">SignalR ayrıca bağlantı yönetimi (örneğin, bağlantı ve bağlantı bağlantılarını ayırmak) ve bağlantıları gruplandırma için API'yi de içerir.</span><span class="sxs-lookup"><span data-stu-id="439df-118">SignalR also includes API for connection management (for instance, connect and disconnect events), and grouping connections.</span></span>

![SignalR ile çekme yöntemleri](introduction-to-signalr/_static/image1.png)

<span data-ttu-id="439df-120">SignalR, bağlantı yönetimini otomatik olarak işler ve bir sohbet odasında olduğu gibi, iletileri bağlı tüm istemcilere yayınlamanıza olanak tanır.</span><span class="sxs-lookup"><span data-stu-id="439df-120">SignalR handles connection management automatically, and lets you broadcast messages to all connected clients simultaneously, like a chat room.</span></span> <span data-ttu-id="439df-121">İletileri belirli istemcilere de gönderebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="439df-121">You can also send messages to specific clients.</span></span> <span data-ttu-id="439df-122">Bağlantının her iletişimde tekrar kurulduğu klasik bir HTTP bağlantısının aksine, istemci ve sunucu arasındaki bağlantı kalıcıdır.</span><span class="sxs-lookup"><span data-stu-id="439df-122">The connection between the client and server is persistent, unlike a classic HTTP connection, which is re-established for each communication.</span></span>

<span data-ttu-id="439df-123">SignalR, sunucu kodunun bugün web'de yaygın olan istek yanıt modeli yerine Uzaktan Yordam Çağrıları (RPC) kullanarak tarayıcıdaki istemci koduna çağrılabildiği "sunucu itme" işlevini destekler.</span><span class="sxs-lookup"><span data-stu-id="439df-123">SignalR supports "server push" functionality, in which server code can call out to client code in the browser using Remote Procedure Calls (RPC), rather than the request-response model common on the web today.</span></span>

<span data-ttu-id="439df-124">SignalR uygulamaları, yerleşik ve üçüncü taraf ölçeklendirme sağlayıcılarını kullanarak binlerce istemciye ölçeklenebilir.</span><span class="sxs-lookup"><span data-stu-id="439df-124">SignalR applications can scale out to thousands of clients using built-in, and third-party scale-out providers.</span></span>

<span data-ttu-id="439df-125">Yerleşik sağlayıcılar şunlardır:</span><span class="sxs-lookup"><span data-stu-id="439df-125">Built-in providers include:</span></span>
* [<span data-ttu-id="439df-126">Service Bus</span><span class="sxs-lookup"><span data-stu-id="439df-126">Service Bus</span></span>](https://www.nuget.org/packages/Microsoft.AspNet.SignalR.ServiceBus3)
* [<span data-ttu-id="439df-127">SQL Server</span><span class="sxs-lookup"><span data-stu-id="439df-127">SQL Server</span></span>](https://www.nuget.org/packages/Microsoft.AspNet.SignalR.SqlServer)
* [<span data-ttu-id="439df-128">Redis</span><span class="sxs-lookup"><span data-stu-id="439df-128">Redis</span></span>](https://www.nuget.org/packages/Microsoft.AspNet.SignalR.Redis)

<span data-ttu-id="439df-129">Üçüncü taraf sağlayıcılar şunlardır:</span><span class="sxs-lookup"><span data-stu-id="439df-129">Third-party providers include:</span></span>
* <span data-ttu-id="439df-130">[NÖnbellek](https://www.alachisoft.com/ncache/asp-net-core-signalr.html).</span><span class="sxs-lookup"><span data-stu-id="439df-130">[NCache](https://www.alachisoft.com/ncache/asp-net-core-signalr.html).</span></span>

<span data-ttu-id="439df-131">SignalR açık kaynak kodludur, [GitHub](https://github.com/signalr)üzerinden erişilebilir.</span><span class="sxs-lookup"><span data-stu-id="439df-131">SignalR is open-source, accessible through [GitHub](https://github.com/signalr).</span></span>

## <a name="signalr-and-websocket"></a><span data-ttu-id="439df-132">SignalR ve WebSocket</span><span class="sxs-lookup"><span data-stu-id="439df-132">SignalR and WebSocket</span></span>

<span data-ttu-id="439df-133">SignalR, mevcut olduğu yerlerde yeni WebSocket aktarımını kullanır ve gerektiğinde eski taşımaaraçlarına geri döner.</span><span class="sxs-lookup"><span data-stu-id="439df-133">SignalR uses the new WebSocket transport where available and falls back to older transports where necessary.</span></span> <span data-ttu-id="439df-134">Kesinlikle doğrudan WebSocket kullanarak uygulama nızı yazabilirsiniz iken, SignalR kullanarak uygulamak için gereken ekstra işlevsellik bir çok zaten sizin için yapılır anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="439df-134">While you could certainly write your app using WebSocket directly, using SignalR means that a lot of the extra functionality you would need to implement is already done for you.</span></span> <span data-ttu-id="439df-135">En önemlisi, bu, eski istemciler için ayrı bir kod yolu oluşturma konusunda endişelenmenize gerek kalmadan uygulamanızı WebSocket'den yararlanmak için kodlayabileceğiniz anlamına gelir.</span><span class="sxs-lookup"><span data-stu-id="439df-135">Most importantly, this means that you can code your app to take advantage of WebSocket without having to worry about creating a separate code path for older clients.</span></span> <span data-ttu-id="439df-136">SignalR, uygulamanızın WebSocket sürümleri arasında tutarlı bir arayüz sağlayarak temel aktarımdaki değişiklikleri destekleyecek şekilde güncelleştirilediğinden, SignalR sizi WebSocket'teki güncellemeler hakkında endişelenmenize karşı da koruma sağlar.</span><span class="sxs-lookup"><span data-stu-id="439df-136">SignalR also shields you from having to worry about updates to WebSocket, since SignalR is updated to support changes in the underlying transport, providing your application a consistent interface across versions of WebSocket.</span></span>

<a id="transports"></a>

## <a name="transports-and-fallbacks"></a><span data-ttu-id="439df-137">Taşımalar ve geri dönüşler</span><span class="sxs-lookup"><span data-stu-id="439df-137">Transports and fallbacks</span></span>

<span data-ttu-id="439df-138">SignalR istemci ve sunucu arasında gerçek zamanlı çalışma yapmak için gerekli olan bazı aktarımlar üzerinde bir soyutlama.</span><span class="sxs-lookup"><span data-stu-id="439df-138">SignalR is an abstraction over some of the transports that are required to do real-time work between client and server.</span></span> <span data-ttu-id="439df-139">SignalR bağlantısı HTTP olarak başlar ve varsa WebSocket bağlantısına yükseltilir.</span><span class="sxs-lookup"><span data-stu-id="439df-139">A SignalR connection starts as HTTP, and is then promoted to a WebSocket connection if it is available.</span></span> <span data-ttu-id="439df-140">WebSocket SignalR için ideal bir aktarımdır, sunucu belleği en verimli şekilde kullanır, en düşük gecikme ye sahiptir ve en temel özelliklere sahiptir (istemci ve sunucu arasındaki tam çift yönlü iletişim gibi), ancak aynı zamanda en sıkı gereksinimlere sahiptir: WebSocket sunucunun Windows Server 2012 veya Windows 8 ve .NET Framework 4.5'i kullanmasını gerektirir.</span><span class="sxs-lookup"><span data-stu-id="439df-140">WebSocket is the ideal transport for SignalR, since it makes the most efficient use of server memory, has the lowest latency, and has the most underlying features (such as full duplex communication between client and server), but it also has the most stringent requirements: WebSocket requires the server to be using Windows Server 2012 or Windows 8, and .NET Framework 4.5.</span></span> <span data-ttu-id="439df-141">Bu gereksinimler karşılanmazsa, SignalR bağlantılarını yapmak için diğer aktarımları kullanmaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="439df-141">If these requirements are not met, SignalR will attempt to use other transports to make its connections.</span></span>

### <a name="html-5-transports"></a><span data-ttu-id="439df-142">HTML 5 taşımaları</span><span class="sxs-lookup"><span data-stu-id="439df-142">HTML 5 transports</span></span>

<span data-ttu-id="439df-143">Bu aktarımlar [HTML 5](http://en.wikipedia.org/wiki/HTML5)desteğine bağlıdır.</span><span class="sxs-lookup"><span data-stu-id="439df-143">These transports depend on support for [HTML 5](http://en.wikipedia.org/wiki/HTML5).</span></span> <span data-ttu-id="439df-144">İstemci tarayıcısı HTML 5 standardını desteklemiyorsa, eski aktarımlar kullanılır.</span><span class="sxs-lookup"><span data-stu-id="439df-144">If the client browser does not support the HTML 5 standard, older transports will be used.</span></span>

- <span data-ttu-id="439df-145">**WebSocket** (hem sunucu hem de tarayıcı Websocket'i destekleyebilirlerini gösteriyorsa).</span><span class="sxs-lookup"><span data-stu-id="439df-145">**WebSocket** (if both the server and browser indicate they can support Websocket).</span></span> <span data-ttu-id="439df-146">WebSocket, istemci ve sunucu arasında kalıcı, iki yönlü gerçek bir bağlantı kuran tek aktarımdır.</span><span class="sxs-lookup"><span data-stu-id="439df-146">WebSocket is the only transport that establishes a true persistent, two-way connection between client and server.</span></span> <span data-ttu-id="439df-147">Ancak, WebSocket da en sıkı gereksinimleri vardır; yalnızca Microsoft Internet Explorer, Google Chrome ve Mozilla Firefox'un en son sürümlerinde tam olarak desteklenir ve opera ve safari gibi diğer tarayıcılarda yalnızca kısmi bir uygulama vardır.</span><span class="sxs-lookup"><span data-stu-id="439df-147">However, WebSocket also has the most stringent requirements; it is fully supported only in the latest versions of Microsoft Internet Explorer, Google Chrome, and Mozilla Firefox, and only has a partial implementation in other browsers such as Opera and Safari.</span></span>
- <span data-ttu-id="439df-148">**Sunucu Gönderilen Olaylar**, ayrıca EventSource olarak bilinen (tarayıcı Temelde Internet Explorer hariç tüm tarayıcılar Sunucu Gönderilen Olaylar, destekliyorsa.)</span><span class="sxs-lookup"><span data-stu-id="439df-148">**Server Sent Events**, also known as EventSource (if the browser supports Server Sent Events, which is basically all browsers except Internet Explorer.)</span></span>

### <a name="comet-transports"></a><span data-ttu-id="439df-149">Kuyruklu yıldız taşımaları</span><span class="sxs-lookup"><span data-stu-id="439df-149">Comet transports</span></span>

<span data-ttu-id="439df-150">Aşağıdaki aktarımlar, bir tarayıcının veya başka bir istemcinin, istemci özellikle istemeden verileri istemciye taşımak için kullanabileceği uzun süreli bir HTTP isteğini koruduğu [Kuyruklu Yıldız](http://en.wikipedia.org/wiki/Comet_(programming)) web uygulama modeline dayanır.</span><span class="sxs-lookup"><span data-stu-id="439df-150">The following transports are based on the [Comet](http://en.wikipedia.org/wiki/Comet_(programming)) web application model, in which a browser or other client maintains a long-held HTTP request, which the server can use to push data to the client without the client specifically requesting it.</span></span>

- <span data-ttu-id="439df-151">**Forever Frame** (yalnızca Internet Explorer için).</span><span class="sxs-lookup"><span data-stu-id="439df-151">**Forever Frame** (for Internet Explorer only).</span></span> <span data-ttu-id="439df-152">Forever Frame, tamamlanmayan sunucuda bir bitiş noktasına istekte bulunan gizli bir IFrame oluşturur.</span><span class="sxs-lookup"><span data-stu-id="439df-152">Forever Frame creates a hidden IFrame which makes a request to an endpoint on the server that does not complete.</span></span> <span data-ttu-id="439df-153">Sunucu daha sonra komut dosyasını istemciye sürekli olarak gönderir ve bu komut dosyası hemen yürütülür ve sunucudan istemciye tek yönlü gerçek zamanlı bağlantı sağlar.</span><span class="sxs-lookup"><span data-stu-id="439df-153">The server then continually sends script to the client which is immediately executed, providing a one-way realtime connection from server to client.</span></span> <span data-ttu-id="439df-154">İstemciden sunucuya bağlantı sunucudan istemci bağlantısına ayrı bir bağlantı kullanır ve standart bir HTTP isteği gibi, gönderilmesi gereken her veri parçası için yeni bir bağlantı oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="439df-154">The connection from client to server uses a separate connection from the server to client connection, and like a standard HTTP request, a new connection is created for each piece of data that needs to be sent.</span></span>
- <span data-ttu-id="439df-155">**Ajax uzun yoklama**.</span><span class="sxs-lookup"><span data-stu-id="439df-155">**Ajax long polling**.</span></span> <span data-ttu-id="439df-156">Uzun yoklama kalıcı bir bağlantı oluşturmaz, ancak bunun yerine sunucu yanıt verene kadar açık kalan bir istekle sunucuyu yoklar ve bu noktada bağlantı kapanır ve hemen yeni bir bağlantı istenir.</span><span class="sxs-lookup"><span data-stu-id="439df-156">Long polling does not create a persistent connection, but instead polls the server with a request that stays open until the server responds, at which point the connection closes, and a new connection is requested immediately.</span></span> <span data-ttu-id="439df-157">Bu, bağlantı sıfırlanırken bazı gecikme sürelerini başlatabilir.</span><span class="sxs-lookup"><span data-stu-id="439df-157">This may introduce some latency while the connection resets.</span></span>

<span data-ttu-id="439df-158">Hangi aktarımların hangi yapılandırmalar altında desteklendiği hakkında daha fazla bilgi için desteklenen [Platformlar'a](supported-platforms.md)bakın.</span><span class="sxs-lookup"><span data-stu-id="439df-158">For more information on what transports are supported under which configurations, see [Supported Platforms](supported-platforms.md).</span></span>

### <a name="transport-selection-process"></a><span data-ttu-id="439df-159">Taşıma seçim süreci</span><span class="sxs-lookup"><span data-stu-id="439df-159">Transport selection process</span></span>

<span data-ttu-id="439df-160">Aşağıdaki liste, SignalR'in hangi aktarımın kullanılacağına karar vermek için kullandığı adımları gösterir.</span><span class="sxs-lookup"><span data-stu-id="439df-160">The following list shows the steps that SignalR uses to decide which transport to use.</span></span>

1. <span data-ttu-id="439df-161">Tarayıcı Internet Explorer 8 veya daha önceyse, Uzun Yoklama kullanılır.</span><span class="sxs-lookup"><span data-stu-id="439df-161">If the browser is Internet Explorer 8 or earlier, Long Polling is used.</span></span>
2. <span data-ttu-id="439df-162">JSONP yapılandırılırsa (diğer bir `jsonp` şekilde, parametre bağlantı `true` başlatıldığında ayarlanır), Uzun Yoklama kullanılır.</span><span class="sxs-lookup"><span data-stu-id="439df-162">If JSONP is configured (that is, the `jsonp` parameter is set to `true` when the connection is started), Long Polling is used.</span></span>
3. <span data-ttu-id="439df-163">Etki alanları arası bağlantı yapılıyorsa (diğer bir deyişle, SignalR bitiş noktası barındırma sayfasıyla aynı etki alanında değilse), aşağıdaki ölçütler karşılanırsa WebSocket kullanılır:</span><span class="sxs-lookup"><span data-stu-id="439df-163">If a cross-domain connection is being made (that is, if the SignalR endpoint is not in the same domain as the hosting page), then WebSocket will be used if the following criteria are met:</span></span>

   - <span data-ttu-id="439df-164">İstemci CORS 'u (Çapraz Kaynak Paylaşımı) destekler.</span><span class="sxs-lookup"><span data-stu-id="439df-164">The client supports CORS (Cross-Origin Resource Sharing).</span></span> <span data-ttu-id="439df-165">Hangi müşterilerin CORS'u desteklediği ne kadar ayrıntılı bilgi [için, caniuse.com'da CORS'e](http://www.caniuse.com/CORS)bakın.</span><span class="sxs-lookup"><span data-stu-id="439df-165">For details on which clients support CORS, see [CORS at caniuse.com](http://www.caniuse.com/CORS).</span></span>
   - <span data-ttu-id="439df-166">İstemci WebSocket'i destekler</span><span class="sxs-lookup"><span data-stu-id="439df-166">The client supports WebSocket</span></span>
   - <span data-ttu-id="439df-167">Sunucu WebSocket destekler</span><span class="sxs-lookup"><span data-stu-id="439df-167">The server supports WebSocket</span></span>

     <span data-ttu-id="439df-168">Bu ölçütlerden herhangi biri karşılanmazsa, Uzun Yoklama kullanılacaktır.</span><span class="sxs-lookup"><span data-stu-id="439df-168">If any of these criteria are not met, Long Polling will be used.</span></span> <span data-ttu-id="439df-169">Etki alanları arası bağlantılar hakkında daha fazla bilgi için, [etki alanları arası bağlantı nın nasıl kurulabildiğini](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain)öğrenin.</span><span class="sxs-lookup"><span data-stu-id="439df-169">For more information on cross-domain connections, see [How to establish a cross-domain connection](../guide-to-the-api/hubs-api-guide-javascript-client.md#crossdomain).</span></span>
4. <span data-ttu-id="439df-170">JSONP yapılandırılmamışsa ve bağlantı etki alanı arası değilse, hem istemci hem de sunucu destekliyorsa WebSocket kullanılır.</span><span class="sxs-lookup"><span data-stu-id="439df-170">If JSONP is not configured and the connection is not cross-domain, WebSocket will be used if both the client and server support it.</span></span>
5. <span data-ttu-id="439df-171">İstemci veya sunucu WebSocket'i desteklemiyorsa, varsa Sunucu Gönderilen Olaylar kullanılır.</span><span class="sxs-lookup"><span data-stu-id="439df-171">If either the client or server do not support WebSocket, Server Sent Events is used if it is available.</span></span>
6. <span data-ttu-id="439df-172">Sunucu Gönderilen Olaylar kullanılamıyorsa, Forever Frame denenir.</span><span class="sxs-lookup"><span data-stu-id="439df-172">If Server Sent Events is not available, Forever Frame is attempted.</span></span>
7. <span data-ttu-id="439df-173">Forever Frame başarısız olursa, Uzun Yoklama kullanılır.</span><span class="sxs-lookup"><span data-stu-id="439df-173">If Forever Frame fails, Long Polling is used.</span></span>

<a id="MonitoringTransports"></a>
### <a name="monitoring-transports"></a><span data-ttu-id="439df-174">Taşımaların izlenmesi</span><span class="sxs-lookup"><span data-stu-id="439df-174">Monitoring transports</span></span>

<span data-ttu-id="439df-175">Hub'ınızda günlüğe kaydetmeyi etkinleştirerek ve tarayıcınızdaki konsol penceresini açarak uygulamanızın hangi taşımayı kullandığını belirleyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="439df-175">You can determine what transport your application is using by enabling logging on your hub, and opening the console window in your browser.</span></span>

<span data-ttu-id="439df-176">Hub'ınızın bir tarayıcıdaki olayları nın günlüğe kaydedilmesini etkinleştirmek için istemci uygulamanıza aşağıdaki komutu ekleyin:</span><span class="sxs-lookup"><span data-stu-id="439df-176">To enable logging for your hub's events in a browser, add the following command to your client application:</span></span>

`$.connection.hub.logging = true;`

- <span data-ttu-id="439df-177">Internet Explorer'da F12 tuşuna basarak geliştirici araçlarını açın ve Konsol sekmesini tıklatın.</span><span class="sxs-lookup"><span data-stu-id="439df-177">In Internet Explorer, open the developer tools by pressing F12, and click the Console tab.</span></span>

    ![Microsoft Internet Explorer konsolu](introduction-to-signalr/_static/image2.png)
- <span data-ttu-id="439df-179">Chrome'da Ctrl+Shift+J tuşuna basarak konsolu açın.</span><span class="sxs-lookup"><span data-stu-id="439df-179">In Chrome, open the console by pressing Ctrl+Shift+J.</span></span>

    ![Google Chrome'da Konsol](introduction-to-signalr/_static/image3.png)

<span data-ttu-id="439df-181">Konsol açık ve günlüğe kaydetme etkin olduğunda, SignalR tarafından hangi aktarımın kullanıldığını görebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="439df-181">With the console open and logging enabled, you'll be able to see which transport is being used by SignalR.</span></span>

![Internet Explorer'da WebSocket aktarımLarını gösteren konsol](introduction-to-signalr/_static/image4.png)

### <a name="specifying-a-transport"></a><span data-ttu-id="439df-183">Aktarım belirtme</span><span class="sxs-lookup"><span data-stu-id="439df-183">Specifying a transport</span></span>

<span data-ttu-id="439df-184">Aktarım üzerinde anlaşma kakma belirli bir süre ve istemci/sunucu kaynakları alır.</span><span class="sxs-lookup"><span data-stu-id="439df-184">Negotiating a transport takes a certain amount of time and client/server resources.</span></span> <span data-ttu-id="439df-185">İstemci yetenekleri biliniyorsa, istemci bağlantısı başlatıldığında bir aktarım belirtilebilir.</span><span class="sxs-lookup"><span data-stu-id="439df-185">If the client capabilities are known, then a transport can be specified when the client connection is started.</span></span> <span data-ttu-id="439df-186">Aşağıdaki kod snippet, istemcinin başka bir protokolü desteklemediği biliniyorsa, Ajax Uzun Yoklama aktarımını kullanarak bağlantı kurmayı gösterir:</span><span class="sxs-lookup"><span data-stu-id="439df-186">The following code snippet demonstrates starting a connection using the Ajax Long Polling transport, as would be used if it was known that the client did not support any other protocol:</span></span>

`connection.start({ transport: 'longPolling' });`

<span data-ttu-id="439df-187">İstemci sırayla belirli aktarımları denemek istiyorsanız bir geri dönüş sırası belirtebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="439df-187">You can specify a fallback order if you want a client to try specific transports in order.</span></span> <span data-ttu-id="439df-188">Aşağıdaki kod snippet WebSocket çalışırken gösterir, ve başarısız, doğrudan Uzun Yoklama gidiyor.</span><span class="sxs-lookup"><span data-stu-id="439df-188">The following code snippet demonstrates trying WebSocket, and failing that, going directly to Long Polling.</span></span>

`connection.start({ transport: ['webSockets','longPolling'] });`

<span data-ttu-id="439df-189">Aktarımları belirtmek için dize sabitleri aşağıdaki gibi tanımlanır:</span><span class="sxs-lookup"><span data-stu-id="439df-189">The string constants for specifying transports are defined as follows:</span></span>

- `webSockets`
- `foreverFrame`
- `serverSentEvents`
- `longPolling`

## <a name="connections-and-hubs"></a><span data-ttu-id="439df-190">Bağlantılar ve Hub'lar</span><span class="sxs-lookup"><span data-stu-id="439df-190">Connections and Hubs</span></span>

<span data-ttu-id="439df-191">SignalR API istemciler ve sunucular arasında iletişim kurmak için iki model içerir: Kalıcı Bağlantılar ve Hub'lar.</span><span class="sxs-lookup"><span data-stu-id="439df-191">The SignalR API contains two models for communicating between clients and servers: Persistent Connections and Hubs.</span></span>

<span data-ttu-id="439df-192">Bağlantı, tek alıcı, gruplu veya yayın iletileri göndermek için basit bir bitiş noktasını temsil eder.</span><span class="sxs-lookup"><span data-stu-id="439df-192">A Connection represents a simple endpoint for sending single-recipient, grouped, or broadcast messages.</span></span> <span data-ttu-id="439df-193">Kalıcı Bağlantı API'si (PersistentConnection sınıfı tarafından .NET kodunda temsil edilir) geliştiriciye SignalR'ın sunduğu alt düzey iletişim protokolüne doğrudan erişim sağlar.</span><span class="sxs-lookup"><span data-stu-id="439df-193">The Persistent Connection API (represented in .NET code by the PersistentConnection class) gives the developer direct access to the low-level communication protocol that SignalR exposes.</span></span> <span data-ttu-id="439df-194">Bağlantılar iletişim modelini kullanmak, Windows Communication Foundation gibi bağlantı tabanlı API'leri kullanan geliştiriciler için tanıdık olacaktır.</span><span class="sxs-lookup"><span data-stu-id="439df-194">Using the Connections communication model will be familiar to developers who have used connection-based APIs such as Windows Communication Foundation.</span></span>

<span data-ttu-id="439df-195">Hub, bağlantı API'si üzerine inşa edilmiş ve istemcinizin ve sunucunuzun yöntemleri doğrudan birbirleri üzerinde aramasına olanak tanıyan daha üst düzey bir ardışık sistem dir.</span><span class="sxs-lookup"><span data-stu-id="439df-195">A Hub is a more high-level pipeline built upon the Connection API that allows your client and server to call methods on each other directly.</span></span> <span data-ttu-id="439df-196">SignalR, makine sınırları ötesine, istemcilerin sunucudaki yöntemleri yerel yöntemler kadar kolay aramasına izin vererek, bunun tam tersi gibi, makine sınırları ötesine göndermeyi işler.</span><span class="sxs-lookup"><span data-stu-id="439df-196">SignalR handles the dispatching across machine boundaries as if by magic, allowing clients to call methods on the server as easily as local methods, and vice versa.</span></span> <span data-ttu-id="439df-197">Hubs iletişim modelini kullanmak, .NET Remoting gibi uzaktan çağırma API'leri kullanan geliştiriciler için tanıdık olacaktır.</span><span class="sxs-lookup"><span data-stu-id="439df-197">Using the Hubs communication model will be familiar to developers who have used remote invocation APIs such as .NET Remoting.</span></span> <span data-ttu-id="439df-198">Hub kullanmak, güçlü bir şekilde yazılan parametreleri yöntemlere geçirmenize olanak sağlayarak model bağlamayı sağlar.</span><span class="sxs-lookup"><span data-stu-id="439df-198">Using a Hub also allows you to pass strongly typed parameters to methods, enabling model binding.</span></span>

### <a name="architecture-diagram"></a><span data-ttu-id="439df-199">Mimari diyagramı</span><span class="sxs-lookup"><span data-stu-id="439df-199">Architecture diagram</span></span>

<span data-ttu-id="439df-200">Aşağıdaki diyagram, Hub'lar, Kalıcı Bağlantılar ve taşımalar için kullanılan temel teknolojiler arasındaki ilişkiyi gösterir.</span><span class="sxs-lookup"><span data-stu-id="439df-200">The following diagram shows the relationship between Hubs, Persistent Connections, and the underlying technologies used for transports.</span></span>

![API'leri, taşımaları ve istemcileri gösteren SignalR Mimari Diyagramı](introduction-to-signalr/_static/image5.png)

### <a name="how-hubs-work"></a><span data-ttu-id="439df-202">Hub'lar nasıl çalışır?</span><span class="sxs-lookup"><span data-stu-id="439df-202">How Hubs work</span></span>

<span data-ttu-id="439df-203">Sunucu tarafı kodu istemcide bir yöntem çağırdığında, çağrılacak yöntemin adını ve parametrelerini içeren etkin aktarım boyunca bir paket gönderilir (bir nesne yöntem parametresi olarak gönderildiğinde, JSON kullanılarak seri hale getirilir).</span><span class="sxs-lookup"><span data-stu-id="439df-203">When server-side code calls a method on the client, a packet is sent across the active transport that contains the name and parameters of the method to be called (when an object is sent as a method parameter, it is serialized using JSON).</span></span> <span data-ttu-id="439df-204">İstemci daha sonra yöntem adını istemci tarafı kodunda tanımlanan yöntemlerle eşleşir.</span><span class="sxs-lookup"><span data-stu-id="439df-204">The client then matches the method name to methods defined in client-side code.</span></span> <span data-ttu-id="439df-205">Bir eşleşme varsa, istemci yöntemi deserialized parametre verileri kullanılarak yürütülür.</span><span class="sxs-lookup"><span data-stu-id="439df-205">If there is a match, the client method will be executed using the deserialized parameter data.</span></span>

<span data-ttu-id="439df-206">Yöntem çağrısı [Fiddler](http://fiddler2.com/) gibi araçlar kullanılarak izlenebilir.</span><span class="sxs-lookup"><span data-stu-id="439df-206">The method call can be monitored using tools like [Fiddler.](http://fiddler2.com/)</span></span> <span data-ttu-id="439df-207">Aşağıdaki resimde, SignalR sunucusundan Fiddler'ın Günlükler bölmesinde bir web tarayıcıistemcisine gönderilen bir yöntem çağrısı gösterilmektedir.</span><span class="sxs-lookup"><span data-stu-id="439df-207">The following image shows a method call sent from a SignalR server to a web browser client in the Logs pane of Fiddler.</span></span> <span data-ttu-id="439df-208">Yöntem çağrısı adlı `MoveShapeHub`bir hub'dan gönderiliyor ve çağrılan `updateShape`yönteme denir.</span><span class="sxs-lookup"><span data-stu-id="439df-208">The method call is being sent from a hub called `MoveShapeHub`, and the method being invoked is called `updateShape`.</span></span>

![SignalR trafiğini gösteren Fiddler günlüğünün görünümü](introduction-to-signalr/_static/image6.png)

<span data-ttu-id="439df-210">Bu örnekte, hub adı `H` parametre ile tanımlanır; yöntem adı `M` parametre ile tanımlanır ve yönteme gönderilen veriler `A` parametre ile tanımlanır.</span><span class="sxs-lookup"><span data-stu-id="439df-210">In this example, the hub name is identified with the `H` parameter; the method name is identified with the `M` parameter, and the data being sent to the method is identified with the `A` parameter.</span></span> <span data-ttu-id="439df-211">Bu iletiyi oluşturan uygulama [Yüksek Frekanslı Gerçek Zamanlı](tutorial-high-frequency-realtime-with-signalr.md) öğreticide oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="439df-211">The application that generated this message is created in the [High-Frequency Realtime](tutorial-high-frequency-realtime-with-signalr.md) tutorial.</span></span>

### <a name="choosing-a-communication-model"></a><span data-ttu-id="439df-212">İletişim modeli seçme</span><span class="sxs-lookup"><span data-stu-id="439df-212">Choosing a communication model</span></span>

<span data-ttu-id="439df-213">Çoğu uygulama Hub'lar API kullanmalıdır.</span><span class="sxs-lookup"><span data-stu-id="439df-213">Most applications should use the Hubs API.</span></span> <span data-ttu-id="439df-214">Bağlantılar API'si aşağıdaki durumlarda kullanılabilir:</span><span class="sxs-lookup"><span data-stu-id="439df-214">The Connections API could be used in the following circumstances:</span></span>

- <span data-ttu-id="439df-215">Gönderilen gerçek iletinin biçiminin belirtilmesi gerekir.</span><span class="sxs-lookup"><span data-stu-id="439df-215">The format of the actual message sent needs to be specified.</span></span>
- <span data-ttu-id="439df-216">Geliştirici, uzaktan çağırma modeli yerine bir ileti ve gönderme modeliyle çalışmayı tercih eder.</span><span class="sxs-lookup"><span data-stu-id="439df-216">The developer prefers to work with a messaging and dispatching model rather than a remote invocation model.</span></span>
- <span data-ttu-id="439df-217">SignalR kullanmak için bir ileti modeli kullanan varolan bir uygulama taşınır.</span><span class="sxs-lookup"><span data-stu-id="439df-217">An existing application that uses a messaging model is being ported to use SignalR.</span></span>
