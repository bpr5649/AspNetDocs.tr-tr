---
uid: mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
title: Otomatik birim testini etkinleştir | Microsoft Docs
author: microsoft
description: 12. adım, Nerdakşam yemeği işlevselümüzü doğrulayan ve değişiklik yapma güvencesine izin veren bir otomatik birim testleri paketinin nasıl geliştirileceği gösterilmektedir...
ms.author: riande
ms.date: 07/27/2010
ms.assetid: a19ff2ce-3f7e-4358-9a51-a1403da9c63e
msc.legacyurl: /mvc/overview/older-versions-1/nerddinner/enable-automated-unit-testing
msc.type: authoredcontent
ms.openlocfilehash: 09a7aa186605a6cce48ee94028425ded957c00d3
ms.sourcegitcommit: e7e91932a6e91a63e2e46417626f39d6b244a3ab
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 03/06/2020
ms.locfileid: "78541680"
---
# <a name="enable-automated-unit-testing"></a><span data-ttu-id="bb3ee-103">Otomatik Birim Testini Etkinleştirme</span><span class="sxs-lookup"><span data-stu-id="bb3ee-103">Enable Automated Unit Testing</span></span>

<span data-ttu-id="bb3ee-104">[Microsoft](https://github.com/microsoft) tarafından</span><span class="sxs-lookup"><span data-stu-id="bb3ee-104">by [Microsoft](https://github.com/microsoft)</span></span>

[<span data-ttu-id="bb3ee-105">PDF 'YI indir</span><span class="sxs-lookup"><span data-stu-id="bb3ee-105">Download PDF</span></span>](http://aspnetmvcbook.s3.amazonaws.com/aspnetmvc-nerdinner_v1.pdf)

> <span data-ttu-id="bb3ee-106">Bu, ASP.NET MVC 1 kullanarak küçük, ancak tam bir Web uygulamasının nasıl oluşturulacağını gösteren ücretsiz bir ["Nerdakşam yemeği" uygulama öğreticisinin](introducing-the-nerddinner-tutorial.md) 12. adımından oluşur.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-106">This is step 12 of a free ["NerdDinner" application tutorial](introducing-the-nerddinner-tutorial.md) that walks-through how to build a small, but complete, web application using ASP.NET MVC 1.</span></span>
> 
> <span data-ttu-id="bb3ee-107">12. adım, Nerdakşam yemeği işlevselümüzü doğrulayan bir otomatik birim testi paketinin nasıl geliştirileceği ve gelecekte uygulamada değişiklik ve iyileştirmeler yapma güvencesine sahip olduğunu gösterir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-107">Step 12 shows how to develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>
> 
> <span data-ttu-id="bb3ee-108">ASP.NET MVC 3 kullanıyorsanız, [MVC 3 Ile çalışmaya başlama](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) veya [MVC müzik mağazası](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) öğreticilerini izlemeniz önerilir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-108">If you are using ASP.NET MVC 3, we recommend you follow the [Getting Started With MVC 3](../../older-versions/getting-started-with-aspnet-mvc3/cs/intro-to-aspnet-mvc-3.md) or [MVC Music Store](../../older-versions/mvc-music-store/mvc-music-store-part-1.md) tutorials.</span></span>

## <a name="nerddinner-step-12-unit-testing"></a><span data-ttu-id="bb3ee-109">Nerdakşam yemeği adım 12: birim testi</span><span class="sxs-lookup"><span data-stu-id="bb3ee-109">NerdDinner Step 12: Unit Testing</span></span>

<span data-ttu-id="bb3ee-110">Nerdakşam yemeği işlevselümüzü doğrulayan ve gelecekte uygulamada değişiklik ve iyileştirmeler yapma güvencesine izin veren bir otomatik birim testleri paketi geliştiriyorum.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-110">Let's develop a suite of automated unit tests that verify our NerdDinner functionality, and which will give us the confidence to make changes and improvements to the application in the future.</span></span>

### <a name="why-unit-test"></a><span data-ttu-id="bb3ee-111">Birim testi neden?</span><span class="sxs-lookup"><span data-stu-id="bb3ee-111">Why Unit Test?</span></span>

<span data-ttu-id="bb3ee-112">Sürücüde bir sabah iş üzerinde çalıştığınız bir uygulamayla ilgili ani bir flaş vardır.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-112">On the drive into work one morning you have a sudden flash of inspiration about an application you are working on.</span></span> <span data-ttu-id="bb3ee-113">Uygulamayı önemli ölçüde daha iyi hale getirmek için uygulayabileceğiniz bir değişiklik olduğunu fark edersiniz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-113">You realize there is a change you can implement that will make the application dramatically better.</span></span> <span data-ttu-id="bb3ee-114">Kodu temizliyor, yeni bir özellik ekleyen veya bir hatayı düzelten bir yeniden düzenleme olabilir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-114">It might be a refactoring that cleans up the code, adds a new feature, or fixes a bug.</span></span>

<span data-ttu-id="bb3ee-115">Bilgisayarınıza ulaşan bir sorun var: "Bu geliştirmeyi yapmak için güvenli hale getirme mi?"</span><span class="sxs-lookup"><span data-stu-id="bb3ee-115">The question that confronts you when you arrive at your computer is – "how safe is it to make this improvement?"</span></span> <span data-ttu-id="bb3ee-116">Değişikliğin yan etkileri varsa veya bir şeyi bozarsa ne olacak?</span><span class="sxs-lookup"><span data-stu-id="bb3ee-116">What if making the change has side effects or breaks something?</span></span> <span data-ttu-id="bb3ee-117">Değişikliğin uygulanması basit olabilir ve yalnızca birkaç dakika sürer, ancak tüm uygulama senaryolarını el ile test etmek için saat alırsa ne olur?</span><span class="sxs-lookup"><span data-stu-id="bb3ee-117">The change might be simple and only take a few minutes to implement, but what if it takes hours to manually test out all of the application scenarios?</span></span> <span data-ttu-id="bb3ee-118">Bir senaryoyu ele almayı unutursanız ve bozuk bir uygulama üretime gidiyor mi?</span><span class="sxs-lookup"><span data-stu-id="bb3ee-118">What if you forget to cover a scenario and a broken application goes into production?</span></span> <span data-ttu-id="bb3ee-119">Bu geliştirmeyi tamamen tüm çabalara getirsin mi?</span><span class="sxs-lookup"><span data-stu-id="bb3ee-119">Is making this improvement really worth all the effort?</span></span>

<span data-ttu-id="bb3ee-120">Otomatik birim testleri, uygulamalarınızı sürekli olarak geliştirmenize ve üzerinde çalıştığınız kodun bir RAID 'den kaçınmanızı sağlayan bir güvenlik ağı sağlayabilir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-120">Automated unit tests can provide a safety net that enables you to continually enhance your applications, and avoid being afraid of the code you are working on.</span></span> <span data-ttu-id="bb3ee-121">İşlevselliği hızlı bir şekilde doğrulayan otomatikleştirilmiş testlerin olması, güvenle kod sağlamanıza olanak sağlar ve sizin de rahat bir şekilde yapamamanıza izin vermeyebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-121">Having automated tests that quickly verify functionality enables you to code with confidence – and empower you to make improvements you might otherwise not have felt comfortable doing.</span></span> <span data-ttu-id="bb3ee-122">Ayrıca, daha fazla sürdürülebilir çözüm oluşturmaya yardımcı olur ve daha uzun bir süre boyunca yatırım getirisi daha yüksektir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-122">They also help create solutions that are more maintainable and have a longer lifetime - which leads to a much higher return on investment.</span></span>

<span data-ttu-id="bb3ee-123">ASP.NET MVC Framework, birim testi uygulaması işlevselliğini kolaylaştırır ve doğal hale getirir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-123">The ASP.NET MVC Framework makes it easy and natural to unit test application functionality.</span></span> <span data-ttu-id="bb3ee-124">Ayrıca, test ilk tabanlı geliştirmeyi sağlayan test odaklı geliştirme (TDD) iş akışını da mümkün kılar.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-124">It also enables a Test Driven Development (TDD) workflow that enables test-first based development.</span></span>

### <a name="nerddinnertests-project"></a><span data-ttu-id="bb3ee-125">Nerdakşam yemeği. Tests projesi</span><span class="sxs-lookup"><span data-stu-id="bb3ee-125">NerdDinner.Tests Project</span></span>

<span data-ttu-id="bb3ee-126">Bu öğreticinin başlangıcında Nerdakşam yemeği uygulamamızı oluşturduğumuzda, uygulama projesiyle birlikte olmak üzere bir birim testi projesi oluşturmak isteyip istemediğinizi soran bir iletişim kutusu sorulduk:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-126">When we created our NerdDinner application at the beginning of this tutorial, we were prompted with a dialog asking whether we wanted to create a unit test project to go along with the application project:</span></span>

![](enable-automated-unit-testing/_static/image1.png)

<span data-ttu-id="bb3ee-127">Çözümünüze "Nerdakşam. Tests" projesinin eklenmesinden kaynaklanan "Evet, birim test projesi oluştur" radyo düğmesinin seçili olduğunu tutduk:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-127">We kept the "Yes, create a unit test project" radio button selected – which resulted in a "NerdDinner.Tests" project being added to our solution:</span></span>

![](enable-automated-unit-testing/_static/image2.png)

<span data-ttu-id="bb3ee-128">Nerdakşam yemeği. Tests projesi, Nerdakşam yemeği uygulaması proje derlemesine başvurur ve uygulama işlevselliğini doğrulayan buna kolayca otomatikleştirilmiş testler ekleyebilmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-128">The NerdDinner.Tests project references the NerdDinner application project assembly, and enables us to easily add automated tests to it that verify the application functionality.</span></span>

### <a name="creating-unit-tests-for-our-dinner-model-class"></a><span data-ttu-id="bb3ee-129">Akşam yemeği model sınıfımız için birim testleri oluşturma</span><span class="sxs-lookup"><span data-stu-id="bb3ee-129">Creating Unit Tests for our Dinner Model Class</span></span>

<span data-ttu-id="bb3ee-130">Şimdi, model katmanımızı oluştururken oluşturduğumuz akşam yemeği sınıfını doğrulayan Nerdakşam yemeği. test projemize bazı testler ekleyelim.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-130">Let's add some tests to our NerdDinner.Tests project that verify the Dinner class we created when we built our model layer.</span></span>

<span data-ttu-id="bb3ee-131">Test projemizde, modellerle ilgili testlerinizi yerleştireceğiniz "modeller" adlı yeni bir klasör oluşturarak başlayacağız.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-131">We'll start by creating a new folder within our test project called "Models" where we'll place our model-related tests.</span></span> <span data-ttu-id="bb3ee-132">Ardından, klasöre sağ tıklayıp **&gt;yeni test Ekle** menü komutunu seçmelisiniz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-132">We'll then right-click on the folder and choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="bb3ee-133">Bu, "yeni test Ekle" iletişim kutusunu getirir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-133">This will bring up the "Add New Test" dialog.</span></span>

<span data-ttu-id="bb3ee-134">"Birim testi" oluşturup "DinnerTest.cs" olarak adlandırın:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-134">We'll choose to create a "Unit Test" and name it "DinnerTest.cs":</span></span>

![](enable-automated-unit-testing/_static/image3.png)

<span data-ttu-id="bb3ee-135">"Tamam" düğmesine tıkladığımızda, Visual Studio projeye bir DinnerTest.cs dosyası ekler (ve açar):</span><span class="sxs-lookup"><span data-stu-id="bb3ee-135">When we click the "ok" button Visual Studio will add (and open) a DinnerTest.cs file to the project:</span></span>

![](enable-automated-unit-testing/_static/image4.png)

<span data-ttu-id="bb3ee-136">Varsayılan Visual Studio birim testi şablonu, küçük bir Messy buldum.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-136">The default Visual Studio unit test template has a bunch of boiler-plate code within it that I find a little messy.</span></span> <span data-ttu-id="bb3ee-137">Yalnızca aşağıdaki kodu içerecek şekilde temizleyelim:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-137">Let's clean it up to just contain the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample1.cs)]

<span data-ttu-id="bb3ee-138">Yukarıdaki DinnerTest sınıfındaki [TestClass] özniteliği, testleri içerecek bir sınıf olarak ve isteğe bağlı test başlatma ve tearı kodu tanımlar.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-138">The [TestClass] attribute on the DinnerTest class above identifies it as a class that will contain tests, as well as optional test initialization and teardown code.</span></span> <span data-ttu-id="bb3ee-139">Üzerinde [TestMethod] özniteliğine sahip ortak yöntemler ekleyerek, içindeki testleri tanımlayabiliriz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-139">We can define tests within it by adding public methods that have a [TestMethod] attribute on them.</span></span>

<span data-ttu-id="bb3ee-140">Aşağıda akşam yemeği sınıfınızı sunduğumuz iki testten ilki verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-140">Below are the first of two tests we'll add that exercise our Dinner class.</span></span> <span data-ttu-id="bb3ee-141">İlk test, tüm özellikler doğru şekilde ayarlanmaksızın yeni bir akşam yemeği oluşturulduysa, akşam yemeği 'nin geçersiz olduğunu doğrular.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-141">The first test verifies that our Dinner is invalid if a new Dinner is created without all properties being set correctly.</span></span> <span data-ttu-id="bb3ee-142">İkinci test, bir akşam yemeği 'nin geçerli değerlerle ayarlanmış tüm özellikleri olduğunda akşam yemeği 'nin geçerli olduğunu doğrular:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-142">The second test verifies that our Dinner is valid when a Dinner has all properties set with valid values:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample2.cs)]

<span data-ttu-id="bb3ee-143">Test adlarımızın çok açık (ve biraz ayrıntılı) olduğunu fark edeceksiniz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-143">You'll notice above that our test names are very explicit (and somewhat verbose).</span></span> <span data-ttu-id="bb3ee-144">Yüzlerce veya binlerce küçük test oluşturduğumuz için bunu yapıyoruz ve bunların her birinin amacını ve davranışını hızlı bir şekilde belirlemeyi kolaylaştırmak istiyoruz (özellikle bir Test Çalıştırıcısı içindeki hataların bir listesini aradığımızda).</span><span class="sxs-lookup"><span data-stu-id="bb3ee-144">We are doing this because we might end up creating hundreds or thousands of small tests, and we want to make it easy to quickly determine the intent and behavior of each of them (especially when we are looking through a list of failures in a test runner).</span></span> <span data-ttu-id="bb3ee-145">Test adları, test ettikleri işlevlerden sonra adlandırılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-145">The test names should be named after the functionality they are testing.</span></span> <span data-ttu-id="bb3ee-146">Yukarıdaki bir "ad\_\_fiil" adlandırma deseninin kullanılması gerekir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-146">Above we are using a "Noun\_Should\_Verb" naming pattern.</span></span>

<span data-ttu-id="bb3ee-147">"Düzenle, davran, onaylama" anlamına gelir ve "AAA" test modelini kullanarak testleri oluşturacağız:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-147">We are structuring the tests using the "AAA" testing pattern – which stands for "Arrange, Act, Assert":</span></span>

- <span data-ttu-id="bb3ee-148">Düzenle: test edilmekte olan birimi ayarla</span><span class="sxs-lookup"><span data-stu-id="bb3ee-148">Arrange: Setup the unit being tested</span></span>
- <span data-ttu-id="bb3ee-149">Davran: birimi test ve yakalama sonuçları altında yapın</span><span class="sxs-lookup"><span data-stu-id="bb3ee-149">Act: Exercise the unit under test and capture results</span></span>
- <span data-ttu-id="bb3ee-150">Onaylama: davranışı doğrulama</span><span class="sxs-lookup"><span data-stu-id="bb3ee-150">Assert: Verify the behavior</span></span>

<span data-ttu-id="bb3ee-151">Testleri yazarken, bireysel testlerin çok fazla olmasına engel olmak istiyoruz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-151">When we write tests we want to avoid having the individual tests do too much.</span></span> <span data-ttu-id="bb3ee-152">Bunun yerine her testin yalnızca tek bir kavram doğrulaması gerekir (Bu, hataların nedenlerini saptamak çok daha kolay hale getirir).</span><span class="sxs-lookup"><span data-stu-id="bb3ee-152">Instead each test should verify only a single concept (which will make it much easier to pinpoint the cause of failures).</span></span> <span data-ttu-id="bb3ee-153">Her test için, denemek ve yalnızca tek bir onay bildirimine sahip olmak iyi bir uygulamadır.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-153">A good guideline is to try and only have a single assert statement for each test.</span></span> <span data-ttu-id="bb3ee-154">Bir test yönteminde birden fazla onay deyiminiz varsa, bunların aynı kavramı test etmek için kullanıldığından emin olun.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-154">If you have more than one assert statement in a test method, make sure they are all being used to test the same concept.</span></span> <span data-ttu-id="bb3ee-155">Şüpheli olduğunda başka bir test oluşturun.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-155">When in doubt, make another test.</span></span>

### <a name="running-tests"></a><span data-ttu-id="bb3ee-156">Testleri Çalıştırma</span><span class="sxs-lookup"><span data-stu-id="bb3ee-156">Running Tests</span></span>

<span data-ttu-id="bb3ee-157">Visual Studio 2008 Professional (ve üzeri sürümler), IDE içinde Visual Studio birim testi projelerini çalıştırmak için kullanılabilen yerleşik bir Test Çalıştırıcısı içerir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-157">Visual Studio 2008 Professional (and higher editions) includes a built-in test runner that can be used to run Visual Studio Unit Test projects within the IDE.</span></span> <span data-ttu-id="bb3ee-158">Tüm birim testlerimizi çalıştırmak için **&gt;test-&gt;tüm testleri çözüm** menü komutunda (veya CTRL R, A) seçebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-158">We can select the **Test-&gt;Run-&gt;All Tests in Solution** menu command (or type Ctrl R, A) to run all of our unit tests.</span></span> <span data-ttu-id="bb3ee-159">Ya da alternatif olarak, imleimizi belirli bir test sınıfı veya test yöntemi içinde konumlandırabiliriz ve birim testlerinin bir alt kümesini çalıştırmak için **geçerli bağlam menü komutunda test&gt;Run-&gt;testlerini** (veya CTRL R, t) kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-159">Or alternatively we can position our cursor within a specific test class or test method and use the **Test-&gt;Run-&gt;Tests in Current Context** menu command (or type Ctrl R, T) to run a subset of the unit tests.</span></span>

<span data-ttu-id="bb3ee-160">Şimdi, yeni tanımladığımız iki testi çalıştırmak için imlecinizi DinnerTest sınıfı içinde konumlandıralım ve "CTRL R, T" yazın.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-160">Let's position our cursor within the DinnerTest class and type "Ctrl R, T" to run the two tests we just defined.</span></span> <span data-ttu-id="bb3ee-161">Bunu yaptığımızda, Visual Studio içinde bir "Test Sonuçları" penceresi görünür ve test çalıştırdığımız sonuçları onun içinde listelenmiş olarak görebiliriz:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-161">When we do this a "Test Results" window will appear within Visual Studio and we'll see the results of our test run listed within it:</span></span>

![](enable-automated-unit-testing/_static/image5.png)

<span data-ttu-id="bb3ee-162">*Not: VS test sonuçları penceresi sınıf adı sütununu varsayılan olarak göstermez. Test Sonuçları penceresinin içine sağ tıklayıp sütunları ekle/kaldır menü komutunu kullanarak bunu ekleyebilirsiniz.*</span><span class="sxs-lookup"><span data-stu-id="bb3ee-162">*Note: The VS test results window does not show the Class Name column by default. You can add this by right-clicking within the Test Results window and using the Add/Remove Columns menu command.*</span></span>

<span data-ttu-id="bb3ee-163">İki sınamamız yalnızca saniyenin bir kısmını çalıştırtık ve her ikisini de görebilecekleri gibi.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-163">Our two tests took only a fraction of a second to run – and as you can see they both passed.</span></span> <span data-ttu-id="bb3ee-164">Artık, belirli kural doğrulamaları doğrulayan ek sınamalar oluşturarak bunları artırabilir ve bu, akşam yemeği sınıfına eklediğimiz iki yardımcı yöntemi (ısuserhost () ve ıuserregistered ()) kapsar.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-164">We can now go on and augment them by creating additional tests that verify specific rule validations, as well as cover the two helper methods - IsUserHost() and IsUserRegistered() – that we added to the Dinner class.</span></span> <span data-ttu-id="bb3ee-165">Dinner Now sınıfı için tüm bu testlerin yerinde olması, gelecekte buna yeni iş kuralları ve doğrulamalar eklemek çok daha kolay ve güvenli hale getirir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-165">Having all these tests in place for the Dinner class will make it much easier and safer to add new business rules and validations to it in the future.</span></span> <span data-ttu-id="bb3ee-166">Yeni kural mantığımızı akşam yemeği 'ya ekleyebiliriz ve saniyeler içinde önceki Logic işlevlerinden hiçbirini bozmadığını doğrulıyoruz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-166">We can add our new rule logic to Dinner, and then within seconds verify that it hasn't broken any of our previous logic functionality.</span></span>

<span data-ttu-id="bb3ee-167">Açıklayıcı bir test adı kullanmanın, her sınamanın ne olduğunu hızla öğrenmesini nasıl kolaylaştırdığını unutmayın.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-167">Notice how using a descriptive test name makes it easy to quickly understand what each test is verifying.</span></span> <span data-ttu-id="bb3ee-168">**Araçlar-&gt;seçenekler** menü komutunu, test araçları-&gt;test yürütme yapılandırma ekranını açmak ve "başarısız veya sonuçlanmamış birim test sonucunu çift tıklatmak, testteki hata noktasını görüntüler" onay kutusunu işaretleyerek.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-168">I recommend using the **Tools-&gt;Options** menu command, opening the Test Tools-&gt;Test Execution configuration screen, and checking the "Double-clicking a failed or inconclusive unit test result displays the point of failure in the test" checkbox.</span></span> <span data-ttu-id="bb3ee-169">Bu, test sonuçları penceresinde bir hataya çift tıklamasına ve onaylama hatasına hemen geçebilmenizi sağlar.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-169">This will allow you to double-click on a failure in the test results window and jump immediately to the assert failure.</span></span>

### <a name="creating-dinnerscontroller-unit-tests"></a><span data-ttu-id="bb3ee-170">DinnersController birim testleri oluşturma</span><span class="sxs-lookup"><span data-stu-id="bb3ee-170">Creating DinnersController Unit Tests</span></span>

<span data-ttu-id="bb3ee-171">Şimdi DinnersController işlevselümüzü doğrulayan bazı birim testleri oluşturalım.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-171">Let's now create some unit tests that verify our DinnersController functionality.</span></span> <span data-ttu-id="bb3ee-172">Test projemizdeki "denetleyiciler" klasörüne sağ tıklayıp ardından **&gt;yeni test Ekle** menü komutunu seçerek başlayacağız.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-172">We'll start by right-clicking on the "Controllers" folder within our Test project and then choose the **Add-&gt;New Test** menu command.</span></span> <span data-ttu-id="bb3ee-173">"Birim testi" oluşturacağız ve "DinnersControllerTest.cs" olarak adlandırın.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-173">We'll create a "Unit Test" and name it "DinnersControllerTest.cs".</span></span>

<span data-ttu-id="bb3ee-174">DinnersController üzerinde details () eylem yöntemini doğrulayan iki test yöntemi oluşturacağız.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-174">We'll create two test methods that verify the Details() action method on the DinnersController.</span></span> <span data-ttu-id="bb3ee-175">Birincisi, var olan bir akşam yemeği istendiğinde bir görünümün döndürüleceğini doğrular.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-175">The first will verify that a View is returned when an existing Dinner is requested.</span></span> <span data-ttu-id="bb3ee-176">İkincisi, var olmayan bir akşam yemeği istendiğinde "NotFound" görünümünün döndürüldüğünü doğrular:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-176">The second will verify that a "NotFound" view is returned when a non-existent Dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample3.cs)]

<span data-ttu-id="bb3ee-177">Yukarıdaki kod, temizlemeyi derler.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-177">The above code compiles clean.</span></span> <span data-ttu-id="bb3ee-178">Testleri çalıştırdığımızda, her ikisi de başarısız olur:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-178">When we run the tests, though, they both fail:</span></span>

![](enable-automated-unit-testing/_static/image6.png)

<span data-ttu-id="bb3ee-179">Hata iletilerine baktığımızda, DinnersRepository sınıfımız bir veritabanına bağlanamadığı için testin başarısız olmasının nedenini görüyoruz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-179">If we look at the error messages, we'll see that the reason the tests failed was because our DinnersRepository class was unable to connect to a database.</span></span> <span data-ttu-id="bb3ee-180">Nerdakşam yemeği uygulamamız, Nerdakşam yemeği uygulama projesinin \app\_veri dizininde bulunan bir yerel SQL Server Express dosyasına bağlantı dizesi kullanıyor.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-180">Our NerdDinner application is using a connection-string to a local SQL Server Express file which lives under the \App\_Data directory of the NerdDinner application project.</span></span> <span data-ttu-id="bb3ee-181">Nerdakşam yemeği. Tests projesi farklı bir dizinde derlendiğinden ve çalıştırıldığı için, bağlantı dizemizin göreli yol konumu yanlış.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-181">Because our NerdDinner.Tests project compiles and runs in a different directory then the application project, the relative path location of our connection-string is incorrect.</span></span>

<span data-ttu-id="bb3ee-182">Bunu, SQL Express veritabanı dosyasını test projemiz olarak kopyalayarak ve ardından test projemizin App. config dosyasında buna uygun bir test bağlantısı dizesi *ekleyerek giderebiliriz* .</span><span class="sxs-lookup"><span data-stu-id="bb3ee-182">We *could* fix this by copying the SQL Express database file to our test project, and then add an appropriate test connection-string to it in the App.config of our test project.</span></span> <span data-ttu-id="bb3ee-183">Bu, yukarıdaki testlerin engeli kaldırılmış ve çalışır durumda olur.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-183">This would get the above tests unblocked and running.</span></span>

<span data-ttu-id="bb3ee-184">Gerçek bir veritabanı kullanan birim testi kodu, bununla birlikte bir dizi zorluk gösterir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-184">Unit testing code using a real database, though, brings with it a number of challenges.</span></span> <span data-ttu-id="bb3ee-185">Daha ayrıntılı şekilde belirtmek gerekirse:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-185">Specifically:</span></span>

- <span data-ttu-id="bb3ee-186">Birim testlerinin yürütme süresini önemli ölçüde yavaşlatır.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-186">It significantly slows down the execution time of unit tests.</span></span> <span data-ttu-id="bb3ee-187">Testleri çalıştırmak daha uzun sürer, bu da sık sık yürütülecektir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-187">The longer it takes to run tests, the less likely you are to execute them frequently.</span></span> <span data-ttu-id="bb3ee-188">İdeal olarak, birim testlerinizin Saniyeler içinde çalıştırılmasını ve projeyi derlemek için doğal olarak yaptığınız bir şey olmasını istersiniz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-188">Ideally you want your unit tests to be able to be run in seconds – and have it be something you do as naturally as compiling the project.</span></span>
- <span data-ttu-id="bb3ee-189">Testler içindeki kurulum ve Temizleme mantığını karmaşıklaştırır.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-189">It complicates the setup and cleanup logic within tests.</span></span> <span data-ttu-id="bb3ee-190">Her birim testinin diğerlerinden (yan etkileri veya bağımlılıklar olmadan) yalıtılmış ve bağımsız olmasını istiyorsunuz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-190">You want each unit test to be isolated and independent of others (with no side effects or dependencies).</span></span> <span data-ttu-id="bb3ee-191">Gerçek bir veritabanına karşı çalışırken, eyalet olması ve testler arasında sıfırlanması gerekir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-191">When working against a real database you have to be mindful of state and reset it between tests.</span></span>

<span data-ttu-id="bb3ee-192">Bu sorunları çözmek için "bağımlılık ekleme" adlı bir tasarım düzenine göz atalım ve testlerimizde gerçek bir veritabanı kullanma gereksinimini ortadan kaldırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-192">Let's look at a design pattern called "dependency injection" that can help us work around these issues and avoid the need to use a real database with our tests.</span></span>

### <a name="dependency-injection"></a><span data-ttu-id="bb3ee-193">Bağımlılık Ekleme</span><span class="sxs-lookup"><span data-stu-id="bb3ee-193">Dependency Injection</span></span>

<span data-ttu-id="bb3ee-194">Hemen DinnersController, DinnerRepository sınıfına sıkı bir şekilde "bağlanmış".</span><span class="sxs-lookup"><span data-stu-id="bb3ee-194">Right now DinnersController is tightly "coupled" to the DinnerRepository class.</span></span> <span data-ttu-id="bb3ee-195">"Kuponu" bir sınıfın çalışması için açıkça başka bir sınıfa bağlı olduğu bir durum anlamına gelir:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-195">"Coupling" refers to a situation where a class explicitly relies on another class in order to work:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample4.cs)]

<span data-ttu-id="bb3ee-196">DinnerRepository sınıfı bir veritabanına erişim gerektirdiğinden, DinnersController sınıfının sıkı şekilde bağlanmış bağımlılığı, DinnersController eylem yöntemlerinin test edilmesi için bir veritabanının olmasını gerektirmemizi gerektirir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-196">Because the DinnerRepository class requires access to a database, the tightly coupled dependency the DinnersController class has on the DinnerRepository ends up requiring us to have a database in order for the DinnersController action methods to be tested.</span></span>

<span data-ttu-id="bb3ee-197">Bu sorunu çözmek için "bağımlılık ekleme" adlı bir tasarım deseninin kullanıldığı bir yaklaşım olan, bağımlılıklar (veri erişimi sağlayan depo sınıfları gibi) bunları kullanan sınıflarda artık örtük olarak oluşturulmayacak.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-197">We can get around this by employing a design pattern called "dependency injection" – which is an approach where dependencies (like repository classes that provide data access) are no longer implicitly created within classes that use them.</span></span> <span data-ttu-id="bb3ee-198">Bunun yerine, bağımlılıklar, Oluşturucu bağımsız değişkenleri kullanarak bunları kullanan sınıfa açıkça geçirilebilir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-198">Instead, dependencies can be explicitly passed to the class that uses them using constructor arguments.</span></span> <span data-ttu-id="bb3ee-199">Bağımlılıklar arabirimler kullanılarak tanımlanmışsa, birim testi senaryoları için "sahte" bağımlılık uygulamalarında geçiş esnekliği elde ediyoruz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-199">If the dependencies are defined using interfaces, we then have the flexibility to pass in "fake" dependency implementations for unit test scenarios.</span></span> <span data-ttu-id="bb3ee-200">Bu, gerçekte bir veritabanına erişim gerektirmeyen, teste özel bağımlılık uygulamaları oluşturmamızı sağlar.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-200">This enables us to create test-specific dependency implementations that do not actually require access to a database.</span></span>

<span data-ttu-id="bb3ee-201">Bunu eylemde görmek için DinnersController ile bağımlılık ekleme işlemi uygulayalim.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-201">To see this in action, let's implement dependency injection with our DinnersController.</span></span>

#### <a name="extracting-an-idinnerrepository-interface"></a><span data-ttu-id="bb3ee-202">IDinnerRepository arabirimini ayıklama</span><span class="sxs-lookup"><span data-stu-id="bb3ee-202">Extracting an IDinnerRepository interface</span></span>

<span data-ttu-id="bb3ee-203">İlk adımımız, denetleyicilerimizin Dinerleri almak ve güncelleştirmek için gereken depo sözleşmesini kapsülleyen yeni bir IDinnerRepository arabirimi oluşturmaktır.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-203">Our first step will be to create a new IDinnerRepository interface that encapsulates the repository contract our controllers require to retrieve and update Dinners.</span></span>

<span data-ttu-id="bb3ee-204">Bu arabirim sözleşmesini \Modeller klasörüne sağ tıklayıp ardından **&gt;yeni öğe Ekle** menü komutunu seçerek ve IDinnerRepository.cs adlı yeni bir arabirim oluşturarak el ile tanımlayabiliriz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-204">We can define this interface contract manually by right-clicking on the \Models folder, and then choosing the **Add-&gt;New Item** menu command and creating a new interface named IDinnerRepository.cs.</span></span>

<span data-ttu-id="bb3ee-205">Alternatif olarak, var olan DinnerRepository sınıfımızın bir arabirimini otomatik olarak ayıklamak ve oluşturmak için yerleşik Visual Studio Professional (ve sonraki sürümler) yeniden düzenleme araçlarını kullanabiliriz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-205">Alternatively we can use the refactoring tools built-into Visual Studio Professional (and higher editions) to automatically extract and create an interface for us from our existing DinnerRepository class.</span></span> <span data-ttu-id="bb3ee-206">VS kullanarak bu arabirimi ayıklamak için, imleci DinnerRepository sınıfındaki metin düzenleyicisinde konumlandırın ve sonra sağ tıklayıp yeniden **Düzenle-&gt;ayıklamayı Ayıkla** menü komutunu seçin:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-206">To extract this interface using VS, simply position the cursor in the text editor on the DinnerRepository class, and then right-click and choose the **Refactor-&gt;Extract Interface** menu command:</span></span>

![](enable-automated-unit-testing/_static/image7.png)

<span data-ttu-id="bb3ee-207">Bu, "Arabirimi Ayıkla" iletişim kutusunu başlatacaktır ve oluşturulacak arabirimin adı için bizi ister.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-207">This will launch the "Extract Interface" dialog and prompt us for the name of the interface to create.</span></span> <span data-ttu-id="bb3ee-208">IDinnerRepository varsayılan olarak, arabirime eklemek için var olan DinnerRepository sınıfındaki tüm ortak yöntemleri otomatik olarak seçer:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-208">It will default to IDinnerRepository and automatically select all public methods on the existing DinnerRepository class to add to the interface:</span></span>

![](enable-automated-unit-testing/_static/image8.png)

<span data-ttu-id="bb3ee-209">"Tamam" düğmesine tıkladığımızda, Visual Studio uygulamamıza yeni bir IDinnerRepository arabirimi ekleyecek:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-209">When we click the "ok" button, Visual Studio will add a new IDinnerRepository interface to our application:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample5.cs)]

<span data-ttu-id="bb3ee-210">Ve var olan DinnerRepository sınıfımız, arabirimini uygulayan şekilde güncelleştirilecektir:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-210">And our existing DinnerRepository class will be updated so that it implements the interface:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample6.cs)]

#### <a name="updating-dinnerscontroller-to-support-constructor-injection"></a><span data-ttu-id="bb3ee-211">DinnersController 'i Oluşturucu ekleme işlemini destekleyecek şekilde güncelleştirme</span><span class="sxs-lookup"><span data-stu-id="bb3ee-211">Updating DinnersController to support constructor injection</span></span>

<span data-ttu-id="bb3ee-212">Şimdi, yeni arabirimi kullanmak için DinnersController sınıfını güncelleştireceğiz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-212">We'll now update the DinnersController class to use the new interface.</span></span>

<span data-ttu-id="bb3ee-213">Şu anda DinnersController, "dinnerRepository" alanı her zaman bir DinnerRepository sınıfı olacak şekilde sabit kodludur:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-213">Currently DinnersController is hard-coded such that its "dinnerRepository" field is always a DinnerRepository class:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample7.cs)]

<span data-ttu-id="bb3ee-214">Bunu, "dinnerRepository" alanı DinnerRepository yerine IDinnerRepository türünde olacak şekilde değiştireceksiniz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-214">We'll change it so that the "dinnerRepository" field is of type IDinnerRepository instead of DinnerRepository.</span></span> <span data-ttu-id="bb3ee-215">Daha sonra iki genel DinnersController Oluşturucusu ekleyeceğiz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-215">We'll then add two public DinnersController constructors.</span></span> <span data-ttu-id="bb3ee-216">Oluşturuculardan biri, bir IDinnerRepository bağımsız değişken olarak geçirilmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-216">One of the constructors allows an IDinnerRepository to be passed as an argument.</span></span> <span data-ttu-id="bb3ee-217">Diğeri, var olan DinnerRepository uygulamamızı kullanan varsayılan bir oluşturucudur:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-217">The other is a default constructor that uses our existing DinnerRepository implementation:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample8.cs)]

<span data-ttu-id="bb3ee-218">ASP.NET MVC Varsayılan oluşturucuları kullanarak denetleyici sınıfları oluşturduğundan, çalışma zamanındaki DinnersController, veri erişimi gerçekleştirmek için DinnerRepository sınıfını kullanmaya devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-218">Because ASP.NET MVC by default creates controller classes using default constructors, our DinnersController at runtime will continue to use the DinnerRepository class to perform data access.</span></span>

<span data-ttu-id="bb3ee-219">Artık birim testlerimizi güncelleştirebiliriz, ancak parametre oluşturucusunu kullanarak "sahte" bir akşam yemeği depo uygulamasını geçirmek için.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-219">We can now update our unit tests, though, to pass in a "fake" dinner repository implementation using the parameter constructor.</span></span> <span data-ttu-id="bb3ee-220">Bu "sahte" akşam yemeği deposu gerçek bir veritabanına erişim gerektirmez ve bunun yerine bellek içi örnek verileri kullanır.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-220">This "fake" dinner repository will not require access to a real database, and instead will use in-memory sample data.</span></span>

#### <a name="creating-the-fakedinnerrepository-class"></a><span data-ttu-id="bb3ee-221">FakeDinnerRepository sınıfı oluşturma</span><span class="sxs-lookup"><span data-stu-id="bb3ee-221">Creating the FakeDinnerRepository class</span></span>

<span data-ttu-id="bb3ee-222">Bir FakeDinnerRepository sınıfı oluşturalım.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-222">Let's create a FakeDinnerRepository class.</span></span>

<span data-ttu-id="bb3ee-223">Nerdakşam yemeği. Tests projemizdeki bir "Fakes" dizini oluşturup buna yeni bir FakeDinnerRepository sınıfı ekleyerek başlayacağız (klasöre sağ tıklayıp **Add-&gt;New Class**) ' i seçin:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-223">We'll begin by creating a "Fakes" directory within our NerdDinner.Tests project and then add a new FakeDinnerRepository class to it (right-click on the folder and choose **Add-&gt;New Class**):</span></span>

![](enable-automated-unit-testing/_static/image9.png)

<span data-ttu-id="bb3ee-224">Kodu FakeDinnerRepository sınıfının IDinnerRepository arabirimini uyguladığı şekilde güncelleştireceğiz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-224">We'll update the code so that the FakeDinnerRepository class implements the IDinnerRepository interface.</span></span> <span data-ttu-id="bb3ee-225">Daha sonra, üzerine sağ tıklayıp "arabirim IDinnerRepository Uygula" bağlam menüsü komutunu seçebilirsiniz:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-225">We can then right-click on it and choose the "Implement interface IDinnerRepository" context menu command:</span></span>

![](enable-automated-unit-testing/_static/image10.png)

<span data-ttu-id="bb3ee-226">Bu, Visual Studio 'nun tüm IDinnerRepository arabirimi üyelerini varsayılan "saplama çıkış" uygulamalarıyla FakeDinnerRepository sınıfımızda otomatik olarak eklemesine neden olur:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-226">This will cause Visual Studio to automatically add all of the IDinnerRepository interface members to our FakeDinnerRepository class with default "stub out" implementations:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample9.cs)]

<span data-ttu-id="bb3ee-227">Daha sonra FakeDinnerRepository uygulamasını, bir Oluşturucu bağımsız değişkeni olarak kendisine geçirilen akşam yemeği&gt; koleksiyonu&lt;bir bellek içi listede çalışmak üzere güncelleştirebiliriz:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-227">We can then update the FakeDinnerRepository implementation to work off of an in-memory List&lt;Dinner&gt; collection passed to it as a constructor argument:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample10.cs)]

<span data-ttu-id="bb3ee-228">Artık bir veritabanı gerektirmeyen sahte bir IDinnerRepository uygulamasıdır ve bunun yerine akşam yemeği nesnelerinin bellek içi bir listesini çalıştırabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-228">We now have a fake IDinnerRepository implementation that does not require a database, and can instead work off an in-memory list of Dinner objects.</span></span>

#### <a name="using-the-fakedinnerrepository-with-unit-tests"></a><span data-ttu-id="bb3ee-229">Birim testleriyle FakeDinnerRepository kullanma</span><span class="sxs-lookup"><span data-stu-id="bb3ee-229">Using the FakeDinnerRepository with Unit Tests</span></span>

<span data-ttu-id="bb3ee-230">Veritabanı kullanılamadığından daha önce başarısız olan DinnersController birim testlerine geri dönelim.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-230">Let's return to the DinnersController unit tests that failed earlier because the database wasn't available.</span></span> <span data-ttu-id="bb3ee-231">Test yöntemlerini aşağıdaki kodu kullanarak örnek bellek içi akşam yemeği verileriyle birlikte DinnersController ile doldurulmuş bir FakeDinnerRepository kullanacak şekilde güncelleştirebiliriz:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-231">We can update the test methods to use a FakeDinnerRepository populated with sample in-memory Dinner data to the DinnersController using the code below:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample11.cs)]

<span data-ttu-id="bb3ee-232">Şimdi de bu testleri çalıştırdığımızda her iki geçiş de yapılır:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-232">And now when we run these tests they both pass:</span></span>

![](enable-automated-unit-testing/_static/image11.png)

<span data-ttu-id="bb3ee-233">En iyisi, yalnızca saniyenin bir kısmını çalıştırırlar ve karmaşık kurulum/Temizleme mantığı gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-233">Best of all, they take only a fraction of a second to run, and do not require any complicated setup/cleanup logic.</span></span> <span data-ttu-id="bb3ee-234">Artık gerçek bir veritabanına bağlanmak zorunda kalmadan tüm DinnersController eylem yöntemi kodumuzu (listeleme, sayfalama, ayrıntılar, oluşturma, güncelleştirme ve silme dahil) test edebilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-234">We can now unit test all of our DinnersController action method code (including listing, paging, details, create, update and delete) without ever needing to connect to a real database.</span></span>

| <span data-ttu-id="bb3ee-235">**Kenar konusu: bağımlılık ekleme çerçeveleri**</span><span class="sxs-lookup"><span data-stu-id="bb3ee-235">**Side Topic: Dependency Injection Frameworks**</span></span> |
| --- |
| <span data-ttu-id="bb3ee-236">El ile bağımlılık ekleme (yukarıda yaptığımız gibi) gerçekleştiriyoruz, ancak bir uygulamadaki bağımlılıkların ve bileşenlerin sayısı arttıkça devam etmek daha zor hale gelir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-236">Performing manual dependency injection (like we are above) works fine, but does become harder to maintain as the number of dependencies and components in an application increases.</span></span> <span data-ttu-id="bb3ee-237">.NET için birçok bağımlılık ekleme çerçevesi, daha da fazla bağımlılık yönetimi esnekliği sağlamaya yardımcı olabilir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-237">Several dependency injection frameworks exist for .NET that can help provide even more dependency management flexibility.</span></span> <span data-ttu-id="bb3ee-238">Ayrıca, bazen "Control of Control" (IOC) kapsayıcıları olarak da adlandırılan bu çerçeveler, çalışma zamanında nesnelere bağımlılıklar belirtme ve geçirme için ek yapılandırma desteğinin sağlanmasına olanak tanıyan mekanizmalar sağlar (çoğunlukla Oluşturucu Ekleme kullanarak). ).</span><span class="sxs-lookup"><span data-stu-id="bb3ee-238">These frameworks, also sometimes called "Inversion of Control" (IoC) containers, provide mechanisms that enable an additional level of configuration support for specifying and passing dependencies to objects at runtime (most often using constructor injection).</span></span> <span data-ttu-id="bb3ee-239">.NET 'teki daha popüler OSS bağımlılığı ekleme/ıOC çerçevelerinden bazıları şunlardır: AutoFac, Neklemesine, Spring.NET, StructureMap ve Wınossor.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-239">Some of the more popular OSS Dependency Injection / IOC frameworks in .NET include: AutoFac, Ninject, Spring.NET, StructureMap, and Windsor.</span></span> <span data-ttu-id="bb3ee-240">ASP.NET MVC, geliştiricilerin çözüme ve örneklemesine katılmasını sağlayan ve bağımlılık ekleme/IOC çerçevelerinin bu işlem dahilinde düzgün bir şekilde tümleştirilebilmesi için genişletilebilirlik API 'Leri sunar.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-240">ASP.NET MVC exposes extensibility APIs that enable developers to participate in the resolution and instantiation of controllers, and which enables Dependency Injection / IoC frameworks to be cleanly integrated within this process.</span></span> <span data-ttu-id="bb3ee-241">Bir dı/ıOC çerçevesinin kullanılması Ayrıca, DinnersController ' dan varsayılan oluşturucuyu kaldırmamızı sağlar; Bu, ile DinnerRepository arasındaki kuponu tamamen kaldırır.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-241">Using a DI/IOC framework would also enable us to remove the default constructor from our DinnersController – which would completely remove the coupling between it and the DinnerRepository.</span></span> <span data-ttu-id="bb3ee-242">Nerdakşam yemeği uygulamamız ile bir bağımlılık ekleme/ıOC çerçevesi kullanmayacağız.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-242">We won't be using a dependency injection / IOC framework with our NerdDinner application.</span></span> <span data-ttu-id="bb3ee-243">Ancak, Nerdakşam yemeği kod tabanı ve özellikleri grew ise gelecek için göz önünde bulundurduğumuz bir şeydir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-243">But it is something we could consider for the future if the NerdDinner code-base and capabilities grew.</span></span> |

### <a name="creating-edit-action-unit-tests"></a><span data-ttu-id="bb3ee-244">Düzenleme eylemi birim testlerini oluşturma</span><span class="sxs-lookup"><span data-stu-id="bb3ee-244">Creating Edit Action Unit Tests</span></span>

<span data-ttu-id="bb3ee-245">Şimdi, DinnersController 'in düzenleme işlevini doğrulayan bazı birim testleri oluşturalım.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-245">Let's now create some unit tests that verify the Edit functionality of the DinnersController.</span></span> <span data-ttu-id="bb3ee-246">Düzenleme eylemimizin HTTP-Al sürümünü test ederek başlayacağız:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-246">We'll start by testing the HTTP-GET version of our Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample12.cs)]

<span data-ttu-id="bb3ee-247">Geçerli bir akşam yemeği istendiğinde, bir DinnerFormViewModel nesnesi tarafından desteklenen bir görünümün geri işlenip işlenmeyeceğini doğrulayan bir test oluşturacağız:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-247">We'll create a test that verifies that a View backed by a DinnerFormViewModel object is rendered back when a valid dinner is requested:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample13.cs)]

<span data-ttu-id="bb3ee-248">Testi çalıştırdığımızda, düzenleme yöntemi akşam yemeği. ıshostedby () denetimini gerçekleştirmek üzere User.Identity.Name özelliğine eriştiğinde null başvuru özel durumu atıldığı için başarısız olduğunu öğreniyoruz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-248">When we run the test, though, we'll find that it fails because a null reference exception is thrown when the Edit method accesses the User.Identity.Name property to perform the Dinner.IsHostedBy() check.</span></span>

<span data-ttu-id="bb3ee-249">Denetleyici temel sınıfındaki Kullanıcı nesnesi, oturum açmış kullanıcıyla ilgili ayrıntıları kapsüller ve çalışma zamanında denetleyici oluşturduğunda ASP.NET MVC tarafından doldurulur.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-249">The User object on the Controller base class encapsulates details about the logged-in user, and is populated by ASP.NET MVC when it creates the controller at runtime.</span></span> <span data-ttu-id="bb3ee-250">DinnersController 'i bir Web-Server ortamının dışında test ettiğimiz için, Kullanıcı nesnesi ayarlı değil (Bu nedenle, null başvuru özel durumu).</span><span class="sxs-lookup"><span data-stu-id="bb3ee-250">Because we are testing the DinnersController outside of a web-server environment, the User object isn't set (hence the null reference exception).</span></span>

### <a name="mocking-the-useridentityname-property"></a><span data-ttu-id="bb3ee-251">User.Identity.Name özelliğini moclama</span><span class="sxs-lookup"><span data-stu-id="bb3ee-251">Mocking the User.Identity.Name property</span></span>

<span data-ttu-id="bb3ee-252">Mocking çerçeveleri, testlerinizi destekleyen bağımlı nesnelerin sahte sürümlerini dinamik olarak oluşturmamızı sağlayarak testi daha kolay hale getirir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-252">Mocking frameworks make testing easier by enabling us to dynamically create fake versions of dependent objects that support our tests.</span></span> <span data-ttu-id="bb3ee-253">Örneğin, DinnersController 'in sanal bir kullanıcı adını aramak için kullanabileceği bir Kullanıcı nesnesini dinamik olarak oluşturmak için düzenleme eylemi testimizde bir sahte işlem çerçevesi kullanabiliriz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-253">For example, we can use a mocking framework in our Edit action test to dynamically create a User object that our DinnersController can use to lookup a simulated username.</span></span> <span data-ttu-id="bb3ee-254">Bu, test çalıştırdığımız zaman bir null başvurusunun oluşmasını önler.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-254">This will avoid a null reference from being thrown when we run our test.</span></span>

<span data-ttu-id="bb3ee-255">ASP.NET MVC ile kullanılabilen birçok .net sahte işlem çerçevesi vardır (bunların bir listesini burada görebilirsiniz: [http://www.mockframeworks.com/](http://www.mockframeworks.com/)).</span><span class="sxs-lookup"><span data-stu-id="bb3ee-255">There are many .NET mocking frameworks that can be used with ASP.NET MVC (you can see a list of them here: [http://www.mockframeworks.com/](http://www.mockframeworks.com/)).</span></span> <span data-ttu-id="bb3ee-256">Nerdakşam yemeği uygulamanızı test etmek için, [http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq)ücretsiz olarak indirilebilen, "moq" adlı açık kaynaklı bir sahte işlem çerçevesi kullanacağız.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-256">For testing our NerdDinner application we'll use an open source mocking framework called "Moq", which can be downloaded for free from [http://www.mockframeworks.com/moq](http://www.mockframeworks.com/moq).</span></span>

<span data-ttu-id="bb3ee-257">İndirildikten sonra, Nerdakşam. test projemizdeki moq. dll derlemesine bir başvuru ekleyeceğiz:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-257">Once downloaded, we'll add a reference in our NerdDinner.Tests project to the Moq.dll assembly:</span></span>

![](enable-automated-unit-testing/_static/image12.png)

<span data-ttu-id="bb3ee-258">Daha sonra bir parametre olarak Kullanıcı adı alan ve daha sonra DinnersController örneğindeki User.Identity.Name özelliğini "bir" CreateDinnersControllerAs (username) "yardımcı yöntemi ekleyeceğiz:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-258">We'll then add a "CreateDinnersControllerAs(username)" helper method to our test class that takes a username as a parameter, and which then "mocks" the User.Identity.Name property on the DinnersController instance:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample14.cs)]

<span data-ttu-id="bb3ee-259">Yukarıda, bir ControllerContext nesnesini kullanan bir sahte nesne (ASP.NET MVC 'nin Kullanıcı, Istek, yanıt ve oturum gibi çalışma zamanı nesnelerini kullanıma sunmak için denetleyici sınıflarına ne kadar başarılı olduğunu) oluşturmak için moq kullanıyoruz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-259">Above we are using Moq to create a Mock object that fakes a ControllerContext object (which is what ASP.NET MVC passes to Controller classes to expose runtime objects like User, Request, Response, and Session).</span></span> <span data-ttu-id="bb3ee-260">ControllerContext üzerinde HttpContext.User.Identity.Name özelliğinin yardımcı metoduna geçirdiğimiz Kullanıcı adı dizesini döndürmesi gerektiğini göstermek için, "SetupGet" yöntemini geliştirdik.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-260">We are calling the "SetupGet" method on the Mock to indicate that the HttpContext.User.Identity.Name property on ControllerContext should return the username string we passed to the helper method.</span></span>

<span data-ttu-id="bb3ee-261">Herhangi bir sayıda ControllerContext özelliği ve yöntemi olabilir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-261">We can mock any number of ControllerContext properties and methods.</span></span> <span data-ttu-id="bb3ee-262">Bunu göstermek için, Request. IsAuthenticated özelliği için bir SetupGet () çağrısı ekledik (Bu aslında aşağıdaki testler için gerekli değildir, ancak Istek özelliklerinin nasıl sahte olduğunu göstermeye yardımcı olur).</span><span class="sxs-lookup"><span data-stu-id="bb3ee-262">To illustrate this I've also added a SetupGet() call for the Request.IsAuthenticated property (which isn't actually needed for the tests below – but which helps illustrate how you can mock Request properties).</span></span> <span data-ttu-id="bb3ee-263">İşiniz bittiğinde, DinnersController yardımcı yöntemimizin döndürdüğü bir ControllerContext 'in bir örneğini atamamız.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-263">When we are done we assign an instance of the ControllerContext mock to the DinnersController our helper method returns.</span></span>

<span data-ttu-id="bb3ee-264">Artık, farklı kullanıcılar ile ilgili düzenleme senaryolarını test etmek için bu yardımcı yöntemi kullanan birim testleri yazalım:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-264">We can now write unit tests that use this helper method to test Edit scenarios involving different users:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample15.cs)]

<span data-ttu-id="bb3ee-265">Şimdi, başarılı olan testleri çalıştırdığımızda:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-265">And now when we run the tests they pass:</span></span>

![](enable-automated-unit-testing/_static/image13.png)

### <a name="testing-updatemodel-scenarios"></a><span data-ttu-id="bb3ee-266">UpdateModel () senaryolarını test etme</span><span class="sxs-lookup"><span data-stu-id="bb3ee-266">Testing UpdateModel() scenarios</span></span>

<span data-ttu-id="bb3ee-267">Düzenleme eyleminin HTTP-Al sürümünü kapsayan testler oluşturduk.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-267">We've created tests that cover the HTTP-GET version of the Edit action.</span></span> <span data-ttu-id="bb3ee-268">Şimdi, düzenleme eyleminin HTTP-POST sürümünü doğrulayan bazı sınamalar oluşturalım:</span><span class="sxs-lookup"><span data-stu-id="bb3ee-268">Let's now create some tests that verify the HTTP-POST version of the Edit action:</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample16.cs)]

<span data-ttu-id="bb3ee-269">Bu eylem yöntemiyle desteketmemizi istediğiniz ilginç yeni test senaryosu, denetleyici temel sınıfındaki UpdateModel () yardımcı yönteminin kullanımındır.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-269">The interesting new testing scenario for us to support with this action method is its usage of the UpdateModel() helper method on the Controller base class.</span></span> <span data-ttu-id="bb3ee-270">Bu yardımcı yöntemi, form gönderme değerlerini akşam yemeği nesne örneğimize bağlamak için kullanıyoruz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-270">We are using this helper method to bind form-post values to our Dinner object instance.</span></span>

<span data-ttu-id="bb3ee-271">Aşağıda, kullanılacak UpdateModel () yardımcı yöntemi için postalanan değerleri nasıl sağlayabiliriz gösteren iki test verilmiştir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-271">Below are two tests that demonstrates how we can supply form posted values for the UpdateModel() helper method to use.</span></span> <span data-ttu-id="bb3ee-272">Bunu bir FormCollection nesnesi oluşturup doldurarak ve sonra denetleyicideki "ValueProvider" özelliğine atayarak yapacağız.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-272">We'll do this by creating and populating a FormCollection object, and then assign it to the "ValueProvider" property on the Controller.</span></span>

<span data-ttu-id="bb3ee-273">İlk test, tarayıcıyı başarılı bir şekilde Kaydet ' in Ayrıntılar eylemine yeniden yönlendirildiğini doğrular.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-273">The first test verifies that on a successful save the browser is redirected to the details action.</span></span> <span data-ttu-id="bb3ee-274">İkinci test, geçersiz giriş gönderildiğinde, işlem düzenleme görünümünü bir hata iletisiyle yeniden görüntüler.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-274">The second test verifies that when invalid input is posted the action redisplays the edit view again with an error message.</span></span>

[!code-csharp[Main](enable-automated-unit-testing/samples/sample17.cs)]

### <a name="testing-wrap-up"></a><span data-ttu-id="bb3ee-275">Kaydırmayı test etme</span><span class="sxs-lookup"><span data-stu-id="bb3ee-275">Testing Wrap-Up</span></span>

<span data-ttu-id="bb3ee-276">Birim testi denetleyici sınıflarıyla ilgili temel kavramları ele aldık.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-276">We've covered the core concepts involved in unit testing controller classes.</span></span> <span data-ttu-id="bb3ee-277">Uygulamamızın davranışını doğrulayan yüzlerce basit testi kolayca oluşturmak için bu teknikleri kullanabiliriz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-277">We can use these techniques to easily create hundreds of simple tests that verify the behavior of our application.</span></span>

<span data-ttu-id="bb3ee-278">Denetleyicimiz ve model testleriniz gerçek bir veritabanı gerektirmediğinden, bunlar son derece hızlı ve kolay bir şekilde çalışır.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-278">Because our controller and model tests do not require a real database, they are extremely fast and easy to run.</span></span> <span data-ttu-id="bb3ee-279">Saniyeler içinde yüzlerce otomatik test yürütebilecektir ve yaptığımız bir değişikliğin bir şeyi yapıp yapmadığımızda anında geri bildirim alırsınız.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-279">We'll be able to execute hundreds of automated tests in seconds, and immediately get feedback as to whether a change we made broke something.</span></span> <span data-ttu-id="bb3ee-280">Bu, uygulamamızı sürekli iyileştirme, yeniden düzenleme ve iyileştirmenin güvencesi sağlamasına yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-280">This will help provide us the confidence to continually improve, refactor, and refine our application.</span></span>

<span data-ttu-id="bb3ee-281">Testi bu bölümün son konusu olarak ele aldık, ancak test bir geliştirme sürecinin sonunda yapmanız gereken bir şeydir!</span><span class="sxs-lookup"><span data-stu-id="bb3ee-281">We covered testing as the last topic in this chapter – but not because testing is something you should do at the end of a development process!</span></span> <span data-ttu-id="bb3ee-282">Aksine, geliştirme sürecinizde otomatik testleri mümkün olduğunca erken yazmanız gerekir.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-282">On the contrary, you should write automated tests as early as possible in your development process.</span></span> <span data-ttu-id="bb3ee-283">Böylece geliştirme sırasında anında geri bildirimde bulunmanızı sağlar, uygulamanızın kullanım örneği senaryolarınız hakkında daha fazla bilgi almanızı düşünmenize yardımcı olur ve uygulamanızı temiz katmanla ve daha sonra göz önünde bulundurarak tasarlamanıza kılavuzluk eder.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-283">Doing so enables you to get immediate feedback as you develop, helps you think thoughtfully about your application's use case scenarios, and guides you to design your application with clean layering and coupling in mind.</span></span>

<span data-ttu-id="bb3ee-284">Kitapta daha sonraki bir bölümde test odaklı geliştirme (TDD) ve ASP.NET MVC ile nasıl kullanılacağı ele alınacaktır.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-284">A later chapter in the book will discuss Test Driven Development (TDD), and how to use it with ASP.NET MVC.</span></span> <span data-ttu-id="bb3ee-285">TDD, sonuçta elde edilen kodunuzun karşılaacağı testleri ilk yazdığınız yinelemeli bir kodlama uygulamasıdır.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-285">TDD is an iterative coding practice where you first write the tests that your resulting code will satisfy.</span></span> <span data-ttu-id="bb3ee-286">TDD ile, uygulamak üzere olduğunuz işlevselliği doğrulayan bir test oluşturarak her bir özelliği başlatın.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-286">With TDD you begin each feature by creating a test that verifies the functionality you are about to implement.</span></span> <span data-ttu-id="bb3ee-287">Öncelikle birim testi yazmak, özelliği net bir şekilde anladığınızdan ve çalışmanın nasıl çalıştığınızdan emin olmanıza yardımcı olur.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-287">Writing the unit test first helps ensure that you clearly understand the feature and how it is supposed to work.</span></span> <span data-ttu-id="bb3ee-288">Yalnızca test yazıldıktan sonra (ve başarısız olduğunu doğruladıktan sonra), test tarafından doğrulanan gerçek işlevselliği uygulayın.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-288">Only after the test is written (and you have verified that it fails) do you then implement the actual functionality the test verifies.</span></span> <span data-ttu-id="bb3ee-289">Özelliğin nasıl çalışacağından ilgili kullanım durumu hakkında daha fazla zaman harcadığınız için, gereksinimlerin ve ne kadar en iyi şekilde faydalanacağınızı daha iyi anlayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-289">Because you've already spent time thinking about the use case of how the feature is supposed to work, you will have a better understanding of the requirements and how best to implement them.</span></span> <span data-ttu-id="bb3ee-290">Uygulama ile işiniz bittiğinde, testi yeniden çalıştırabilir ve özelliğin doğru şekilde çalışıp çalışmadığını anında geri bildirimde bulabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-290">When you are done with the implementation you can re-run the test – and get immediate feedback as to whether the feature works correctly.</span></span> <span data-ttu-id="bb3ee-291">Bölüm 10 ' da TDD daha fazla ele alınacaktır.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-291">We'll cover TDD more in Chapter 10.</span></span>

### <a name="next-step"></a><span data-ttu-id="bb3ee-292">Sonraki adım</span><span class="sxs-lookup"><span data-stu-id="bb3ee-292">Next Step</span></span>

<span data-ttu-id="bb3ee-293">Bazı son sarmalar açıklamaları.</span><span class="sxs-lookup"><span data-stu-id="bb3ee-293">Some final wrap up comments.</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="bb3ee-294">[Önceki](use-ajax-to-implement-mapping-scenarios.md)
> [İleri](nerddinner-wrap-up.md)</span><span class="sxs-lookup"><span data-stu-id="bb3ee-294">[Previous](use-ajax-to-implement-mapping-scenarios.md)
[Next](nerddinner-wrap-up.md)</span></span>
