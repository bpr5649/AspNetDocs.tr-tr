---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: ASP.NET MVC ve Web sayfalarında XSRF/CSRF önleme | Microsoft Docs
author: Rick-Anderson
description: Siteler arası istek sahteciliği (XSRF veya CSRF olarak da bilinir), kötü amaçlı bir Web sitesinin ınteracti 'yi etkileyebilecek Web 'de barındırılan uygulamalara karşı bir saldırıya karşı bir saldırıdır...
ms.author: riande
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: 1965063a9b613d0e2857cddcc2165f5fda64ec0c
ms.sourcegitcommit: 7709c0a091b8d55b7b33bad8849f7b66b23c3d72
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 02/19/2020
ms.locfileid: "77455535"
---
# <a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="8b471-103">ASP.NET MVC ve Web Sayfalarında XSRF/CSRF Önleme</span><span class="sxs-lookup"><span data-stu-id="8b471-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>

<span data-ttu-id="8b471-104">[Rick Anderson](https://twitter.com/RickAndMSFT) tarafından</span><span class="sxs-lookup"><span data-stu-id="8b471-104">by [Rick Anderson](https://twitter.com/RickAndMSFT)</span></span>

> <span data-ttu-id="8b471-105">Siteler arası istek sahteciliği (XSRF veya CSRF olarak da bilinir), kötü amaçlı bir Web sitesinin bir istemci tarayıcısı ile bu tarayıcı tarafından güvenilen bir Web sitesi arasındaki etkileşimi etkileyebilecek Web 'de barındırılan uygulamalara karşı bir saldırıya karşı bir saldırıdır.</span><span class="sxs-lookup"><span data-stu-id="8b471-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="8b471-106">Web tarayıcıları her bir Web sitesi isteğiyle otomatik olarak kimlik doğrulama belirteçleri gönderebileceğinden, bu saldırılar mümkün hale getirilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="8b471-107">Kurallı örnek, ASP gibi bir kimlik doğrulama tanımlama bilgisidir. NET ' in Forms kimlik doğrulama bileti.</span><span class="sxs-lookup"><span data-stu-id="8b471-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="8b471-108">Ancak, herhangi bir kalıcı kimlik doğrulama mekanizması (örneğin, Windows kimlik doğrulaması, temel vb.) kullanan Web siteleri bu saldırılar tarafından hedeflenebilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="8b471-109">Bir XSRF saldırısı, kimlik avı saldırısından farklıdır.</span><span class="sxs-lookup"><span data-stu-id="8b471-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="8b471-110">Sızdırma saldırıları, kurban 'ten etkileşim gerektirir.</span><span class="sxs-lookup"><span data-stu-id="8b471-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="8b471-111">Bir sızdırma saldırısında, kötü amaçlı bir Web sitesi hedef Web sitesini taklit eder ve kurban, saldırgana duyarlı bilgiler sağlamaya çalışır.</span><span class="sxs-lookup"><span data-stu-id="8b471-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="8b471-112">Bir XSRF saldırısında, genellikle kurban için gereken bir etkileşim yoktur.</span><span class="sxs-lookup"><span data-stu-id="8b471-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="8b471-113">Bunun yerine saldırgan, tüm ilgili tanımlama bilgilerini hedef Web sitesine otomatik olarak göndererek tarayıcıya bağlı olur.</span><span class="sxs-lookup"><span data-stu-id="8b471-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="8b471-114">Daha fazla bilgi için [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="8b471-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>

## <a name="anatomy-of-an-attack"></a><span data-ttu-id="8b471-115">Bir saldırının anatomumu</span><span class="sxs-lookup"><span data-stu-id="8b471-115">Anatomy of an attack</span></span>

<span data-ttu-id="8b471-116">Bir XSRF saldırısında gezinmek için, bazı çevrimiçi bankacılık işlemlerini gerçekleştirmek isteyen bir kullanıcıyı göz önünde bulundurun.</span><span class="sxs-lookup"><span data-stu-id="8b471-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="8b471-117">Bu Kullanıcı, içindeki WoodgroveBank.com ve günlükleri ilk kez ziyaret eder; bu noktada yanıt üst bilgisi kimlik doğrulama tanımlama bilgisini içerir:</span><span class="sxs-lookup"><span data-stu-id="8b471-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="8b471-118">Kimlik doğrulama tanımlama bilgisi bir oturum tanımlama bilgisi olduğundan, tarayıcı işlemi çıktığında tarayıcı tarafından otomatik olarak temizlenir.</span><span class="sxs-lookup"><span data-stu-id="8b471-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="8b471-119">Ancak, bu zamana kadar tarayıcı otomatik olarak her bir WoodgroveBank.com isteğine sahip tanımlama bilgisini dahil eder.</span><span class="sxs-lookup"><span data-stu-id="8b471-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com.</span></span> <span data-ttu-id="8b471-120">Kullanıcı şimdi başka bir hesaba $1000 aktarmak istiyor, bu nedenle bankacılık sitesinde bir form doldurmuş ve tarayıcı bu isteği sunucuya getiriyor:</span><span class="sxs-lookup"><span data-stu-id="8b471-120">The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="8b471-121">Bu işlemin bir yan etkisi olduğundan (parasal bir işlem başlatır), bu işlemi başlatmak için bankacılık sitesi bir HTTP POST gerektirmesini seçti.</span><span class="sxs-lookup"><span data-stu-id="8b471-121">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="8b471-122">Sunucu, istekten kimlik doğrulama belirtecini okur, geçerli kullanıcının hesap numarasını arar, yeterli fon olduğunu doğrular ve ardından işlemi hedef hesaba başlatır.</span><span class="sxs-lookup"><span data-stu-id="8b471-122">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="8b471-123">Çevrimiçi bankacılık tamamlanmıştır, Kullanıcı bankacılık sitesinden uzaklaştırabilir ve Web 'deki diğer konumları ziyaret ettiğinde.</span><span class="sxs-lookup"><span data-stu-id="8b471-123">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="8b471-124">Bu sitelerden biri – fabrikam.com – &lt;iframe&gt;eklenmiş bir sayfada aşağıdaki biçimlendirmeyi içerir:</span><span class="sxs-lookup"><span data-stu-id="8b471-124">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="8b471-125">Böylece tarayıcının bu isteği yapmasına neden olur:</span><span class="sxs-lookup"><span data-stu-id="8b471-125">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="8b471-126">Saldırgan, kullanıcının hedef Web sitesi için geçerli bir kimlik doğrulama belirtecine sahip olabileceği ve tarayıcının hedef siteye otomatik olarak bir HTTP POST işlemi yapmasını sağlamak için küçük bir JavaScript kod parçacığı kullanmakta olduğundan emin olmaya başlamıştır.</span><span class="sxs-lookup"><span data-stu-id="8b471-126">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="8b471-127">Kimlik doğrulama belirteci hala geçerliyse, bankacılık sitesi, saldırganın tercih ettiği hesaba $250 aktarımını başlatır.</span><span class="sxs-lookup"><span data-stu-id="8b471-127">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="8b471-128">Etkisiz azaltmaları</span><span class="sxs-lookup"><span data-stu-id="8b471-128">Ineffective mitigations</span></span>

<span data-ttu-id="8b471-129">Yukarıdaki senaryoda, WoodgroveBank.com 'in SSL aracılığıyla erişildiği ve saldırı için yalnızca bir SSL kimlik doğrulama tanımlama bilgisinin yetersiz olduğunu düşündüğüne dikkat edin.</span><span class="sxs-lookup"><span data-stu-id="8b471-129">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="8b471-130">Saldırgan, &lt;form&gt; öğesinde [URI şeması](http://en.wikipedia.org/wiki/URI_scheme) (https) belirtebilir ve bu tanımlama bilgileri amaçlanan hedefin URI şeması ile tutarlı olduğu sürece tarayıcı, geçerliliği olmayan tanımlama bilgilerini hedef siteye göndermeye devam edecektir.</span><span class="sxs-lookup"><span data-stu-id="8b471-130">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="8b471-131">Yalnızca güvenilen siteleri ziyaret etmek, güvenli çevrimiçi olmaya yardımcı olduğundan, Kullanıcı yalnızca güvenilmeyen siteleri ziyaret etmemelidir.</span><span class="sxs-lookup"><span data-stu-id="8b471-131">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="8b471-132">Bunun için bazı gerçeği vardır, ancak bu öneri her zaman pratik değildir.</span><span class="sxs-lookup"><span data-stu-id="8b471-132">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="8b471-133">Belki de Kullanıcı, yerel haber sitesi ConsolidatedMessenger "güvenir".</span><span class="sxs-lookup"><span data-stu-id="8b471-133">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="8b471-134">ConsolidatedMessenger.com ve bunun yerine bu siteyi ziyaret edin, ancak bu sitede, bir saldırganın fabrikam.com üzerinde çalışan aynı kod parçacığını eklemesine izin veren bir XSS Güvenlik açığı vardır.</span><span class="sxs-lookup"><span data-stu-id="8b471-134">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="8b471-135">Gelen isteklerin, etki alanına başvuran bir [Referer üst bilgisine](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) sahip olduğunu doğrulayabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8b471-135">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="8b471-136">Bu, bir üçüncü taraf etki alanından gönderilen isteklerin farkında olarak durdurulur.</span><span class="sxs-lookup"><span data-stu-id="8b471-136">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="8b471-137">Bununla birlikte, bazı kullanıcılar tarayıcının Referer üst bilgisini gizlilik nedenleriyle devre dışı bırakır ve kurban bazı güvenli olmayan yazılımların yüklü olduğu durumlarda saldırganlar bu üstbilgiyi taklit edebilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-137">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="8b471-138">[Başvuru üst bilgisinin](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) DOĞRULANMASı, XSRF saldırılarını önlemek için güvenli bir yaklaşım olarak kabul edilmez.</span><span class="sxs-lookup"><span data-stu-id="8b471-138">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="8b471-139">Web yığını çalışma zamanı XSRF azaltmaları</span><span class="sxs-lookup"><span data-stu-id="8b471-139">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="8b471-140">ASP.NET Web Stack çalışma zamanı, XSRF saldırılarına karşı savunmak için [Eşitleyici belirteç deseninin](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) bir türevini kullanır.</span><span class="sxs-lookup"><span data-stu-id="8b471-140">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="8b471-141">Eşitleyici belirteç deseninin genel formu, her HTTP gönderimiyle (kimlik doğrulama belirtecine ek olarak) sunucuya iki anti-XSRF belirtecinin gönderilmesinin yanı sıra, tanımlama bilgisi olarak bir belirteç ve diğeri de bir form değeri olarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="8b471-141">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="8b471-142">ASP.NET çalışma zamanı tarafından oluşturulan belirteç değerleri, bir saldırgan tarafından belirleyici veya öngörülebilir değildir.</span><span class="sxs-lookup"><span data-stu-id="8b471-142">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="8b471-143">Belirteçler gönderildiğinde sunucu, isteğin yalnızca her iki belirteç de bir karşılaştırma denetimi iletmesine izin verir.</span><span class="sxs-lookup"><span data-stu-id="8b471-143">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="8b471-144">XSRF isteği doğrulama *oturum belirteci* bir http tanımlama bilgisi olarak depolanır ve şu anda yükünde şu bilgileri içerir:</span><span class="sxs-lookup"><span data-stu-id="8b471-144">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="8b471-145">Rastgele bir 128 bit tanımlayıcısından oluşan bir güvenlik belirteci.</span><span class="sxs-lookup"><span data-stu-id="8b471-145">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="8b471-146">Aşağıdaki görüntüde, Internet Explorer F12 geliştirici araçları ile gösterilen XSRF isteği doğrulama oturum belirteci gösterilmektedir: (Bu, geçerli uygulama ve büyük olasılıkla, değişebilir, yani değiştirilebilir.)</span><span class="sxs-lookup"><span data-stu-id="8b471-146">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="8b471-147">*Alan belirteci* bir `<input type="hidden" />` olarak depolanır ve yükünde aşağıdaki bilgileri içerir:</span><span class="sxs-lookup"><span data-stu-id="8b471-147">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="8b471-148">Oturum açmış kullanıcının Kullanıcı adı (kimliği doğrulanmışsa).</span><span class="sxs-lookup"><span data-stu-id="8b471-148">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="8b471-149">[Iantiforgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)tarafından sunulan ek veriler.</span><span class="sxs-lookup"><span data-stu-id="8b471-149">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="8b471-150">Anti-XSRF belirteçleri 'nin yükleri şifrelenir ve imzalanır, bu nedenle belirteçleri incelemek için araçları kullanırken kullanıcı adını görüntüleyemezsiniz.</span><span class="sxs-lookup"><span data-stu-id="8b471-150">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="8b471-151">Web uygulaması ASP.NET 4,0 ' i hedeflerken, Şifreleme Hizmetleri [machineKey. Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) yordamı tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="8b471-151">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="8b471-152">Web uygulaması ASP.NET 4,5 veya üstünü hedeflerken, şifreleme hizmetleri, daha iyi performans, genişletilebilirlik ve güvenlik sunan [machineKey. Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) yordamı tarafından sağlanır.</span><span class="sxs-lookup"><span data-stu-id="8b471-152">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="8b471-153">Daha fazla ayrıntı için aşağıdaki blog gönderilerine bakın:</span><span class="sxs-lookup"><span data-stu-id="8b471-153">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="8b471-154">ASP.NET 4,5, pt. 1 ' de şifreleme geliştirmeleri</span><span class="sxs-lookup"><span data-stu-id="8b471-154">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="8b471-155">ASP.NET 4,5, pt. 2 ' de şifreleme geliştirmeleri</span><span class="sxs-lookup"><span data-stu-id="8b471-155">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="8b471-156">ASP.NET 4,5, pt. 3 ' te şifreleme geliştirmeleri</span><span class="sxs-lookup"><span data-stu-id="8b471-156">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="8b471-157">Belirteçleri oluşturma</span><span class="sxs-lookup"><span data-stu-id="8b471-157">Generating the tokens</span></span>

<span data-ttu-id="8b471-158">Anti-XSRF belirteçlerini oluşturmak için bir MVC görünümünden [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) yöntemini veya Razor sayfasından @AntiForgery.GetHtml() çağırın.</span><span class="sxs-lookup"><span data-stu-id="8b471-158">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="8b471-159">Çalışma zamanı daha sonra aşağıdaki adımları gerçekleştirir:</span><span class="sxs-lookup"><span data-stu-id="8b471-159">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="8b471-160">Geçerli HTTP isteği zaten bir anti-xsrf oturum belirteci içeriyorsa (\_Requestdoğrulamaları Icationtoken \_Anti-XSRF Cookie), güvenlik belirteci bundan ayıklanır.</span><span class="sxs-lookup"><span data-stu-id="8b471-160">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="8b471-161">HTTP isteği bir anti-XSRF oturum belirteci içermiyorsa veya güvenlik belirtecinin ayıklanması başarısız olursa, yeni bir rastgele Anti-XSRF belirteci oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="8b471-161">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="8b471-162">Bir anti-XSRF alan belirteci, yukarıdaki adım (1) ve oturum açmış geçerli kullanıcının kimliği kullanılarak oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="8b471-162">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="8b471-163">(Kullanıcı kimliğini belirleme hakkında daha fazla bilgi için aşağıdaki **[özel desteğe sahip senaryolar](#_Scenarios_with_special)** bölümüne bakın.) Ek olarak, bir [ıantiforgeryadditionaldataprovider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) yapılandırıldıysa, çalışma zamanı, [Getaddıtionaldata](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) metodunu çağırır ve döndürülen dizeyi alan belirtecine dahil eder.</span><span class="sxs-lookup"><span data-stu-id="8b471-163">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="8b471-164">(Daha fazla bilgi için **[yapılandırma ve genişletilebilirlik](#_Configuration_and_extensibility)** bölümüne bakın.)</span><span class="sxs-lookup"><span data-stu-id="8b471-164">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="8b471-165">Adımda (1) yeni bir anti-XSRF belirteci oluşturulduysa, bunu içerecek yeni bir oturum belirteci oluşturulur ve giden HTTP tanımlama bilgileri koleksiyonuna eklenecektir.</span><span class="sxs-lookup"><span data-stu-id="8b471-165">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="8b471-166">Adımdaki alan belirteci (2) bir `<input type="hidden" />` öğesinde Sarmalanacak ve bu HTML biçimlendirmesi `Html.AntiForgeryToken()` veya `AntiForgery.GetHtml()`dönüş değeri olacaktır.</span><span class="sxs-lookup"><span data-stu-id="8b471-166">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="8b471-167">Belirteçleri doğrulama</span><span class="sxs-lookup"><span data-stu-id="8b471-167">Validating the tokens</span></span>

<span data-ttu-id="8b471-168">Geliştirici, gelen Anti-XSRF belirteçlerini doğrulamak için, MVC eyleminde veya denetleyicisinde bir [Validateantiforgeri belirteci](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) özniteliği içerir ya da Razor sayfasından `@AntiForgery.Validate()` çağırır.</span><span class="sxs-lookup"><span data-stu-id="8b471-168">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="8b471-169">Çalışma zamanı aşağıdaki adımları gerçekleştirir:</span><span class="sxs-lookup"><span data-stu-id="8b471-169">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="8b471-170">Gelen oturum belirteci ve alan belirteci okunurdur ve her birinden ayıklanan Anti-XSRF belirteci bulunur.</span><span class="sxs-lookup"><span data-stu-id="8b471-170">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="8b471-171">Oluşturma yordamında, Anti-XSRF belirteçleri, adım (2) başına aynı olmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8b471-171">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="8b471-172">Geçerli kullanıcının kimliği doğrulanırsa, Kullanıcı adı, alan belirtecinde depolanan Kullanıcı adı ile karşılaştırılır.</span><span class="sxs-lookup"><span data-stu-id="8b471-172">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="8b471-173">Kullanıcı adları eşleşmelidir.</span><span class="sxs-lookup"><span data-stu-id="8b471-173">The usernames must match.</span></span>
3. <span data-ttu-id="8b471-174">Bir [ıantiforgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) yapılandırılmışsa, çalışma zamanı *validateadditionaldata* yöntemini çağırır.</span><span class="sxs-lookup"><span data-stu-id="8b471-174">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="8b471-175">Yöntem, *true*Boole değerini döndürmelidir.</span><span class="sxs-lookup"><span data-stu-id="8b471-175">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="8b471-176">Doğrulama başarılı olursa, isteğin devam etmesini izin verilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-176">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="8b471-177">Doğrulama başarısız olursa, Framework bir *Httpantiforgero özel durumu*oluşturur.</span><span class="sxs-lookup"><span data-stu-id="8b471-177">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="8b471-178">Hata koşulları</span><span class="sxs-lookup"><span data-stu-id="8b471-178">Failure conditions</span></span>

<span data-ttu-id="8b471-179">ASP.NET Web Stack Runtime v2 ile başlayarak, doğrulama sırasında oluşturulan tüm *Httpantiforgeri özel durumu* , neyin yanlış gittiğini belirten ayrıntılı bilgiler içerir.</span><span class="sxs-lookup"><span data-stu-id="8b471-179">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="8b471-180">Şu anda tanımlı hata koşulları şunlardır:</span><span class="sxs-lookup"><span data-stu-id="8b471-180">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="8b471-181">İstekte oturum belirteci veya form belirteci yok.</span><span class="sxs-lookup"><span data-stu-id="8b471-181">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="8b471-182">Oturum belirteci veya form belirteci okunamaz durumda.</span><span class="sxs-lookup"><span data-stu-id="8b471-182">The session token or form token is unreadable.</span></span> <span data-ttu-id="8b471-183">Bunun en olası nedeni, ASP.NET Web Stack çalışma zamanının eşleşmeyen sürümlerini çalıştıran bir grup veya Web. config dosyasındaki &lt;machineKey&gt; öğesinin makineler arasında farklılık gösterir.</span><span class="sxs-lookup"><span data-stu-id="8b471-183">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="8b471-184">Bu özel durumu, Anti-XSRF belirteci ile izinsiz değişiklik yaparak zorlamak için Fiddler gibi bir araç kullanabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8b471-184">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="8b471-185">Oturum belirteci ve alan belirteci takas edildi.</span><span class="sxs-lookup"><span data-stu-id="8b471-185">The session token and field token were swapped.</span></span>
- <span data-ttu-id="8b471-186">Oturum belirteci ve alan belirteci eşleşmeyen güvenlik belirteçleri içeriyor.</span><span class="sxs-lookup"><span data-stu-id="8b471-186">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="8b471-187">Alan belirteci içine katıştırılmış Kullanıcı adı, oturum açmış olan kullanıcının kullanıcı adıyla eşleşmiyor.</span><span class="sxs-lookup"><span data-stu-id="8b471-187">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="8b471-188">*[Iantiforgeryadditionaldataprovider. ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* yöntemi *false*döndürdü.</span><span class="sxs-lookup"><span data-stu-id="8b471-188">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="8b471-189">Anti-XSRF tesisler, belirtecin oluşturulması veya doğrulanması sırasında de ek denetim gerçekleştirebilir ve bu denetimler sırasında oluşan başarısızlıklar özel durumlar oluşturulmasına neden olabilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-189">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="8b471-190">Daha fazla bilgi için bkz. [WIF/ACS/talepler tabanlı kimlik doğrulaması](#_WIF_ACS) ve **[yapılandırma ve genişletilebilirlik](#_Configuration_and_extensibility)** bölümleri.</span><span class="sxs-lookup"><span data-stu-id="8b471-190">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="8b471-191">Özel desteğe sahip senaryolar</span><span class="sxs-lookup"><span data-stu-id="8b471-191">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="8b471-192">Anonim kimlik doğrulama</span><span class="sxs-lookup"><span data-stu-id="8b471-192">Anonymous authentication</span></span>

<span data-ttu-id="8b471-193">Anti-XSRF sistemi, anonim kullanıcılar için özel destek içerir. burada "anonim", *IIdentity. IsAuthenticated* özelliğinin *false*döndüğü bir kullanıcı olarak tanımlanmıştır.</span><span class="sxs-lookup"><span data-stu-id="8b471-193">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="8b471-194">Senaryolar, oturum açma sayfasında (kullanıcının kimlik doğrulamasından önce) XSRF koruması sağlamayı ve uygulamanın kullanıcıları tanımlamak için *IIdentity* dışında bir mekanizma kullandığı özel kimlik doğrulama düzenlerini içerir.</span><span class="sxs-lookup"><span data-stu-id="8b471-194">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="8b471-195">Bu senaryoları desteklemek için, oturum ve alan belirteçlerinin 128 bitlik bir rastgele oluşturulmuş donuk tanımlayıcı olan bir güvenlik belirteci ile katıldığını geri çekin.</span><span class="sxs-lookup"><span data-stu-id="8b471-195">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="8b471-196">Bu güvenlik belirteci, siteyi gezindiği için tek bir kullanıcının oturumunu izlemek üzere kullanılır, bu nedenle anonim bir tanımlayıcının amacını etkin bir şekilde sunar.</span><span class="sxs-lookup"><span data-stu-id="8b471-196">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="8b471-197">Yukarıda açıklanan oluşturma ve doğrulama yordamlarının Kullanıcı adının yerine boş bir dize kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8b471-197">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="8b471-198">WıF/ACS/talep tabanlı kimlik doğrulaması</span><span class="sxs-lookup"><span data-stu-id="8b471-198">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="8b471-199">Normal olarak, .NET Framework yerleşik olarak bulunan *IIdentity* sınıfları, belirli bir uygulama içinde belirli bir kullanıcıyı benzersiz şekilde tanımlamak için *IIdentity.Name* özelliği vardır.</span><span class="sxs-lookup"><span data-stu-id="8b471-199">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="8b471-200">Örneğin, *FormsIdentity.Name* , üyelik veritabanında depolanan kullanıcı adını döndürür (bu veritabanına bağlı olarak tüm uygulamalar için benzersizdir), *WindowsIdentity.Name* kullanıcının etki alanı nitelikli kimliğini döndürür ve bu şekilde devam eder.</span><span class="sxs-lookup"><span data-stu-id="8b471-200">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="8b471-201">Bu sistemler yalnızca kimlik doğrulaması sağlamaz; kullanıcılar da bir uygulamaya kullanıcıları *belirler* .</span><span class="sxs-lookup"><span data-stu-id="8b471-201">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="8b471-202">Diğer yandan talep tabanlı kimlik doğrulaması, belirli bir kullanıcıyı tanımlamayı gerektirmez.</span><span class="sxs-lookup"><span data-stu-id="8b471-202">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="8b471-203">Bunun yerine, *ClaimsPrincipal* ve *ClaimsIdentity* türleri bir *talep* örnekleri kümesiyle ilişkilendirilir, burada ayrı talepler "18 + yıllık kullanım" veya "yönetici ise" olabilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-203">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="8b471-204">Kullanıcı tanımlı olmadığından, çalışma zamanı bu belirli kullanıcı için benzersiz bir tanımlayıcı olarak *ClaimsIdentity.Name* özelliğini kullanamaz.</span><span class="sxs-lookup"><span data-stu-id="8b471-204">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="8b471-205">Takım, *ClaimsIdentity.Name* ' nin *null*döndüğü, kolay (görünen) bir ad döndürdüğü veya başka bir şekilde Kullanıcı için benzersiz bir tanımlayıcı olarak kullanılması uygun olmayan bir dize döndüren gerçek dünyada örnekleri gördünüz.</span><span class="sxs-lookup"><span data-stu-id="8b471-205">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="8b471-206">Talep tabanlı kimlik doğrulaması kullanan birçok dağıtım, belirli bir şekilde [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) kullanıyor.</span><span class="sxs-lookup"><span data-stu-id="8b471-206">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="8b471-207">ACS, geliştiricilerin tek tek *kimlik sağlayıcılarını* (ADFS, Microsoft hesap sağlayıcısı, Yahoo! gibi OpenID sağlayıcıları, vb.) yapılandırmasına izin verir ve kimlik sağlayıcıları *ad tanımlayıcılarını*döndürür.</span><span class="sxs-lookup"><span data-stu-id="8b471-207">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="8b471-208">Bu ad tanımlayıcıları, e-posta adresi gibi kişisel olarak tanımlanabilir bilgiler (PII) içerebilir veya özel bir kişisel tanımlayıcı (PPıD) gibi anonim olabilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-208">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="8b471-209">Ne olursa olsun, kayıt düzeni (kimlik sağlayıcısı, ad tanımlayıcısı), siteye göz atarken belirli bir kullanıcı için uygun bir izleme belirteci görevi görirken, ASP.NET Web Stack çalışma zamanı, oluştururken Kullanıcı adının yerine kayıt kümesini kullanabilir ve Anti-XSRF alan belirteçleri doğrulanıyor.</span><span class="sxs-lookup"><span data-stu-id="8b471-209">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="8b471-210">Kimlik sağlayıcısı ve ad tanımlayıcısı için belirli URI 'Ler şunlardır:</span><span class="sxs-lookup"><span data-stu-id="8b471-210">The particular URIs for the identity provider and the name identifier are :</span></span>

- `https://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="8b471-211">(daha fazla bilgi için bu [ACS belgesi sayfasına](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) bakın.)</span><span class="sxs-lookup"><span data-stu-id="8b471-211">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="8b471-212">Bir belirteci oluştururken veya doğrularken, ASP.NET Web Stack çalışma zamanı çalışma zamanında bu türlere bağlamayı dener:</span><span class="sxs-lookup"><span data-stu-id="8b471-212">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="8b471-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (WıF SDK Için).</span><span class="sxs-lookup"><span data-stu-id="8b471-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="8b471-214">`System.Security.Claims.ClaimsIdentity` (.NET 4,5 Için).</span><span class="sxs-lookup"><span data-stu-id="8b471-214">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="8b471-215">Bu türler varsa ve geçerli kullanıcının *Iiiıdentity* bu türlerden birini uygularsa veya alt sınıflara alıyorsa, ANTI-XSRF tesisi belirteçleri oluştururken ve doğrularken Kullanıcı adının yerine (kimlik sağlayıcısı, ad tanımlayıcısı) kayıt düzeni kullanır.</span><span class="sxs-lookup"><span data-stu-id="8b471-215">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="8b471-216">Böyle bir tanımlama grubu yoksa, istek, geliştirici ile ilgili belirli kimlik doğrulama mekanizmasını anlamak için anti-XSRF sisteminin nasıl yapılandırılacağı hakkında hata vererek başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="8b471-216">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="8b471-217">Daha fazla bilgi için **[yapılandırma ve genişletilebilirlik](#_Configuration_and_extensibility)** bölümüne bakın.</span><span class="sxs-lookup"><span data-stu-id="8b471-217">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="8b471-218">OAuth/OpenID kimlik doğrulaması</span><span class="sxs-lookup"><span data-stu-id="8b471-218">OAuth / OpenID authentication</span></span>

<span data-ttu-id="8b471-219">Son olarak, Anti-XSRF özelliği OAuth veya OpenID kimlik doğrulaması kullanan uygulamalar için özel desteğe sahiptir.</span><span class="sxs-lookup"><span data-stu-id="8b471-219">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="8b471-220">Bu destek buluşsal-tabanlıdır: geçerli *IIdentity.Name* http://veya https://ile başlıyorsa, Kullanıcı adı karşılaştırmaları varsayılan OrdinalIgnoreCase karşılaştırıcısı yerine bir sıra karşılaştırıcısı kullanılarak yapılır.</span><span class="sxs-lookup"><span data-stu-id="8b471-220">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="8b471-221">Yapılandırma ve genişletilebilirlik</span><span class="sxs-lookup"><span data-stu-id="8b471-221">Configuration and extensibility</span></span>

<span data-ttu-id="8b471-222">Bazen, geliştiriciler Anti-XSRF oluşturma ve doğrulama davranışları üzerinde sıkı bir denetim isteyebilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-222">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="8b471-223">Örneğin, MVC ve Web sayfaları yardımcılarının yanıta HTTP tanımlama bilgilerini otomatik olarak eklemenin varsayılan davranışı istenmeyen bir durum değildir ve geliştirici belirteçleri başka bir yerde kalıcı hale getirmek isteyebilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-223">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="8b471-224">Bunun için yardımcı olacak iki API var:</span><span class="sxs-lookup"><span data-stu-id="8b471-224">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="8b471-225">*GetTokens* metodu, mevcut bir xsrf isteği doğrulama oturum belirtecini (null olabilir) giriş olarak alır ve yenı bir xsrf isteği doğrulama oturumu belirteci ve alan belirteci olarak üretilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-225">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="8b471-226">Belirteçler, dekorasyonu olmadan yalnızca opak dizelerdir; *form belirteci* değeri, örnek bir &lt;girişi&gt; etiketine kaydırılmayacak.</span><span class="sxs-lookup"><span data-stu-id="8b471-226">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="8b471-227">*Newbir ıetoken* değeri null olabilir; Bu durumda, *Oldpişirme ıetoken* değeri hala geçerlidir ve yeni yanıt tanımlama bilgisinin ayarlanması gerekmez.</span><span class="sxs-lookup"><span data-stu-id="8b471-227">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="8b471-228">*GetToken* çağıranı, gerekli yanıt tanımlama bilgilerini kalıcı hale getirmekten veya gerekli biçimlendirme oluşturmaktan sorumludur; *GetTokens* metodu, bir yan etkisi olarak yanıtı değiştirmez.</span><span class="sxs-lookup"><span data-stu-id="8b471-228">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="8b471-229">*Validate* yöntemi, gelen oturum ve alan belirteçlerini alır ve kendileri üzerinde belirtilen doğrulama mantığını çalıştırır.</span><span class="sxs-lookup"><span data-stu-id="8b471-229">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="8b471-230">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="8b471-230">AntiForgeryConfig</span></span>

<span data-ttu-id="8b471-231">Geliştirici, uygulama\_Başlat ' dan Anti-XSRF sistemini yapılandırabilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-231">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="8b471-232">Yapılandırma programlı.</span><span class="sxs-lookup"><span data-stu-id="8b471-232">Configuration is programmatic.</span></span> <span data-ttu-id="8b471-233">Statik *Antiforgeryıconfig* türünün özellikleri aşağıda açıklanmıştır.</span><span class="sxs-lookup"><span data-stu-id="8b471-233">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="8b471-234">Talepler kullanan çoğu kullanıcı, UniqueClaimTypeIdentifier özelliğini ayarlamak ister.</span><span class="sxs-lookup"><span data-stu-id="8b471-234">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="8b471-235">**Özellik**</span><span class="sxs-lookup"><span data-stu-id="8b471-235">**Property**</span></span> | <span data-ttu-id="8b471-236">**Açıklama**</span><span class="sxs-lookup"><span data-stu-id="8b471-236">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="8b471-237">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="8b471-237">**AdditionalDataProvider**</span></span> | <span data-ttu-id="8b471-238">Belirteç oluşturma sırasında ek veriler sağlayan ve belirteç doğrulama sırasında ek veriler tüketen bir [ıantiforgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) .</span><span class="sxs-lookup"><span data-stu-id="8b471-238">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="8b471-239">Varsayılan değer *null*.</span><span class="sxs-lookup"><span data-stu-id="8b471-239">The default value is *null*.</span></span> <span data-ttu-id="8b471-240">Daha fazla bilgi için, bkz. [ıantiforgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) bölümü.</span><span class="sxs-lookup"><span data-stu-id="8b471-240">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="8b471-241">**Tanımlama bilgisi adı**</span><span class="sxs-lookup"><span data-stu-id="8b471-241">**CookieName**</span></span> | <span data-ttu-id="8b471-242">Anti-XSRF oturum belirtecini depolamak için kullanılan HTTP tanımlama bilgisinin adını sağlayan bir dize.</span><span class="sxs-lookup"><span data-stu-id="8b471-242">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="8b471-243">Bu değer ayarlanmamışsa, uygulamanın dağıtılan sanal yoluna göre otomatik olarak bir ad oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="8b471-243">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="8b471-244">Varsayılan değer *null*.</span><span class="sxs-lookup"><span data-stu-id="8b471-244">The default value is *null*.</span></span> |
| <span data-ttu-id="8b471-245">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="8b471-245">**RequireSsl**</span></span> | <span data-ttu-id="8b471-246">Anti-XSRF belirteçlerinin SSL ile güvenli bir kanaldan gönderilmesi gerekip gerekmediğini belirleyen bir Boole değeri.</span><span class="sxs-lookup"><span data-stu-id="8b471-246">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="8b471-247">Bu değer *true*ise, otomatik olarak oluşturulan herhangi bir tanımlama bilgisi "güvenli" bayrak kümesine sahip olur ve SSL aracılığıyla gönderilmemiş bir istek içinden çağrılırsa, ANTI-XSRF API 'leri oluşturulur.</span><span class="sxs-lookup"><span data-stu-id="8b471-247">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="8b471-248">Varsayılan değer *false*'dur.</span><span class="sxs-lookup"><span data-stu-id="8b471-248">The default value is *false*.</span></span> |
| <span data-ttu-id="8b471-249">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="8b471-249">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="8b471-250">Anti-XSRF sisteminin, talep tabanlı kimlikler için desteğini devre dışı bırakıp bırakmayacağını belirleyen bir Boole değeri.</span><span class="sxs-lookup"><span data-stu-id="8b471-250">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="8b471-251">Bu değer *true*ise sistem, *IIdentity.Name* 'in benzersiz bir Kullanıcı başına tanımlayıcı olarak kullanım için uygun olduğunu varsayar ve [WIF/ACS/talepler tabanlı kimlik doğrulama](#_WIF_ACS) bölümünde açıklandığı gibi özel durum *ıımsıdentity* veya *clclaimsıdentity* ' yi denemeyecektir.</span><span class="sxs-lookup"><span data-stu-id="8b471-251">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="8b471-252">Varsayılan değer: `false`.</span><span class="sxs-lookup"><span data-stu-id="8b471-252">The default value is `false`.</span></span> |
| <span data-ttu-id="8b471-253">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="8b471-253">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="8b471-254">Hangi talep türünün benzersiz kullanıcı başına tanımlayıcı olarak kullanım için uygun olduğunu gösteren bir dize.</span><span class="sxs-lookup"><span data-stu-id="8b471-254">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="8b471-255">Bu değer ayarlandıysa ve geçerli *ıidentity* , talepler tabanlıysa, sistem *UniqueClaimTypeIdentifier*tarafından belirtilen türden bir talebi ayıklamayı dener ve alan belirtecini oluştururken kullanıcının Kullanıcı adı yerine ilgili değer kullanılır.</span><span class="sxs-lookup"><span data-stu-id="8b471-255">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="8b471-256">Talep türü bulunamazsa, sistem isteği başarısız olur.</span><span class="sxs-lookup"><span data-stu-id="8b471-256">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="8b471-257">Varsayılan değer, sistemin Kullanıcı Kullanıcı adının yerine daha önce açıklanan (kimlik sağlayıcısı, ad tanımlayıcısı) kayıt kümesini kullanması gerektiğini belirten *null*değeridir.</span><span class="sxs-lookup"><span data-stu-id="8b471-257">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="8b471-258">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="8b471-258">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="8b471-259">*[Iantiforgeryadditionaldataprovider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* türü, geliştiricilerin, her bir belirteçte ek verilere gidiş dönüşü yaparak ANTI-XSRF sisteminin davranışını genişletmesini sağlar.</span><span class="sxs-lookup"><span data-stu-id="8b471-259">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="8b471-260">*Getaddıtionaldata* yöntemi, bir alan belirtecinin oluşturulduğu her seferinde çağrılır ve döndürülen değer oluşturulan belirtecin içine gömülür.</span><span class="sxs-lookup"><span data-stu-id="8b471-260">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="8b471-261">Bir uygulayıcının Bu yöntemden bir zaman damgası, nonce veya başka bir değer döndürmesi olabilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-261">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="8b471-262">Benzer şekilde, *Validateadditionaldata* yöntemi, bir alan belirteci doğrulandığında her seferinde çağrılır ve belirtece gömülü olan "ek veriler" dizesi yöntemine geçirilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-262">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="8b471-263">Doğrulama yordamı, bir zaman aşımı (belirteç oluşturulduğu sırada saklanan zamana karşı geçerli zamanı denetleyerek), bir kerelik bir denetim yordamı veya istediğiniz diğer herhangi bir mantığı uygulayabilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-263">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="8b471-264">Tasarım kararları ve güvenlik konuları</span><span class="sxs-lookup"><span data-stu-id="8b471-264">Design decisions and security considerations</span></span>

<span data-ttu-id="8b471-265">Oturumu ve alan belirteçlerini bağlayan güvenlik belirteci Teknik olarak yalnızca anonim/kimliği doğrulanmamış kullanıcıları XSRF saldırılarına karşı korumaya çalışırken gereklidir.</span><span class="sxs-lookup"><span data-stu-id="8b471-265">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="8b471-266">Kullanıcının kimliği doğrulandığında, kimlik doğrulama belirtecinin kendisi (bir tanımlama bilgisi biçiminde), Eşitleyici belirteç çiftinin bir yarısı olarak kullanılabilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-266">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="8b471-267">Ancak, kimliği doğrulanmamış kullanıcılar tarafından gerçekleştirilen oturum açma sayfalarının korunması için geçerli senaryolar vardır ve güvenlik belirtecini kimliği doğrulanmış kullanıcılar için bile her zaman oluşturup doğrulayarak, Anti-XSRF mantığı daha basit hale getirilir.</span><span class="sxs-lookup"><span data-stu-id="8b471-267">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="8b471-268">Ayrıca, bir alan belirtecinin bir saldırgan tarafından ele geçirilmediği konusunda, oturum belirtecinin ayarlanması veya tahmin edilmemesini sağlamak için başka bir sorumlu olması durumunda da bazı ek koruma sağlar.</span><span class="sxs-lookup"><span data-stu-id="8b471-268">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="8b471-269">Geliştiriciler, birden çok uygulama tek bir etki alanında barındırıldığı zaman dikkatli kullanılmalıdır.</span><span class="sxs-lookup"><span data-stu-id="8b471-269">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="8b471-270">Örneğin, *example1.cloudapp.net* ve *example2.cloudapp.net* farklı konaklar olsa da, *\*. cloudapp.net* etki alanındaki tüm konaklar arasında örtük bir güven ilişkisi vardır.</span><span class="sxs-lookup"><span data-stu-id="8b471-270">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="8b471-271">Bu örtük güven ilişkisi, [Güvenilmeyen ana bilgisayarların birbirlerinin tanımlama bilgilerini etkilemesini sağlar](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (AJAX isteklerini yöneten aynı kaynak ilkeleri http tanımlama bilgilerine uygulanmaz).</span><span class="sxs-lookup"><span data-stu-id="8b471-271">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="8b471-272">ASP.NET Web Stack çalışma zamanı, Kullanıcı adının alan belirtecine katıştırılması açısından bazı hafifletme sağlar, bu nedenle kötü amaçlı bir alt etki alanı bir oturum belirtecinin üzerine yazabileceğinden bile, Kullanıcı için geçerli bir alan belirteci oluşturamayacak.</span><span class="sxs-lookup"><span data-stu-id="8b471-272">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="8b471-273">Bununla birlikte, böyle bir ortamda barındırıldığı zaman, yerleşik anti-XSRF yordamları, oturum ele geçirme veya oturum açma XSRF için de savunamaz.</span><span class="sxs-lookup"><span data-stu-id="8b471-273">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="8b471-274">Anti-XSRF yordamları Şu anda [tıklama mercesine](https://www.owasp.org/index.php/Clickjacking)karşı koruma sağlamaz.</span><span class="sxs-lookup"><span data-stu-id="8b471-274">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="8b471-275">Kendilerini etkileşimli bir şekilde korumak isteyen uygulamalar, bir X-Frame-Options: SAMEORIGIN üst bilgisini her Yanıtla göndererek kolayca bunu yapabilirsiniz.</span><span class="sxs-lookup"><span data-stu-id="8b471-275">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="8b471-276">Bu üst bilgi, tüm son tarayıcılar tarafından desteklenir.</span><span class="sxs-lookup"><span data-stu-id="8b471-276">This header is supported by all recent browsers.</span></span> <span data-ttu-id="8b471-277">Daha fazla bilgi için bkz. [IE blogu](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), [SDL blogu](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)ve [OWASP](https://www.owasp.org/index.php/Clickjacking).</span><span class="sxs-lookup"><span data-stu-id="8b471-277">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="8b471-278">ASP.NET Web Stack çalışma zamanı bazı gelecek sürümlerde olabilir. MVC ve Web sayfaları Anti-XSRF yardımcıları, uygulamaların bu saldırıya karşı otomatik olarak korunması için bu üstbilgiyi otomatik olarak ayarlar.</span><span class="sxs-lookup"><span data-stu-id="8b471-278">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="8b471-279">Web geliştiricileri, sitelerinin XSS saldırılarına karşı savunmasız olmadığından emin olmaya devam etmelidir.</span><span class="sxs-lookup"><span data-stu-id="8b471-279">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="8b471-280">XSS saldırıları çok güçlüdür ve başarılı bir yararlanma işlemi, XSRF saldırılarına karşı ASP.NET Web yığını çalışma zamanı savunmasının de kesintiye uğramasıdır.</span><span class="sxs-lookup"><span data-stu-id="8b471-280">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="8b471-281">Olumlu</span><span class="sxs-lookup"><span data-stu-id="8b471-281">Acknowledgment</span></span>

<span data-ttu-id="8b471-282">[@LeviBroderick](https://twitter.com/LeviBroderick), bu bilgilerin toplu ASP.NET güvenlik kodunun çoğunu yazdı.</span><span class="sxs-lookup"><span data-stu-id="8b471-282">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
